{"version":3,"file":"mobiledoc.cjs","sources":["../src/js/utils/array-utils.ts","../src/js/utils/dom-utils.ts","../src/js/views/view.ts","../src/js/utils/string-utils.ts","../src/js/utils/element-utils.ts","../src/js/utils/markuperable.ts","../src/js/utils/mobiledoc-error.ts","../src/js/utils/assert.ts","../src/js/models/marker.ts","../src/js/utils/keycodes.ts","../src/js/utils/keys.ts","../src/js/utils/characters.ts","../src/js/utils/key.ts","../src/js/utils/selection-utils.ts","../src/js/utils/cursor/range.ts","../src/js/utils/linked-item.ts","../src/js/models/is-list-section.ts","../src/js/models/_section.ts","../src/js/utils/copy.ts","../src/js/models/card.ts","../src/js/models/atom.ts","../src/js/utils/cursor/position.ts","../src/js/editor/ui.ts","../src/js/views/tooltip.ts","../src/js/models/lifecycle-callbacks.ts","../src/js/models/_has-child-sections.ts","../src/js/editor/post/post-inserter.ts","../src/js/utils/deprecate.ts","../src/js/utils/to-range.ts","../src/js/utils/cursor.ts","../src/js/utils/set.ts","../src/js/utils/linked-list.ts","../src/js/models/_tag-nameable.ts","../src/js/models/_markerable.ts","../src/js/models/types.ts","../src/js/utils/object-utils.ts","../src/js/models/_attributable.ts","../src/js/models/list-section.ts","../src/js/models/list-item.ts","../src/js/models/markup-section.ts","../src/js/editor/post.ts","../src/js/utils/placeholder-image-src.ts","../src/js/cards/image.ts","../src/js/parsers/mobiledoc/0-2.ts","../src/js/parsers/mobiledoc/0-3.ts","../src/js/parsers/mobiledoc/0-3-1.ts","../src/js/parsers/mobiledoc/0-3-2.ts","../src/js/utils/compiler.ts","../src/js/renderers/mobiledoc/0-2.ts","../src/js/renderers/mobiledoc/0-3.ts","../src/js/renderers/mobiledoc/0-3-1.ts","../src/js/renderers/mobiledoc/0-3-2.ts","../src/js/parsers/mobiledoc/index.ts","../src/js/models/card-node.ts","../src/js/models/atom-node.ts","../src/js/renderers/editor-dom.ts","../src/js/models/markup.ts","../src/js/parsers/section.ts","../src/js/parsers/dom.ts","../src/js/parsers/html.ts","../src/js/models/render-node.ts","../src/js/utils/element-map.ts","../src/js/models/render-tree.ts","../src/js/renderers/mobiledoc/index.ts","../src/js/utils/merge.ts","../src/js/utils/environment.ts","../src/js/models/_cloneable.ts","../src/js/models/post.ts","../src/js/models/image.ts","../src/js/models/post-node-builder.ts","../src/js/editor/text-input-handlers.ts","../src/js/utils/browser.ts","../src/js/editor/key-commands.ts","../src/js/editor/mutation-handler.ts","../src/js/utils/fixed-queue.ts","../src/js/editor/edit-history.ts","../src/js/parsers/text.ts","../src/js/utils/parse-utils.ts","../src/js/editor/text-input-handler.ts","../src/js/editor/selection-change-observer.ts","../src/js/editor/selection-manager.ts","../src/js/editor/event-manager.ts","../src/js/editor/edit-state.ts","../node_modules/mobiledoc-dom-renderer/lib/utils/dom.js","../node_modules/mobiledoc-dom-renderer/lib/utils/render-type.js","../node_modules/mobiledoc-dom-renderer/lib/cards/image.js","../node_modules/mobiledoc-dom-renderer/lib/utils/section-types.js","../node_modules/mobiledoc-dom-renderer/lib/utils/tag-names.js","../node_modules/mobiledoc-dom-renderer/lib/utils/array-utils.js","../node_modules/mobiledoc-dom-renderer/lib/utils/sanitization-utils.js","../node_modules/mobiledoc-dom-renderer/lib/utils/render-utils.js","../node_modules/mobiledoc-dom-renderer/lib/renderers/0-2.js","../node_modules/mobiledoc-dom-renderer/lib/utils/marker-types.js","../node_modules/mobiledoc-dom-renderer/lib/renderers/0-3.js","../node_modules/mobiledoc-dom-renderer/lib/renderer-factory.js","../node_modules/mobiledoc-text-renderer/lib/cards/image.js","../node_modules/mobiledoc-text-renderer/lib/utils/render-type.js","../node_modules/mobiledoc-text-renderer/lib/utils/section-types.js","../node_modules/mobiledoc-text-renderer/lib/renderers/0-2.js","../node_modules/mobiledoc-text-renderer/lib/utils/marker-types.js","../node_modules/mobiledoc-text-renderer/lib/renderers/0-3.js","../node_modules/mobiledoc-text-renderer/lib/renderer-factory.js","../src/js/utils/log-manager.ts","../src/js/editor/editor.ts","../src/js/version.ts"],"sourcesContent":["import { Dict } from './types'\n\ninterface Detectable<T> {\n  detect(cb: (val: T) => boolean): T\n}\n\nexport interface HasLength<T> {\n  length: number\n}\n\nexport interface Indexable<T> {\n  [key: number]: T\n  length: number\n}\n\nexport function detect<T>(enumerable: Detectable<T> | Indexable<T>, callback: (val: T) => boolean): T | undefined {\n  if ('detect' in enumerable) {\n    return enumerable.detect(callback)\n  } else {\n    for (let i = 0; i < enumerable.length; i++) {\n      if (callback(enumerable[i])) {\n        return enumerable[i]\n      }\n    }\n  }\n}\n\ninterface Anyable<T> {\n  any(cb: (val: T) => boolean): boolean\n}\n\nexport function any<T>(enumerable: Anyable<T> | Indexable<T>, callback: (val: T) => boolean): boolean {\n  if ('any' in enumerable) {\n    return enumerable.any(callback)\n  }\n\n  for (let i = 0; i < enumerable.length; i++) {\n    if (callback(enumerable[i])) {\n      return true\n    }\n  }\n\n  return false\n}\n\ninterface Everyable<T> {\n  every(cb: (val: T) => boolean): boolean\n}\n\nexport function every<T>(enumerable: Everyable<T> | Indexable<T>, callback: (val: T) => boolean): boolean {\n  if ('every' in enumerable) {\n    return enumerable.every(callback)\n  }\n\n  for (let i = 0; i < enumerable.length; i++) {\n    if (!callback(enumerable[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function toArray<T>(arrayLike: ArrayLike<T>): T[] {\n  return Array.prototype.slice.call(arrayLike)\n}\n\nexport interface ForEachable<T> {\n  forEach(cb: (val: T, idx: number) => void): void\n}\n\n/**\n * Useful for array-like things that aren't\n * actually arrays, like NodeList\n * @private\n */\nexport function forEach<T>(enumerable: ForEachable<T> | Indexable<T>, callback: (val: T, idx: number) => void): void {\n  if ('forEach' in enumerable) {\n    enumerable.forEach(callback)\n  } else {\n    for (let i = 0; i < enumerable.length; i++) {\n      callback(enumerable[i], i)\n    }\n  }\n}\n\nexport function filter<T>(enumerable: ForEachable<T>, conditionFn: (val: T) => boolean) {\n  const filtered: T[] = []\n\n  forEach(enumerable, i => {\n    if (conditionFn(i)) {\n      filtered.push(i)\n    }\n  })\n\n  return filtered\n}\n\n/**\n * @return {Integer} the number of items that are the same, starting from the 0th index, in a and b\n * @private\n */\nexport function commonItemLength(listA: ArrayLike<unknown>, listB: ArrayLike<unknown>) {\n  let offset = 0\n\n  while (offset < listA.length && offset < listB.length) {\n    if (listA[offset] !== listB[offset]) {\n      break\n    }\n    offset++\n  }\n\n  return offset\n}\n\n/**\n * @return {Array} the items that are the same, starting from the 0th index, in a and b\n * @private\n */\nexport function commonItems<T>(listA: T[], listB: T[]): T[] {\n  let offset = 0\n\n  while (offset < listA.length && offset < listB.length) {\n    if (listA[offset] !== listB[offset]) {\n      break\n    }\n    offset++\n  }\n\n  return listA.slice(0, offset)\n}\n\n// return new array without falsy items like ruby's `compact`\nexport function compact<T>(enumerable: ForEachable<T>) {\n  return filter(enumerable, i => !!i)\n}\n\nexport function reduce<T, U>(\n  enumerable: ForEachable<T>,\n  callback: (prev: U, val: T, index: number) => U,\n  initialValue: U\n): U {\n  let previousValue = initialValue\n\n  forEach(enumerable, (val, index) => {\n    previousValue = callback(previousValue, val, index)\n  })\n\n  return previousValue\n}\n\n/**\n * @param {Array} array of key1,value1,key2,value2,...\n * @return {Object} {key1:value1, key2:value2, ...}\n * @private\n */\nexport function kvArrayToObject<T>(array: (T | string)[]): { [key: string]: T } {\n  const obj: { [key: string]: T } = {}\n\n  for (let i = 0; i < array.length; i += 2) {\n    let [key, value] = [array[i], array[i + 1]]\n    obj[key as string] = value as T\n  }\n\n  return obj\n}\n\nexport function objectToSortedKVArray<T extends {}>(obj: T): (keyof T | T[keyof T])[] {\n  const keys = Object.keys(obj).sort() as (keyof T)[]\n  const result: (keyof T | T[keyof T])[] = []\n\n  keys.forEach(k => {\n    result.push(k)\n    result.push(obj[k])\n  })\n\n  return result\n}\n\n// check shallow equality of two non-nested arrays\nexport function isArrayEqual<T>(arr1: ArrayLike<T>, arr2: ArrayLike<T>): boolean {\n  let l1 = arr1.length\n  let l2 = arr2.length\n\n  if (l1 !== l2) {\n    return false\n  }\n\n  for (let i = 0; i < l1; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// return an object with only the valid keys\nexport function filterObject<T>(object: Dict<T>, validKeys: string[] = []) {\n  let result: Dict<T> = {}\n\n  forEach(\n    filter(Object.keys(object), key => validKeys.indexOf(key) !== -1),\n    key => (result[key] = (object as any)[key])\n  )\n\n  return result\n}\n\nexport function contains<T>(array: T[], item: T): boolean {\n  return array.indexOf(item) !== -1\n}\n\nexport function values<T extends {}>(object: T): T[keyof T][] {\n  return (Object.keys(object) as (keyof T)[]).map(key => object[key])\n}\n","import { forEach } from './array-utils'\nimport { Dict } from './types'\n\nexport const NODE_TYPES = {\n  ELEMENT: 1,\n  TEXT: 3,\n  COMMENT: 8,\n}\n\nexport function isTextNode(node: Node): node is Text {\n  return node.nodeType === NODE_TYPES.TEXT\n}\n\nexport function isCommentNode(node: Node): node is Comment {\n  return node.nodeType === NODE_TYPES.COMMENT\n}\n\nexport function isElementNode(node: Node): node is Element {\n  return node.nodeType === NODE_TYPES.ELEMENT\n}\n\n// perform a pre-order tree traversal of the dom, calling `callbackFn(node)`\n// for every node for which `conditionFn(node)` is true\nexport function walkDOM(\n  topNode: Node,\n  callbackFn: (node: Node) => void = () => {},\n  conditionFn: (node: Node) => boolean = () => true\n) {\n  let currentNode: Node | null = topNode\n\n  if (conditionFn(currentNode)) {\n    callbackFn(currentNode)\n  }\n\n  currentNode = currentNode.firstChild\n\n  while (currentNode) {\n    walkDOM(currentNode, callbackFn, conditionFn)\n    currentNode = currentNode.nextSibling\n  }\n}\n\nexport function walkTextNodes(topNode: Node, callbackFn = () => {}) {\n  const conditionFn = (node: Node) => isTextNode(node)\n  walkDOM(topNode, callbackFn, conditionFn)\n}\n\nexport function clearChildNodes(element: Element) {\n  while (element.childNodes.length) {\n    element.removeChild(element.childNodes[0])\n  }\n}\n\n/**\n * @return {Boolean} true when the child node is contained or the same as\n * (e.g., inclusive containment)  the parent node\n *  see https://github.com/webmodules/node-contains/blob/master/index.js\n *  Mimics the behavior of `Node.contains`, which is broken in IE 10\n *  @private\n */\nexport function containsNode(parentNode: Node, childNode: Node) {\n  if (parentNode === childNode) {\n    return true\n  }\n  const position = parentNode.compareDocumentPosition(childNode)\n  return !!(position & Node.DOCUMENT_POSITION_CONTAINED_BY)\n}\n\n/**\n * converts the element's NamedNodeMap of attrs into\n * an object with key-value pairs\n * @param {DOMNode} element\n * @return {Object} key-value pairs\n * @private\n */\nexport function getAttributes(element: Element): Dict<string> {\n  const result: Dict<string> = {}\n  if (element.hasAttributes()) {\n    forEach(element.attributes, ({ name, value }) => {\n      result[name] = value\n    })\n  }\n  return result\n}\n\nexport function addClassName(element: Element, className: string) {\n  element.classList.add(className)\n}\n\nexport function removeClassName(element: Element, className: string) {\n  element.classList.remove(className)\n}\n\nexport function normalizeTagName(tagName: string) {\n  return tagName.toLowerCase()\n}\n\nexport function parseHTML(html: string) {\n  const div = document.createElement('div')\n  div.innerHTML = html\n  return div\n}\n\nexport function serializeHTML(node: Node) {\n  const div = document.createElement('div')\n  div.appendChild(node)\n  return div.innerHTML\n}\n","import { addClassName } from '../utils/dom-utils'\n\ninterface ViewOptions {\n  tagName: string\n  container: HTMLElement\n  classNames: string[]\n}\n\ntype EventType = keyof HTMLElementEventMap\n\nclass View {\n  element: HTMLElement\n  container: HTMLElement\n\n  isShowing: boolean = false\n  isDestroyed: boolean = false\n\n  _eventListeners: [HTMLElement, EventType, EventListener][]\n\n  constructor(options: Partial<ViewOptions> = {}) {\n    options.tagName = options.tagName || 'div'\n    options.container = options.container || document.body\n\n    this.element = document.createElement(options.tagName)\n    this.container = options.container\n\n    let classNames = options.classNames || []\n    classNames.forEach(name => addClassName(this.element, name))\n    this._eventListeners = []\n  }\n\n  addEventListener(element: HTMLElement, type: EventType, listener: EventListener) {\n    element.addEventListener(type, listener)\n    this._eventListeners.push([element, type, listener])\n  }\n\n  removeAllEventListeners() {\n    this._eventListeners.forEach(([element, type, listener]) => {\n      element.removeEventListener(type, listener)\n    })\n  }\n\n  show() {\n    if (!this.isShowing) {\n      this.container.appendChild(this.element)\n      this.isShowing = true\n      return true\n    }\n  }\n\n  hide() {\n    if (this.isShowing) {\n      this.container.removeChild(this.element)\n      this.isShowing = false\n      return true\n    }\n  }\n\n  destroy() {\n    this.removeAllEventListeners()\n    this.hide()\n    this.isDestroyed = true\n  }\n}\n\nexport default View\n","/*\n * @param {String} string\n * @return {String} a dasherized string. 'modelIndex' -> 'model-index', etc\n */\nexport function dasherize(string: string) {\n  return string.replace(/[A-Z]/g, (match, offset) => {\n    const lower = match.toLowerCase()\n\n    return offset === 0 ? lower : '-' + lower\n  })\n}\n\nexport function capitalize(string: string) {\n  return string.charAt(0).toUpperCase() + string.slice(1)\n}\n\nexport function startsWith(string: string, character: string) {\n  return string.charAt(0) === character\n}\n\nexport function endsWith(string: string, endString: string) {\n  let index = string.lastIndexOf(endString)\n  return index !== -1 && index === string.length - endString.length\n}\n","import { dasherize } from './string-utils'\nimport { normalizeTagName } from './dom-utils'\n\nexport function getEventTargetMatchingTag(tagName: string, target: HTMLElement | null, container: HTMLElement) {\n  tagName = normalizeTagName(tagName)\n  // Traverses up DOM from an event target to find the node matching specifed tag\n  while (target && target !== container) {\n    if (normalizeTagName(target.tagName) === tagName) {\n      return target\n    }\n    target = target.parentElement\n  }\n}\n\nexport function getElementRelativeOffset(element: HTMLElement) {\n  const offset = { left: 0, top: -window.pageYOffset }\n  const offsetParent = element.offsetParent!\n  const offsetParentPosition = window.getComputedStyle(offsetParent).position\n  let offsetParentRect\n\n  if (offsetParentPosition === 'relative') {\n    offsetParentRect = offsetParent.getBoundingClientRect()\n    offset.left = offsetParentRect.left\n    offset.top = offsetParentRect.top\n  }\n  return offset\n}\n\ntype StringPropertyNames<T> = { [K in keyof T]: T[K] extends string ? K : never }[keyof T]\n\nexport function getElementComputedStyleNumericProp(\n  element: HTMLElement,\n  prop: StringPropertyNames<CSSStyleDeclaration>\n) {\n  return parseFloat(window.getComputedStyle(element)[prop])\n}\n\nexport function positionElementToRect(element: HTMLElement, rect: ClientRect, topOffset: number, leftOffset: number) {\n  const relativeOffset = getElementRelativeOffset(element)\n  const style = element.style\n  const round = Math.round\n  let left, top\n\n  topOffset = topOffset || 0\n  leftOffset = leftOffset || 0\n  left = round(rect.left - relativeOffset.left - leftOffset)\n  top = round(rect.top + rect.height - relativeOffset.top - topOffset)\n  style.left = `${left}px`\n  style.top = `${top}px`\n  return { left: left, top: top }\n}\n\nexport function positionElementHorizontallyCenteredToRect(element: HTMLElement, rect: ClientRect, topOffset: number) {\n  const horizontalCenter = element.offsetWidth / 2 - rect.width / 2\n  return positionElementToRect(element, rect, topOffset, horizontalCenter)\n}\n\nexport function positionElementCenteredBelow(element: HTMLElement, belowElement: HTMLElement) {\n  const elementMargin = getElementComputedStyleNumericProp(element, 'marginTop')\n  return positionElementHorizontallyCenteredToRect(element, belowElement.getBoundingClientRect(), -elementMargin)\n}\n\nexport function setData(element: HTMLElement, name: string, value: string) {\n  if (element.dataset) {\n    element.dataset[name] = value\n  } else {\n    const dataName = dasherize(name)\n    return element.setAttribute(dataName, value)\n  }\n}\n\nexport interface Cancelable {\n  cancel(): void\n}\n\nexport function whenElementIsNotInDOM(element: HTMLElement, callback: () => void): Cancelable {\n  let isCanceled = false\n  const observerFn = () => {\n    if (isCanceled) {\n      return\n    }\n    if (!element.parentNode) {\n      callback()\n    } else {\n      window.requestAnimationFrame(observerFn)\n    }\n  }\n  observerFn()\n  return { cancel: () => (isCanceled = true) }\n}\n","import { normalizeTagName } from './dom-utils'\nimport { detect, commonItemLength, forEach, filter } from './array-utils'\nimport { Option } from './types'\nimport Markup from '../models/markup'\nimport RenderNode from '../models/render-node'\nimport { Type } from '../models/types'\nimport Markerable from '../models/_markerable'\n\ntype MarkupCallback = (markup: Markup) => boolean\ntype MarkupOrMarkupCallback = Markup | MarkupCallback\n\nexport default abstract class Markuperable {\n  markups: Markup[] = []\n\n  prev: this | null = null\n  next: this | null = null\n\n  isAtom = false\n  isMarker = false\n\n  section: Option<Markerable> = null\n  parent: Option<Markerable> = null\n\n  renderNode: RenderNode | null = null\n\n  abstract text: string\n  abstract value: string\n  abstract type: Type\n  abstract length: number\n  abstract clone(): Markuperable\n  abstract isBlank: boolean\n  abstract canJoin(other: Markuperable): boolean\n  abstract textUntil(offset: number): string\n  abstract splitAtOffset(offset: number): [Markuperable, Markuperable]\n\n  charAt(offset: number) {\n    return this.value.slice(offset, offset + 1)\n  }\n\n  clearMarkups() {\n    this.markups = []\n  }\n\n  addMarkup(markup: Markup) {\n    this.markups.push(markup)\n  }\n\n  addMarkupAtIndex(markup: Markup, index: number) {\n    this.markups.splice(index, 0, markup)\n  }\n\n  removeMarkup(markupOrMarkupCallback: MarkupOrMarkupCallback) {\n    let callback: MarkupCallback\n    if (typeof markupOrMarkupCallback === 'function') {\n      callback = markupOrMarkupCallback as MarkupCallback\n    } else {\n      let markup = markupOrMarkupCallback\n      callback = _markup => _markup === markup\n    }\n\n    forEach(filter(this.markups, callback), m => this._removeMarkup(m))\n  }\n\n  _removeMarkup(markup: Markup) {\n    const index = this.markups.indexOf(markup)\n    if (index !== -1) {\n      this.markups.splice(index, 1)\n    }\n  }\n\n  hasMarkup(tagNameOrMarkup: string | Markup) {\n    return !!this.getMarkup(tagNameOrMarkup)\n  }\n\n  getMarkup(tagNameOrMarkup: string | Markup) {\n    if (typeof tagNameOrMarkup === 'string') {\n      let tagName = normalizeTagName(tagNameOrMarkup)\n      return detect(this.markups, markup => markup.tagName === tagName)\n    } else {\n      let targetMarkup = tagNameOrMarkup\n      return detect(this.markups, markup => markup === targetMarkup)\n    }\n  }\n\n  get openedMarkups() {\n    let count = 0\n    if (this.prev) {\n      count = commonItemLength(this.markups, this.prev.markups)\n    }\n\n    return this.markups.slice(count)\n  }\n\n  get closedMarkups() {\n    let count = 0\n    if (this.next) {\n      count = commonItemLength(this.markups, this.next.markups)\n    }\n\n    return this.markups.slice(count)\n  }\n}\n","export default class MobiledocError extends Error {}\n","import MobiledocError from './mobiledoc-error'\n\nexport default function assert(message: string, conditional: unknown): asserts conditional {\n  if (!conditional) {\n    throw new MobiledocError(message)\n  }\n}\n\nexport function assertExistsIn<T>(message: string, key: string, object: T): asserts key is string & keyof T {\n  assert(message, key in object)\n}\n\nexport function assertNotNull<T>(message: string, value: T | null): asserts value is T {\n  if (value === null) {\n    throw new MobiledocError(message)\n  }\n}\n\nexport function assertType<T>(message: string, _value: any, conditional: boolean): asserts _value is T {\n  assert(message, conditional)\n}\n\nexport function expect<T>(value: T | null | undefined, message: string): T {\n  if (value === null || value === undefined) {\n    throw new MobiledocError(message)\n  }\n  return value\n}\n\nexport function unwrap<T>(value: T | null | undefined): T {\n  return expect(value, 'expected value to not be null or undefined')\n}\n","import { isArrayEqual } from '../utils/array-utils'\nimport Markuperable from '../utils/markuperable'\nimport assert from '../utils/assert'\nimport { Type } from './types'\nimport Markup from './markup'\nimport RenderNode from './render-node'\nimport PostNodeBuilder, { PostNode } from './post-node-builder'\n\n// Unicode uses a pair of \"surrogate\" characters\" (a high- and low-surrogate)\n// to encode characters outside the basic multilingual plane (like emoji and\n// some languages).\n// These values are the unicode code points for the start and end of the\n// high- and low-surrogate characters.\n// See \"high surrogate\" and \"low surrogate\" on\n// https://en.wikipedia.org/wiki/Unicode_block\nexport const HIGH_SURROGATE_RANGE = [0xd800, 0xdbff]\nexport const LOW_SURROGATE_RANGE = [0xdc00, 0xdfff]\n\nexport default class Marker extends Markuperable {\n  type: Type = Type.MARKER\n  isMarker = true\n\n  value: string\n\n  builder!: PostNodeBuilder\n  markups: Markup[] = []\n  renderNode: RenderNode | null = null\n\n  constructor(value = '', markups: Markup[] = []) {\n    super()\n    this.value = value\n    assert('Marker must have value', value !== undefined && value !== null)\n    markups.forEach(m => this.addMarkup(m))\n  }\n\n  clone() {\n    const clonedMarkups = this.markups.slice()\n    return this.builder.createMarker(this.value, clonedMarkups)\n  }\n\n  get isEmpty() {\n    return this.isBlank\n  }\n\n  get isBlank() {\n    return this.length === 0\n  }\n\n  /**\n   * A marker's text is equal to its value.\n   * Compare with an Atom which distinguishes between text and value\n   */\n  get text() {\n    return this.value\n  }\n\n  get length() {\n    return this.value.length\n  }\n\n  // delete the character at this offset,\n  // update the value with the new value\n  deleteValueAtOffset(offset: number) {\n    assert('Cannot delete value at offset outside bounds', offset >= 0 && offset <= this.length)\n\n    let width = 1\n    let code = this.value.charCodeAt(offset)\n    if (code >= HIGH_SURROGATE_RANGE[0] && code <= HIGH_SURROGATE_RANGE[1]) {\n      width = 2\n    } else if (code >= LOW_SURROGATE_RANGE[0] && code <= LOW_SURROGATE_RANGE[1]) {\n      width = 2\n      offset = offset - 1\n    }\n\n    const [left, right] = [this.value.slice(0, offset), this.value.slice(offset + width)]\n    this.value = left + right\n\n    return width\n  }\n\n  canJoin(other: Marker) {\n    return other && other.isMarker && isArrayEqual(this.markups, other.markups)\n  }\n\n  textUntil(offset: number) {\n    return this.value.slice(0, offset)\n  }\n\n  split(offset = 0, endOffset = this.length) {\n    let markers: [Marker, Marker, Marker] = [\n      this.builder.createMarker(this.value.substring(0, offset)),\n      this.builder.createMarker(this.value.substring(offset, endOffset)),\n      this.builder.createMarker(this.value.substring(endOffset)),\n    ]\n\n    this.markups.forEach(mu => markers.forEach(m => m.addMarkup(mu)))\n    return markers\n  }\n\n  /**\n   * @return {Array} 2 markers either or both of which could be blank\n   */\n  splitAtOffset(offset: number): [Marker, Marker] {\n    assert('Cannot split a marker at an offset > its length', offset <= this.length)\n    let { value, builder } = this\n\n    let pre = builder.createMarker(value.substring(0, offset))\n    let post = builder.createMarker(value.substring(offset))\n\n    this.markups.forEach(markup => {\n      pre.addMarkup(markup)\n      post.addMarkup(markup)\n    })\n\n    return [pre, post]\n  }\n}\n\nexport function isMarker(postNode: PostNode): postNode is Marker {\n  return postNode.type === Type.MARKER\n}\n","export default <const>{\n  BACKSPACE: 8,\n  SPACE: 32,\n  ENTER: 13,\n  SHIFT: 16,\n  ESC: 27,\n  DELETE: 46,\n  '0': 48,\n  '9': 57,\n  A: 65,\n  Z: 90,\n  a: 97,\n  z: 122,\n  NUMPAD_0: 186,\n  NUMPAD_9: 111,\n  ';': 186,\n  '.': 190,\n  '`': 192,\n  '[': 219,\n  '\"': 222,\n\n  // Input Method Editor uses multiple keystrokes to display characters.\n  // Example on mac: press option-i then i. This fires 2 key events in Chrome\n  // with keyCode 229 and displays ˆ and then î.\n  // See http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html#fixed-virtual-key-codes\n  IME: 229,\n\n  TAB: 9,\n  CLEAR: 12,\n  PAUSE: 19,\n  PAGEUP: 33,\n  PAGEDOWN: 34,\n  END: 35,\n  HOME: 36,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  INS: 45,\n  META: 91,\n  ALT: 18,\n  CTRL: 17,\n}\n","export default {\n  BACKSPACE: 'Backspace',\n  SPACE: ' ',\n  ENTER: 'Enter',\n  SHIFT: 'Shift',\n  ESC: 'Escape',\n  DELETE: 'Delete',\n  INS: 'Insert',\n  HOME: 'Home',\n  END: 'End',\n  PAGEUP: 'PageUp',\n  PAGEDOWN: 'PageDown',\n  CLEAR: 'Clear',\n  PAUSE: 'Pause',\n  TAB: 'Tab',\n  ALT: 'Alt',\n  CTRL: 'Control',\n\n  LEFT: 'ArrowLeft',\n  RIGHT: 'ArrowRight',\n  UP: 'ArrowUp',\n  DOWN: 'ArrowDown',\n}\n","export const TAB = '\\t'\nexport const ENTER = '\\n'\nexport const SPACE = ' '\n","import Keycodes from './keycodes'\nimport Keys from './keys'\nimport assert from './assert'\nimport { TAB } from './characters'\nimport { Dict } from './types'\n\nexport enum Direction {\n  FORWARD = 1,\n  BACKWARD = -1,\n}\n\n// For backwards compatibility\nexport { Direction as DIRECTION }\n\nexport const MODIFIERS: Dict<number> = {\n  META: 1, // also called \"command\" on OS X\n  CTRL: 2,\n  SHIFT: 4,\n  ALT: 8, // also called \"option\" on OS X\n}\n\nexport function modifierMask(event: KeyboardEvent) {\n  let { metaKey, shiftKey, ctrlKey, altKey } = event\n  let modVal = (val: boolean, modifier: number) => {\n    return (val && modifier) || 0\n  }\n\n  return (\n    modVal(metaKey, MODIFIERS.META) +\n    modVal(shiftKey, MODIFIERS.SHIFT) +\n    modVal(ctrlKey, MODIFIERS.CTRL) +\n    modVal(altKey, MODIFIERS.ALT)\n  )\n}\n\nconst SPECIAL_KEYS: Dict<number> = {\n  BACKSPACE: Keycodes.BACKSPACE,\n  TAB: Keycodes.TAB,\n  ENTER: Keycodes.ENTER,\n  ESC: Keycodes.ESC,\n  SPACE: Keycodes.SPACE,\n  PAGEUP: Keycodes.PAGEUP,\n  PAGEDOWN: Keycodes.PAGEDOWN,\n  END: Keycodes.END,\n  HOME: Keycodes.HOME,\n  LEFT: Keycodes.LEFT,\n  UP: Keycodes.UP,\n  RIGHT: Keycodes.RIGHT,\n  DOWN: Keycodes.DOWN,\n  INS: Keycodes.INS,\n  DEL: Keycodes.DELETE,\n}\n\nexport function specialCharacterToCode(specialCharacter: keyof typeof SPECIAL_KEYS | string): number {\n  return SPECIAL_KEYS[specialCharacter]\n}\n\n// heuristic for determining if `event` is a key event\nfunction isKeyEvent(event: Event) {\n  return /^key/.test(event.type)\n}\n\n/**\n * An abstraction around a KeyEvent\n * that key listeners in the editor can use\n * to determine what sort of key was pressed\n */\nexport default class Key {\n  key: string\n  keyCode: number\n  charCode: number\n  event: KeyboardEvent\n  modifierMask: number\n\n  constructor(event: KeyboardEvent) {\n    this.key = event.key\n    this.keyCode = event.keyCode\n    this.charCode = event.charCode\n    this.event = event\n    this.modifierMask = modifierMask(event)\n  }\n\n  static fromEvent(event: KeyboardEvent) {\n    assert('Must pass a Key event to Key.fromEvent', event && isKeyEvent(event))\n    return new Key(event)\n  }\n\n  toString() {\n    if (this.isTab()) {\n      return TAB\n    }\n    return String.fromCharCode(this.charCode)\n  }\n\n  // See https://caniuse.com/#feat=keyboardevent-key for browser support.\n  isKeySupported() {\n    return this.key\n  }\n\n  isKey(identifier: keyof typeof Keys) {\n    if (this.isKeySupported()) {\n      assert(`Must define Keys.${identifier}.`, !!Keys[identifier])\n      return this.key === Keys[identifier]\n    } else {\n      assert(`Must define Keycodes.${identifier}.`, !!Keycodes[identifier])\n      return this.keyCode === Keycodes[identifier]\n    }\n  }\n\n  isEscape() {\n    return this.isKey('ESC')\n  }\n\n  isDelete() {\n    return this.isKey('BACKSPACE') || this.isForwardDelete()\n  }\n\n  isForwardDelete() {\n    return this.isKey('DELETE')\n  }\n\n  isArrow() {\n    return this.isHorizontalArrow() || this.isVerticalArrow()\n  }\n\n  isHorizontalArrow() {\n    return this.isLeftArrow() || this.isRightArrow()\n  }\n\n  isHorizontalArrowWithoutModifiersOtherThanShift() {\n    return this.isHorizontalArrow() && !(this.ctrlKey || this.metaKey || this.altKey)\n  }\n\n  isVerticalArrow() {\n    return this.isKey('UP') || this.isKey('DOWN')\n  }\n\n  isLeftArrow() {\n    return this.isKey('LEFT')\n  }\n\n  isRightArrow() {\n    return this.isKey('RIGHT')\n  }\n\n  isHome() {\n    return this.isKey('HOME')\n  }\n\n  isEnd() {\n    return this.isKey('END')\n  }\n\n  isPageUp() {\n    return this.isKey('PAGEUP')\n  }\n\n  isPageDown() {\n    return this.isKey('PAGEDOWN')\n  }\n\n  isInsert() {\n    return this.isKey('INS')\n  }\n\n  isClear() {\n    return this.isKey('CLEAR')\n  }\n\n  isPause() {\n    return this.isKey('PAUSE')\n  }\n\n  isSpace() {\n    return this.isKey('SPACE')\n  }\n\n  // In Firefox, pressing ctrl-TAB will switch to another open browser tab, but\n  // it will also fire a keydown event for the tab+modifier (ctrl). This causes\n  // Mobiledoc to erroneously insert a tab character before FF switches to the\n  // new browser tab.  Chrome doesn't fire this event so the issue doesn't\n  // arise there. Fix this by returning false when the TAB key event includes a\n  // modifier.\n  // See: https://github.com/bustle/mobiledoc-kit/issues/565\n  isTab() {\n    return !this.hasAnyModifier() && this.isKey('TAB')\n  }\n\n  isEnter() {\n    return this.isKey('ENTER')\n  }\n\n  /*\n   * If the key is the actual shift key. This is false when the shift key\n   * is held down and the source `event` is not the shift key.\n   * @see {isShift}\n   * @return {bool}\n   */\n  isShiftKey() {\n    return this.isKey('SHIFT')\n  }\n\n  /*\n   * If the key is the actual alt key (aka \"option\" on mac). This is false when the alt key\n   * is held down and the source `event` is not the alt key.\n   * @return {bool}\n   */\n  isAltKey() {\n    return this.isKey('ALT')\n  }\n\n  /*\n   * If the key is the actual ctrl key. This is false when the ctrl key\n   * is held down and the source `event` is not the ctrl key.\n   * @return {bool}\n   */\n  isCtrlKey() {\n    return this.isKey('CTRL')\n  }\n\n  isIME() {\n    // FIXME the IME action seems to get lost when we issue an\n    // `editor.deleteSelection` before it (in Chrome)\n    return this.keyCode === Keycodes.IME\n  }\n\n  get direction() {\n    switch (true) {\n      case this.isDelete():\n        return this.isForwardDelete() ? Direction.FORWARD : Direction.BACKWARD\n      case this.isHorizontalArrow():\n        return this.isRightArrow() ? Direction.FORWARD : Direction.BACKWARD\n      default:\n        return Direction.FORWARD\n    }\n  }\n\n  /**\n   * If the shift key is depressed.\n   * For example, while holding down meta+shift, pressing the \"v\"\n   * key would result in an event whose `Key` had `isShift()` with a truthy value,\n   * because the shift key is down when pressing the \"v\".\n   * @see {isShiftKey} which checks if the key is actually the shift key itself.\n   * @return {bool}\n   */\n  isShift() {\n    return this.shiftKey\n  }\n\n  hasModifier(modifier: number) {\n    return modifier & this.modifierMask\n  }\n\n  hasAnyModifier() {\n    return !!this.modifierMask\n  }\n\n  get ctrlKey() {\n    return MODIFIERS.CTRL & this.modifierMask\n  }\n\n  get metaKey() {\n    return MODIFIERS.META & this.modifierMask\n  }\n\n  get shiftKey() {\n    return MODIFIERS.SHIFT & this.modifierMask\n  }\n\n  get altKey() {\n    return MODIFIERS.ALT & this.modifierMask\n  }\n\n  isPrintableKey() {\n    return !(\n      this.isArrow() ||\n      this.isHome() ||\n      this.isEnd() ||\n      this.isPageUp() ||\n      this.isPageDown() ||\n      this.isInsert() ||\n      this.isClear() ||\n      this.isPause() ||\n      this.isEscape()\n    )\n  }\n\n  isNumberKey() {\n    if (this.isKeySupported()) {\n      return this.key >= '0' && this.key <= '9'\n    } else {\n      const code = this.keyCode\n      return (\n        (code >= Keycodes['0'] && code <= Keycodes['9']) || (code >= Keycodes.NUMPAD_0 && code <= Keycodes.NUMPAD_9)\n      ) // numpad keys\n    }\n  }\n\n  isLetterKey() {\n    if (this.isKeySupported()) {\n      const key = this.key\n      return (key >= 'a' && key <= 'z') || (key >= 'A' && key <= 'Z')\n    } else {\n      const code = this.keyCode\n      return (code >= Keycodes.A && code <= Keycodes.Z) || (code >= Keycodes.a && code <= Keycodes.z)\n    }\n  }\n\n  isPunctuation() {\n    if (this.isKeySupported()) {\n      const key = this.key\n      return (key >= ';' && key <= '`') || (key >= '[' && key <= '\"')\n    } else {\n      const code = this.keyCode\n      return (code >= Keycodes[';'] && code <= Keycodes['`']) || (code >= Keycodes['['] && code <= Keycodes['\"'])\n    }\n  }\n\n  /**\n   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode#Printable_keys_in_standard_position\n   *   and http://stackoverflow.com/a/12467610/137784\n   */\n  isPrintable() {\n    if (this.ctrlKey || this.metaKey) {\n      return false\n    }\n\n    // Firefox calls keypress events for some keys that should not be printable\n    if (!this.isPrintableKey()) {\n      return false\n    }\n\n    return (\n      this.keyCode !== 0 ||\n      this.toString().length > 0 ||\n      this.isNumberKey() ||\n      this.isSpace() ||\n      this.isTab() ||\n      this.isEnter() ||\n      this.isLetterKey() ||\n      this.isPunctuation() ||\n      this.isIME()\n    )\n  }\n}\n","import { Direction } from './key'\nimport { isTextNode, isElementNode } from './dom-utils'\nimport { assertNotNull } from './assert'\n\nexport function clearSelection() {\n  const selection = window.getSelection()\n  selection && selection.removeAllRanges()\n}\n\nfunction textNodeRects(node: Text) {\n  let range = document.createRange()\n  range.setEnd(node, node.nodeValue!.length)\n  range.setStart(node, 0)\n  return range.getClientRects()\n}\n\ninterface PartialCoords {\n  top: number\n  left: number\n}\n\nfunction findOffsetInTextNode(node: Text, coords: PartialCoords) {\n  let len = node.nodeValue!.length\n  let range = document.createRange()\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1)\n    range.setStart(node, i)\n    let rect = range.getBoundingClientRect()\n    if (rect.top === rect.bottom) {\n      continue\n    }\n    if (rect.left <= coords.left && rect.right >= coords.left && rect.top <= coords.top && rect.bottom >= coords.top) {\n      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) }\n    }\n  }\n  return { node, offset: 0 }\n}\n\n/*\n * @param {Object} coords with `top` and `left`\n * @see https://github.com/ProseMirror/prosemirror/blob/4c22e3fe97d87a355a0534e25d65aaf0c0d83e57/src/edit/dompos.js\n * @return {Object} {node, offset}\n */\n/* eslint-disable complexity */\nexport function findOffsetInNode(node: Node, coords: PartialCoords): { node: Node; offset: number } {\n  let closest,\n    dyClosest = 1e8,\n    coordsClosest: PartialCoords,\n    offset = 0\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    let rects\n    if (isElementNode(child)) {\n      rects = child.getClientRects()\n    } else if (isTextNode(child)) {\n      rects = textNodeRects(child)\n    } else {\n      continue\n    }\n\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i]\n      if (rect.left <= coords.left && rect.right >= coords.left) {\n        let dy = rect.top > coords.top ? rect.top - coords.top : rect.bottom < coords.top ? coords.top - rect.bottom : 0\n        if (dy < dyClosest) {\n          closest = child\n          dyClosest = dy\n          coordsClosest = dy ? { left: coords.left, top: rect.top } : coords\n          if (isElementNode(child) && !child.firstChild) {\n            offset = i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n          }\n          continue\n        }\n      }\n      if (!closest && (coords.top >= rect.bottom || (coords.top >= rect.top && coords.left >= rect.right))) {\n        offset = i + 1\n      }\n    }\n  }\n  if (!closest) {\n    return { node, offset }\n  }\n  if (isTextNode(closest)) {\n    return findOffsetInTextNode(closest, coordsClosest!)\n  }\n  if (closest.firstChild) {\n    return findOffsetInNode(closest, coordsClosest!)\n  }\n  return { node, offset }\n}\n/* eslint-enable complexity */\n\nfunction constrainNodeTo(node: Node, parentNode: Node, existingOffset: number) {\n  let compare = parentNode.compareDocumentPosition(node)\n  if (compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    // the node is inside parentNode, do nothing\n    return { node, offset: existingOffset }\n  } else if (compare & Node.DOCUMENT_POSITION_CONTAINS) {\n    // the node contains parentNode. This shouldn't happen.\n    return { node, offset: existingOffset }\n  } else if (compare & Node.DOCUMENT_POSITION_PRECEDING) {\n    // node is before parentNode. return start of deepest first child\n    let child = parentNode.firstChild\n    while (child && child.firstChild) {\n      child = child.firstChild\n    }\n    return { node: child, offset: 0 }\n  } else if (compare & Node.DOCUMENT_POSITION_FOLLOWING) {\n    // node is after parentNode. return end of deepest last child\n    let child = parentNode.lastChild!\n    while (child.lastChild) {\n      child = child.lastChild\n    }\n\n    let offset = isTextNode(child) ? child.textContent!.length : 1\n    return { node: child, offset }\n  } else {\n    return { node, offset: existingOffset }\n  }\n}\n\n/*\n * Returns a new selection that is constrained within parentNode.\n * If the anchorNode or focusNode are outside the parentNode, they are replaced with the beginning\n * or end of the parentNode's children\n */\nexport function constrainSelectionTo(selection: PartialSelection, parentNode: Node): PartialSelection {\n  assertNotNull('selection anchorNode should not be null', selection.anchorNode)\n  assertNotNull('selection focusNode should not be null', selection.focusNode)\n\n  let { node: anchorNode, offset: anchorOffset } = constrainNodeTo(\n    selection.anchorNode,\n    parentNode,\n    selection.anchorOffset\n  )\n  let { node: focusNode, offset: focusOffset } = constrainNodeTo(selection.focusNode, parentNode, selection.focusOffset)\n\n  return { anchorNode, anchorOffset, focusNode, focusOffset }\n}\n\ninterface ComparePositionResult {\n  headNode: Node\n  headOffset: number\n  tailNode: Node\n  tailOffset: number\n  direction: number | null\n}\n\nexport interface PartialSelection {\n  focusNode: Node | null\n  focusOffset: number\n  anchorNode: Node | null\n  anchorOffset: number\n}\n\nexport function isFullSelection(selection: PartialSelection | Selection): selection is Selection {\n  return selection instanceof Selection\n}\n\nexport function comparePosition(selection: PartialSelection): ComparePositionResult {\n  assertNotNull('selection anchorNode should not be null', selection.anchorNode)\n  assertNotNull('selection focusNode should not be null', selection.focusNode)\n\n  let { anchorNode, focusNode, anchorOffset, focusOffset } = selection\n  let headNode, tailNode, headOffset, tailOffset, direction\n\n  const position = anchorNode.compareDocumentPosition(focusNode)\n\n  // IE may select return focus and anchor nodes far up the DOM tree instead of\n  // picking the deepest, most specific possible node. For example in\n  //\n  //     <div><span>abc</span><span>def</span></div>\n  //\n  // with a cursor between c and d, IE might say the focusNode is <div> with\n  // an offset of 1. However the anchorNode for a selection might still be\n  // <span> 2 if there was a selection.\n  //\n  // This code walks down the DOM tree until a good comparison of position can be\n  // made.\n  //\n  if (position & Node.DOCUMENT_POSITION_CONTAINS) {\n    if (focusOffset < focusNode.childNodes.length) {\n      focusNode = focusNode.childNodes[focusOffset]\n      focusOffset = 0\n    } else {\n      // This situation happens on IE when triple-clicking to select.\n      // Set the focus to the very last character inside the node.\n      while (focusNode.lastChild) {\n        focusNode = focusNode.lastChild\n      }\n      focusOffset = focusNode.textContent!.length\n    }\n\n    return comparePosition({\n      focusNode,\n      focusOffset,\n      anchorNode,\n      anchorOffset,\n    })\n  } else if (position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    let offset = anchorOffset - 1\n    if (offset < 0) {\n      offset = 0\n    }\n    return comparePosition({\n      anchorNode: anchorNode.childNodes[offset],\n      anchorOffset: 0,\n      focusNode,\n      focusOffset,\n    })\n    // The meat of translating anchor and focus nodes to head and tail nodes\n  } else if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n    headNode = anchorNode\n    tailNode = focusNode\n    headOffset = anchorOffset\n    tailOffset = focusOffset\n    direction = Direction.FORWARD\n  } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n    headNode = focusNode\n    tailNode = anchorNode\n    headOffset = focusOffset\n    tailOffset = anchorOffset\n    direction = Direction.BACKWARD\n  } else {\n    // same node\n    headNode = tailNode = anchorNode\n    headOffset = anchorOffset\n    tailOffset = focusOffset\n    if (tailOffset < headOffset) {\n      // Swap the offset order\n      headOffset = focusOffset\n      tailOffset = anchorOffset\n      direction = Direction.BACKWARD\n    } else if (headOffset < tailOffset) {\n      direction = Direction.FORWARD\n    } else {\n      direction = null\n    }\n  }\n\n  return { headNode, headOffset, tailNode, tailOffset, direction }\n}\n","import Position from './position'\nimport { Direction } from '../key'\nimport assert, { assertNotNull, unwrap } from '../assert'\nimport Markerable from '../../models/_markerable'\nimport MobiledocError from '../mobiledoc-error'\nimport Section from '../../models/_section'\nimport Markuperable from '../markuperable'\nimport { Option } from '../types'\n\n/**\n * A logical range of a {@link Post}.\n * Usually an instance of Range will be read from the {@link Editor#range} property,\n * but it may be useful to instantiate a range directly when programmatically modifying a Post.\n */\nexport default class Range {\n  head: Position\n  tail: Position\n  direction: Option<Direction>\n\n  /**\n   * @param {Position} head\n   * @param {Position} [tail=head]\n   * @param {Direction} [direction=null]\n   * @private\n   */\n  constructor(head: Position, tail: Position = head, direction: Option<Direction> = null) {\n    /** @property {Position} head */\n    this.head = head\n\n    /** @property {Position} tail */\n    this.tail = tail\n\n    /** @property {Direction} direction */\n    this.direction = direction\n  }\n\n  /**\n   * Shorthand to create a new range from a section(s) and offset(s).\n   * When given only a head section and offset, creates a collapsed range.\n   * @param {Section} headSection\n   * @param {number} headOffset\n   * @param {Section} [tailSection=headSection]\n   * @param {number} [tailOffset=headOffset]\n   * @param {Direction} [direction=null]\n   * @return {Range}\n   */\n  static create(\n    headSection: Markerable,\n    headOffset: number,\n    tailSection: Markerable = headSection,\n    tailOffset = headOffset,\n    direction: Option<Direction> = null\n  ): Range {\n    return new Range(new Position(headSection, headOffset), new Position(tailSection, tailOffset), direction)\n  }\n\n  static blankRange(): Range {\n    return new Range(Position.blankPosition(), Position.blankPosition())\n  }\n\n  /**\n   * @param {Markerable} section\n   * @return {Range} A range that is constrained to only the part that\n   * includes the section.\n   * FIXME -- if the section isn't the head or tail, it's assumed to be\n   * wholly contained. It's possible to call `trimTo` with a selection that is\n   * outside of the range, though, which would invalidate that assumption.\n   * There's no efficient way to determine if a section is within a range, yet.\n   * @private\n   */\n  trimTo(section: Markerable) {\n    const length = section.length\n\n    let headOffset = section === this.head.section ? Math.min(this.head.offset, length) : 0\n    let tailOffset = section === this.tail.section ? Math.min(this.tail.offset, length) : length\n\n    return Range.create(section, headOffset, section, tailOffset)\n  }\n\n  /**\n   * Expands the range 1 unit in the given direction\n   * If the range is expandable in the given direction, always returns a\n   * non-collapsed range.\n   * @param {Number} units If units is > 0, the range is extended to the right,\n   *                 otherwise range is extended to the left.\n   * @return {Range}\n   * @public\n   */\n  extend(units: number): Range {\n    assert(`Must pass integer to Range#extend`, typeof units === 'number')\n\n    if (units === 0) {\n      return this\n    }\n\n    let { head, tail, direction: currentDirection } = this\n    switch (currentDirection) {\n      case Direction.FORWARD:\n        return new Range(head, tail.move(units), currentDirection)\n      case Direction.BACKWARD:\n        return new Range(head.move(units), tail, currentDirection)\n      default: {\n        let newDirection = units > 0 ? Direction.FORWARD : Direction.BACKWARD\n        return new Range(head, tail, newDirection).extend(units)\n      }\n    }\n  }\n\n  /**\n   * Moves this range 1 unit in the given direction.\n   * If the range is collapsed, returns a collapsed range shifted by 1 unit,\n   * otherwise collapses this range to the position at the `direction` end of the range.\n   * Always returns a collapsed range.\n   * @param {Direction} direction\n   * @return {Range}\n   * @public\n   */\n  move(direction: Direction) {\n    assert(\n      `Must pass DIRECTION.FORWARD (${Direction.FORWARD}) or DIRECTION.BACKWARD (${Direction.BACKWARD}) to Range#move`,\n      direction === Direction.FORWARD || direction === Direction.BACKWARD\n    )\n\n    let { focusedPosition, isCollapsed } = this\n\n    if (isCollapsed) {\n      return new Range(focusedPosition.move(direction))\n    } else {\n      return this._collapse(direction)\n    }\n  }\n\n  /**\n   * expand a range to all markers matching a given check\n   *\n   * @param {Function} detectMarker\n   * @return {Range} The expanded range\n   *\n   * @public\n   */\n  expandByMarker(detectMarker: (marker: Markuperable) => boolean) {\n    let { head, tail, direction } = this\n    let { section: headSection } = head\n\n    assertNotNull('expected range section to not be null', headSection)\n    assertMarkerable(headSection)\n\n    if (headSection !== tail.section) {\n      throw new Error(\n        '#expandByMarker does not work across sections. Perhaps you should confirm the range is collapsed'\n      )\n    }\n\n    let firstNotMatchingDetect = (i: Markuperable) => {\n      return !detectMarker(i)\n    }\n\n    let headMarker: Markuperable | null | undefined = headSection.markers.detect(\n      firstNotMatchingDetect,\n      head.marker,\n      true\n    )\n    if (!headMarker && detectMarker(headSection.markers.head!)) {\n      headMarker = headSection.markers.head\n    } else {\n      headMarker = unwrap(headMarker).next || head.marker\n    }\n    let headPosition = new Position(headSection, headSection.offsetOfMarker(unwrap(headMarker)))\n\n    assertMarkerable(tail.section)\n    let tailMarker = tail.section.markers.detect(firstNotMatchingDetect, tail.marker)\n    if (!tailMarker && detectMarker(unwrap(headSection.markers.tail))) {\n      tailMarker = unwrap(headSection.markers.tail)\n    } else {\n      tailMarker = unwrap(tailMarker).prev || unwrap(tail.marker)\n    }\n    let tailPosition = new Position(tail.section, tail.section.offsetOfMarker(tailMarker) + tailMarker.length)\n\n    return headPosition.toRange(tailPosition, direction)\n  }\n\n  _collapse(direction: Direction) {\n    return new Range(direction === Direction.BACKWARD ? this.head : this.tail)\n  }\n\n  get focusedPosition() {\n    return this.direction === Direction.BACKWARD ? this.head : this.tail\n  }\n\n  isEqual(other: Range) {\n    return other && this.head.isEqual(other.head) && this.tail.isEqual(other.tail)\n  }\n\n  get isBlank() {\n    return this.head.isBlank && this.tail.isBlank\n  }\n\n  // \"legacy\" APIs\n  get headSection() {\n    return this.head.section\n  }\n  get tailSection() {\n    return this.tail.section\n  }\n  get headSectionOffset() {\n    return this.head.offset\n  }\n  get tailSectionOffset() {\n    return this.tail.offset\n  }\n  get isCollapsed() {\n    return this.head.isEqual(this.tail)\n  }\n  get headMarker() {\n    return this.head.marker\n  }\n  get tailMarker() {\n    return this.tail.marker\n  }\n  get headMarkerOffset() {\n    return this.head.offsetInMarker\n  }\n  get tailMarkerOffset() {\n    return this.tail.offsetInMarker\n  }\n}\n\nfunction assertMarkerable(section: Section): asserts section is Markerable {\n  if (!('markers' in section)) {\n    throw new MobiledocError('Expected position section to be markerable')\n  }\n}\n","export default class LinkedItem {\n  next: this | null = null\n  prev: this | null = null\n}\n","import ListSection from './list-section'\n\nexport function isListSection(item: any): item is ListSection {\n  return 'items' in item && item.items\n}\n","import LinkedItem from '../utils/linked-item'\nimport assert, { expect } from '../utils/assert'\nimport { Option, Dict } from '../utils/types'\nimport Position from '../utils/cursor/position'\nimport Range from '../utils/cursor/range'\nimport RenderNode from './render-node'\nimport Post from './post'\nimport PostNodeBuilder from './post-node-builder'\nimport { Type } from './types'\nimport Markuperable from '../utils/markuperable'\nimport { isListSection } from './is-list-section'\nimport HasChildSections from './_has-child-sections'\n\nexport interface WithParent<T> {\n  parent: Option<T>\n}\n\ntype ParentSection = Post | (Section & HasChildSections<any>)\n\nexport default class Section extends LinkedItem {\n  type: Type\n\n  isSection = true\n  isMarkerable = false\n  isNested = false\n  isListItem = false\n  isListSection = false\n  isLeafSection = true\n  isCardSection = false\n\n  attributes?: Dict<string>\n\n  post?: Option<Post>\n  renderNode!: RenderNode\n\n  _parent: Option<ParentSection> = null\n  builder!: PostNodeBuilder\n\n  get parent() {\n    return expect(this._parent, 'expected section parent to be assigned')\n  }\n\n  constructor(type: Type) {\n    super()\n    assert('Cannot create section without type', !!type)\n    this.type = type\n  }\n\n  get isBlank() {\n    return false\n  }\n\n  get length() {\n    return 0\n  }\n\n  /**\n   * @return {Position} The position at the start of this section\n   * @public\n   */\n  headPosition(): Position {\n    return this.toPosition(0)\n  }\n\n  /**\n   * @return {Position} The position at the end of this section\n   * @public\n   */\n  tailPosition(): Position {\n    return this.toPosition(this.length)\n  }\n\n  /**\n   * @param {Number} offset\n   * @return {Position} The position in this section at the given offset\n   * @public\n   */\n  toPosition(offset: number): Position {\n    assert('Must pass number to `toPosition`', typeof offset === 'number')\n    assert('Cannot call `toPosition` with offset > length', offset <= this.length)\n\n    return new Position(this, offset)\n  }\n\n  /**\n   * @return {Range} A range from this section's head to tail positions\n   * @public\n   */\n  toRange(): Range {\n    return this.headPosition().toRange(this.tailPosition())\n  }\n\n  /**\n   * Markerable sections should override this method\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  splitMarkerAtOffset(_offset: number) {\n    let blankEdit: { added: Markuperable[]; removed: Markuperable[] } = { added: [], removed: [] }\n    return blankEdit\n  }\n\n  nextLeafSection(): Section | null {\n    const next = this.next\n    if (next) {\n      if (isListSection(next)) {\n        return next.items.head\n      } else {\n        return next\n      }\n    } else {\n      if (isNested(this)) {\n        return this.parent.nextLeafSection()\n      }\n    }\n    return null\n  }\n\n  immediatelyNextMarkerableSection() {\n    let next = this.nextLeafSection()\n    while (next && !next.isMarkerable) {\n      next = next.nextLeafSection()\n    }\n    return next\n  }\n\n  previousLeafSection(): Section | null {\n    const prev = this.prev\n\n    if (prev) {\n      if (isListSection(prev)) {\n        return prev.items.tail\n      } else {\n        return prev\n      }\n    } else {\n      if (isNested(this)) {\n        return this.parent.previousLeafSection()\n      }\n    }\n\n    return null\n  }\n}\n\nexport interface NestedSection {\n  parent: Section\n}\n\nexport function isNested<T extends Section>(section: T): section is T & NestedSection {\n  return section.isNested\n}\n","export function shallowCopyObject<T extends {}>(object: T): T {\n  return { ...object }\n}\n","import Section from './_section'\nimport { Type } from './types'\nimport { shallowCopyObject } from '../utils/copy'\nimport PostNodeBuilder from './post-node-builder'\n\nexport enum CardMode {\n  DISPLAY = 'display',\n  EDIT = 'edit',\n}\n\nconst CARD_LENGTH = 1\n\nexport function isCardSection(section: {}): section is Card {\n  return (section as Card).isCardSection\n}\n\nexport type CardPayload = {}\n\nexport default class Card<T = CardPayload> extends Section {\n  name: string\n  payload: T\n  builder!: PostNodeBuilder\n  _initialMode: CardMode = CardMode.DISPLAY\n\n  isCardSection = true\n\n  constructor(name: string, payload: T) {\n    super(Type.CARD)\n    this.name = name\n    this.payload = payload\n    this.isCardSection = true\n  }\n\n  textUntil(): string {\n    return ''\n  }\n\n  canJoin() {\n    return false\n  }\n\n  get length() {\n    return CARD_LENGTH\n  }\n\n  clone() {\n    let payload = shallowCopyObject(this.payload)\n    let card = this.builder.createCardSection(this.name, payload)\n    // If this card is currently rendered, clone the mode it is\n    // currently in as the default mode of the new card.\n    let mode = this._initialMode\n    if (this.renderNode && this.renderNode.cardNode) {\n      mode = this.renderNode.cardNode.mode\n    }\n    card.setInitialMode(mode)\n    return card\n  }\n\n  /**\n   * set the mode that this will be rendered into initially\n   * @private\n   */\n  setInitialMode(initialMode: CardMode) {\n    // TODO validate initialMode\n    this._initialMode = initialMode\n  }\n}\n","import { Type } from './types'\nimport Markuperable from '../utils/markuperable'\nimport assert from '../utils/assert'\nimport Markup from './markup'\nimport PostNodeBuilder, { PostNode } from './post-node-builder'\n\nconst ATOM_LENGTH = 1\n\nexport type AtomPayload = {}\n\nexport default class Atom extends Markuperable {\n  type: Type = Type.ATOM\n  isAtom = true\n\n  name: string\n  value: string\n  text: string\n  payload: {}\n\n  markups: Markup[]\n  builder!: PostNodeBuilder\n\n  constructor(name: string, value: string, payload: AtomPayload, markups: Markup[] = []) {\n    super()\n    this.name = name\n    this.value = value\n    this.text = '' // An atom never has text, but it does have a value\n    assert('Atom must have value', value !== undefined && value !== null)\n    this.payload = payload\n    this.type = Type.ATOM\n    this.isMarker = false\n    this.isAtom = true\n\n    this.markups = []\n    markups.forEach(m => this.addMarkup(m))\n  }\n\n  clone() {\n    let clonedMarkups = this.markups.slice()\n    return this.builder.createAtom(this.name, this.value, this.payload, clonedMarkups)\n  }\n\n  get isBlank() {\n    return false\n  }\n\n  get length() {\n    return ATOM_LENGTH\n  }\n\n  canJoin(/* other */) {\n    return false\n  }\n\n  textUntil(/* offset */) {\n    return ''\n  }\n\n  split(offset = 0, endOffset = offset) {\n    let markers: Markuperable[] = []\n\n    if (endOffset === 0) {\n      markers.push(this.builder.createMarker('', this.markups.slice()))\n    }\n\n    markers.push(this.clone())\n\n    if (offset === ATOM_LENGTH) {\n      markers.push(this.builder.createMarker('', this.markups.slice()))\n    }\n\n    return markers\n  }\n\n  splitAtOffset(offset: number): [Markuperable, Markuperable] {\n    assert('Cannot split a marker at an offset > its length', offset <= this.length)\n\n    let { builder } = this\n    let clone = this.clone()\n    let blankMarker = builder.createMarker('')\n    let pre: Markuperable, post: Markuperable\n\n    if (offset === 0) {\n      ;[pre, post] = [blankMarker, clone]\n    } else if (offset === ATOM_LENGTH) {\n      ;[pre, post] = [clone, blankMarker]\n    } else {\n      assert(`Invalid offset given to Atom#splitAtOffset: \"${offset}\"`, false)\n    }\n\n    this.markups.forEach(markup => {\n      pre.addMarkup(markup)\n      post.addMarkup(markup)\n    })\n    return [pre, post]\n  }\n}\n\nexport function isAtom(postNode: PostNode): postNode is Atom {\n  return postNode.type === Type.ATOM\n}\n","import Marker, { HIGH_SURROGATE_RANGE, LOW_SURROGATE_RANGE } from '../../models/marker'\nimport RenderTree from '../../models/render-tree'\nimport { isTextNode, containsNode, isElementNode } from '../dom-utils'\nimport { findOffsetInNode } from '../selection-utils'\nimport { Option } from '../types'\nimport { Direction } from '../key'\nimport assert, { assertType } from '../assert'\nimport Range from './range'\nimport Markerable from '../../models/_markerable'\nimport Section from '../../models/_section'\nimport RenderNode from '../../models/render-node'\nimport Card, { isCardSection } from '../../models/card'\nimport Markuperable from '../markuperable'\nimport { isAtom } from '../../models/atom'\n\nconst { FORWARD, BACKWARD } = Direction\n\n// generated via http://xregexp.com/ to cover chars that \\w misses\n// (new XRegExp('\\\\p{Alphabetic}|[0-9]|_|:')).toString()\n// eslint-disable-next-line no-misleading-character-class\nconst WORD_CHAR_REGEX = /[A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͅͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևְ-ׇֽֿׁׂׅׄא-תװ-ײؐ-ؚؠ-ٗٙ-ٟٮ-ۓە-ۜۡ-ۭۨ-ۯۺ-ۼۿܐ-ܿݍ-ޱߊ-ߪߴߵߺࠀ-ࠗࠚ-ࠬࡀ-ࡘࢠ-ࢴࣣ-ࣰࣩ-ऻऽ-ौॎ-ॐॕ-ॣॱ-ঃঅ-ঌএঐও-নপ-রলশ-হঽ-ৄেৈোৌৎৗড়ঢ়য়-ৣৰৱਁ-ਃਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਾ-ੂੇੈੋੌੑਖ਼-ੜਫ਼ੰ-ੵઁ-ઃઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽ-ૅે-ૉોૌૐૠ-ૣૹଁ-ଃଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽ-ୄେୈୋୌୖୗଡ଼ଢ଼ୟ-ୣୱஂஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹா-ூெ-ைொ-ௌௐௗఀ-ఃఅ-ఌఎ-ఐఒ-నప-హఽ-ౄె-ైొ-ౌౕౖౘ-ౚౠ-ౣಁ-ಃಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽ-ೄೆ-ೈೊ-ೌೕೖೞೠ-ೣೱೲഁ-ഃഅ-ഌഎ-ഐഒ-ഺഽ-ൄെ-ൈൊ-ൌൎൗൟ-ൣൺ-ൿංඃඅ-ඖක-නඳ-රලව-ෆා-ුූෘ-ෟෲෳก-ฺเ-ๆํກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ູົ-ຽເ-ໄໆໍໜ-ໟༀཀ-ཇཉ-ཬཱ-ཱྀྈ-ྗྙ-ྼက-ံးျ-ဿၐ-ၢၥ-ၨၮ-ႆႎႜႝႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚ፟ᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜓᜠ-ᜳᝀ-ᝓᝠ-ᝬᝮ-ᝰᝲᝳក-ឳា-ៈៗៜᠠ-ᡷᢀ-ᢪᢰ-ᣵᤀ-ᤞᤠ-ᤫᤰ-ᤸᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨛᨠ-ᩞᩡ-ᩴᪧᬀ-ᬳᬵ-ᭃᭅ-ᭋᮀ-ᮩᮬ-ᮯᮺ-ᯥᯧ-ᯱᰀ-ᰵᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳳᳵᳶᴀ-ᶿᷧ-ᷴḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⒶ-ⓩⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⷠ-ⷿⸯ々-〇〡-〩〱-〵〸-〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿕ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙴ-ꙻꙿ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞭꞰ-ꞷꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠧꡀ-ꡳꢀ-ꣃꣲ-ꣷꣻꣽꤊ-ꤪꤰ-ꥒꥠ-ꥼꦀ-ꦲꦴ-ꦿꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨶꩀ-ꩍꩠ-ꩶꩺꩾ-ꪾꫀꫂꫛ-ꫝꫠ-ꫯꫲ-ꫵꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭥꭰ-ꯪ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ]|[0-9]|_|:/\n\nfunction findParentSectionFromNode(renderTree: RenderTree, node: Node) {\n  let renderNode = renderTree.findRenderNodeFromElement(node, renderNode => (renderNode.postNode as Section).isSection)\n\n  return renderNode && (renderNode.postNode as Section)\n}\n\nfunction findOffsetInMarkerable(markerable: Markerable, node: Node, offset: number = 0) {\n  let offsetInSection = 0\n  let marker = markerable.markers.head\n  while (marker) {\n    assertHasRenderNode(marker.renderNode)\n    let markerNode = marker.renderNode.element\n    if (markerNode === node) {\n      return offsetInSection + offset\n    } else if (marker.isAtom) {\n      if (marker.renderNode.headTextNode === node) {\n        return offsetInSection\n      } else if (marker.renderNode.tailTextNode === node) {\n        return offsetInSection + 1\n      }\n    }\n\n    offsetInSection += marker.length\n    marker = marker.next\n  }\n\n  return offsetInSection\n}\n\nfunction assertHasRenderNode(renderNode: RenderNode | null): asserts renderNode is RenderNode {\n  if (!renderNode) {\n    throw new Error('expected marker to have render node')\n  }\n}\n\nfunction findOffsetInSection(section: Section, node: Node, offset?: number) {\n  if (isMarkerable(section)) {\n    return findOffsetInMarkerable(section, node, offset)\n  } else {\n    assertIsCard(section)\n    assertHasRenderNode(section.renderNode)\n    let wrapperNode = section.renderNode.element!\n    let endTextNode = wrapperNode.lastChild\n    if (node === endTextNode) {\n      return 1\n    }\n    return 0\n  }\n}\n\nfunction assertIsCard(section: any): asserts section is Card {\n  assert('findOffsetInSection must be called with markerable or card section', section && section.isCardSection)\n}\n\nfunction isMarkerable(section: Section): section is Markerable {\n  return section.isMarkerable\n}\n\ninterface Editor {\n  element: HTMLElement\n  _renderTree: RenderTree\n}\n\nexport default class Position {\n  section: Section | null\n  offset: number\n  isBlank: boolean\n\n  /**\n   * A position is a logical location (zero-width, or \"collapsed\") in a post,\n   * typically between two characters in a section.\n   * Two positions (a head and a tail) make up a {@link Range}.\n   * @constructor\n   */\n  constructor(section: Section | null, offset = 0, isBlank = false) {\n    if (!isBlank) {\n      assert('Position must have a section that is addressable by the cursor', section && section.isLeafSection)\n      assert('Position must have numeric offset', typeof offset === 'number')\n    }\n\n    this.section = section\n    this.offset = offset\n    this.isBlank = isBlank\n  }\n\n  /**\n   * @param {integer} x x-position in current viewport\n   * @param {integer} y y-position in current viewport\n   * @param {Editor} editor\n   * @return {Position|null}\n   */\n  static atPoint(x: number, y: number, editor: Editor): Option<Position> {\n    let { _renderTree, element: rootElement } = editor\n    let elementFromPoint = document.elementFromPoint(x, y)\n    if (!elementFromPoint || !containsNode(rootElement, elementFromPoint)) {\n      return null\n    }\n\n    let { node, offset } = findOffsetInNode(elementFromPoint, { left: x, top: y })\n    return Position.fromNode(_renderTree, node, offset)\n  }\n\n  static blankPosition(): Position {\n    return new BlankPosition()\n  }\n\n  /**\n   * Returns a range from this position to the given tail. If no explicit\n   * tail is given this returns a collapsed range focused on this position.\n   * @param {Position} [tail=this] The ending position\n   * @return {Range}\n   * @public\n   */\n  toRange(tail = this, direction: number | null = null) {\n    return new Range(this, tail, direction)\n  }\n\n  get leafSectionIndex() {\n    let post = this.section!.post\n    let leafSectionIndex!: number\n    post!.walkAllLeafSections((section: Section, index: number) => {\n      if (section === this.section) {\n        leafSectionIndex = index\n      }\n    })\n    return leafSectionIndex\n  }\n\n  get isMarkerable() {\n    return this.section && this.section.isMarkerable\n  }\n\n  /**\n   * Returns the marker at this position, in the backward direction\n   * (i.e., the marker to the left of the cursor if the cursor is on a marker boundary and text is left-to-right)\n   * @return {Marker|undefined}\n   */\n  get marker(): Markuperable | null {\n    return (this.isMarkerable && this.markerPosition.marker) || null\n  }\n\n  /**\n   * Returns the marker in `direction` from this position.\n   * If the position is in the middle of a marker, the direction is irrelevant.\n   * Otherwise, if the position is at a boundary between two markers, returns the\n   * marker to the left if `direction` === BACKWARD and the marker to the right\n   * if `direction` === FORWARD (assuming left-to-right text direction).\n   * @param {Direction}\n   * @return {Marker|undefined}\n   */\n  markerIn(direction: number) {\n    if (!this.isMarkerable) {\n      return\n    }\n\n    let { marker, offsetInMarker } = this\n    if (!marker) {\n      return\n    }\n\n    if (offsetInMarker > 0 && offsetInMarker < marker.length) {\n      return marker\n    } else if (offsetInMarker === 0) {\n      return direction === BACKWARD ? marker : marker.prev\n    } else if (offsetInMarker === marker.length) {\n      return direction === FORWARD ? marker.next : marker\n    }\n  }\n\n  get offsetInMarker() {\n    return this.markerPosition.offset\n  }\n\n  isEqual(position: Position) {\n    return this.section === position.section && this.offset === position.offset\n  }\n\n  /**\n   * @return {Boolean} If this position is at the head of the post\n   */\n  isHeadOfPost() {\n    return this.move(BACKWARD).isEqual(this)\n  }\n\n  /**\n   * @return {Boolean} If this position is at the tail of the post\n   */\n  isTailOfPost() {\n    return this.move(FORWARD).isEqual(this)\n  }\n\n  /**\n   * @return {Boolean} If this position is at the head of its section\n   */\n  isHead() {\n    return this.isEqual(this.section!.headPosition())\n  }\n\n  /**\n   * @return {Boolean} If this position is at the tail of its section\n   */\n  isTail() {\n    return this.isEqual(this.section!.tailPosition())\n  }\n\n  /**\n   * Move the position 1 unit in `direction`.\n   *\n   * @param {Number} units to move. > 0 moves right, < 0 moves left\n   * @return {Position} Return a new position one unit in the given\n   * direction. If the position is moving left and at the beginning of the post,\n   * the same position will be returned. Same if the position is moving right and\n   * at the end of the post.\n   */\n  move(units: number): Position {\n    assert('Must pass integer to Position#move', typeof units === 'number')\n\n    if (units < 0) {\n      return this.moveLeft().move(++units)\n    } else if (units > 0) {\n      return this.moveRight().move(--units)\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {Number} direction (FORWARD or BACKWARD)\n   * @return {Position} The result of moving 1 \"word\" unit in `direction`\n   */\n  moveWord(direction: number): Position {\n    let isPostBoundary = direction === BACKWARD ? this.isHeadOfPost() : this.isTailOfPost()\n    if (isPostBoundary) {\n      return this\n    }\n\n    if (!this.isMarkerable) {\n      return this.move(direction)\n    }\n\n    let pos: Position = this\n\n    // Helper fn to check if the pos is at the `dir` boundary of its section\n    let isBoundary = (pos: Position, dir: number) => {\n      return dir === BACKWARD ? pos.isHead() : pos.isTail()\n    }\n    // Get the char at this position (looking forward/right)\n    let getChar = (pos: Position) => {\n      let { marker, offsetInMarker } = pos\n      return marker!.charAt(offsetInMarker)\n    }\n    // Get the char in `dir` at this position\n    let peekChar = (pos: Position, dir: number) => {\n      return dir === BACKWARD ? getChar(pos.move(BACKWARD)) : getChar(pos)\n    }\n    // Whether there is an atom in `dir` from this position\n    let isAtom = (pos: Position, dir: number) => {\n      // Special case when position is at end, the marker associated with it is\n      // the marker to its left. Normally `pos#marker` is the marker to the right of the pos's offset.\n      if (dir === BACKWARD && pos.isTail() && pos.marker!.isAtom) {\n        return true\n      }\n      return dir === BACKWARD ? pos.move(BACKWARD).marker!.isAtom : pos.marker!.isAtom\n    }\n\n    if (isBoundary(pos, direction)) {\n      // extend movement into prev/next section\n      return pos.move(direction).moveWord(direction)\n    }\n\n    let seekWord = (pos: Position) => {\n      return !isBoundary(pos, direction) && !isAtom(pos, direction) && !WORD_CHAR_REGEX.test(peekChar(pos, direction))\n    }\n\n    // move(dir) while we are seeking the first word char\n    while (seekWord(pos)) {\n      pos = pos.move(direction)\n    }\n\n    if (isAtom(pos, direction)) {\n      return pos.move(direction)\n    }\n\n    let seekBoundary = (pos: Position) => {\n      return !isBoundary(pos, direction) && !isAtom(pos, direction) && WORD_CHAR_REGEX.test(peekChar(pos, direction))\n    }\n\n    // move(dir) while we are seeking the first boundary position\n    while (seekBoundary(pos)) {\n      pos = pos.move(direction)\n    }\n\n    return pos\n  }\n\n  /**\n   * The position to the left of this position.\n   * If this position is the post's headPosition it returns itself.\n   * @return {Position}\n   * @private\n   */\n  moveLeft() {\n    if (this.isHead()) {\n      let prev = this.section!.previousLeafSection()\n      return prev ? prev.tailPosition() : this\n    } else {\n      let offset = this.offset - 1\n      if (this.isMarkerable && this.marker) {\n        let code = this.marker.value.charCodeAt(offset)\n        if (code >= LOW_SURROGATE_RANGE[0] && code <= LOW_SURROGATE_RANGE[1]) {\n          offset = offset - 1\n        }\n      }\n      return new Position(this.section, offset)\n    }\n  }\n\n  /**\n   * The position to the right of this position.\n   * If this position is the post's tailPosition it returns itself.\n   * @return {Position}\n   * @private\n   */\n  moveRight() {\n    if (this.isTail()) {\n      let next = this.section!.nextLeafSection()\n      return next ? next.headPosition() : this\n    } else {\n      let offset = this.offset + 1\n      if (this.isMarkerable && this.marker) {\n        let code = this.marker.value.charCodeAt(offset - 1)\n        if (code >= HIGH_SURROGATE_RANGE[0] && code <= HIGH_SURROGATE_RANGE[1]) {\n          offset = offset + 1\n        }\n      }\n      return new Position(this.section, offset)\n    }\n  }\n\n  static fromNode(renderTree: RenderTree, node: Node, offset?: number) {\n    if (isTextNode(node)) {\n      return Position.fromTextNode(renderTree, node, offset)\n    } else if (isElementNode(node)) {\n      return Position.fromElementNode(renderTree, node, offset)\n    }\n\n    assert('Positions can only be created from text nodes or elements', false)\n  }\n\n  static fromTextNode(renderTree: RenderTree, textNode: Text, offsetInNode?: number) {\n    const renderNode = renderTree.getElementRenderNode(textNode)\n    let section: Section, offsetInSection: number\n\n    if (renderNode) {\n      const marker = renderNode.postNode as Marker\n      section = marker.section!\n\n      assert(`Could not find parent section for mapped text node \"${textNode.textContent}\"`, !!section)\n      offsetInSection = marker.section!.offsetOfMarker(marker, offsetInNode)\n    } else {\n      // all text nodes should be rendered by markers except:\n      //   * text nodes inside cards\n      //   * text nodes created by the browser during text input\n      // both of these should have rendered parent sections, though\n      section = findParentSectionFromNode(renderTree, textNode)!\n      assert(`Could not find parent section for un-mapped text node \"${textNode.textContent}\"`, !!section)\n\n      offsetInSection = findOffsetInSection(section, textNode, offsetInNode)\n    }\n\n    return new Position(section, offsetInSection)\n  }\n\n  static fromElementNode(renderTree: RenderTree, elementNode: Element, offset: number = 0) {\n    let position\n\n    // The browser may change the reported selection to equal the editor's root\n    // element if the user clicks an element that is immediately removed,\n    // which can happen when clicking to remove a card.\n    if (elementNode === renderTree.rootElement) {\n      let post = renderTree.rootNode.postNode as Section\n      position = offset === 0 ? post.headPosition() : post.tailPosition()\n    } else {\n      let section = findParentSectionFromNode(renderTree, elementNode)\n      assert('Could not find parent section from element node', !!section)\n\n      if (isCardSection(section)) {\n        // Selections in cards are usually made on a text node\n        // containing a &zwnj;  on one side or the other of the card but\n        // some scenarios (Firefox) will result in selecting the\n        // card's wrapper div. If the offset is 2 we've selected\n        // the final zwnj and should consider the cursor at the\n        // end of the card (offset 1). Otherwise,  the cursor is at\n        // the start of the card\n        position = offset < 2 ? section.headPosition() : section.tailPosition()\n      } else {\n        // In Firefox it is possible for the cursor to be on an atom's wrapper\n        // element. (In Chrome/Safari, the browser corrects this to be on\n        // one of the text nodes surrounding the wrapper).\n        // This code corrects for when the browser reports the cursor position\n        // to be on the wrapper element itself\n        let renderNode = renderTree.getElementRenderNode(elementNode)\n        let postNode = renderNode && renderNode.postNode\n        if (postNode && isAtom(postNode)) {\n          let sectionOffset = (section as Markerable).offsetOfMarker(postNode)\n          if (offset > 1) {\n            // we are on the tail side of the atom\n            sectionOffset += postNode.length\n          }\n          position = new Position(section, sectionOffset)\n        } else if (offset >= elementNode.childNodes.length) {\n          // This is to deal with how Firefox handles triple-click selections.\n          // See https://stackoverflow.com/a/21234837/1269194 for an\n          // explanation.\n          position = section.tailPosition()\n        } else {\n          // The offset is 0 if the cursor is on a non-atom-wrapper element node\n          // (e.g., a <br> tag in a blank markup section)\n          position = section.headPosition()\n        }\n      }\n    }\n\n    return position\n  }\n\n  /**\n   * @private\n   */\n  get markerPosition() {\n    assert('Cannot get markerPosition without a section', !!this.section)\n    assertType<Markerable>('cannot get markerPosition of a non-markerable', this.section, !!this.section.isMarkerable)\n    return this.section.markerPositionAtOffset(this.offset)\n  }\n}\n\nclass BlankPosition extends Position {\n  constructor() {\n    super(null, 0, true)\n  }\n\n  isEqual(other: Position) {\n    return other && other.isBlank\n  }\n\n  toRange() {\n    return Range.blankRange()\n  }\n\n  get leafSectionIndex(): never {\n    throw new Error('must implement get leafSectionIndex')\n  }\n\n  get isMarkerable() {\n    return false\n  }\n\n  get marker() {\n    return null\n  }\n\n  isHeadOfPost() {\n    return false\n  }\n\n  isTailOfPost() {\n    return false\n  }\n\n  isHead() {\n    return false\n  }\n\n  isTail() {\n    return false\n  }\n\n  move(): Position {\n    return (this as unknown) as Position\n  }\n\n  moveWord(): Position {\n    return (this as unknown) as Position\n  }\n\n  get markerPosition() {\n    return {} as any\n  }\n}\n","/**\n * @module UI\n */\n\nimport Position from '../utils/cursor/position'\nimport Range from '../utils/cursor/range'\nimport Editor from './editor'\n\ntype ShowPromptCallback = (message: string, defaultValue: string, callback: (value: string | null) => void) => void\nconst defaultShowPrompt: ShowPromptCallback = (message, defaultValue, callback) =>\n  callback(window.prompt(message, defaultValue))\n\n/**\n * @callback promptCallback\n * @param {String} url The URL to pass back to the editor for linking\n *        to the selected text.\n */\n\n/**\n * @callback showPrompt\n * @param {String} message The text of the prompt.\n * @param {String} defaultValue The initial URL to display in the prompt.\n * @param {module:UI~promptCallback} callback Once your handler has accepted a URL,\n *        it should pass it to `callback` so that the editor may link the\n *        selected text.\n */\n\n/**\n * Exposes the core behavior for linking and unlinking text, and allows for\n * customization of the URL input handler.\n * @param {Editor} editor An editor instance to operate on. If a range is selected,\n *        either prompt for a URL and add a link or un-link the\n *        currently linked text.\n * @param {module:UI~showPrompt} [showPrompt] An optional custom input handler. Defaults\n *        to using `window.prompt`.\n * @example\n * let myPrompt = (message, defaultURL, promptCallback) => {\n *   let url = window.prompt(\"Overriding the defaults\", \"http://placekitten.com\");\n *   promptCallback(url);\n * };\n *\n * editor.registerKeyCommand({\n *   str: \"META+K\",\n *   run(editor) {\n *     toggleLink(editor, myPrompt);\n *   }\n * });\n * @public\n */\nexport function toggleLink(editor: Editor, showPrompt: ShowPromptCallback = defaultShowPrompt) {\n  if (editor.range.isCollapsed) {\n    return\n  }\n\n  let selectedText = editor.cursor.selectedText()\n  let defaultUrl = ''\n  if (selectedText.indexOf('http') !== -1) {\n    defaultUrl = selectedText\n  }\n\n  let { range } = editor\n  let hasLink = editor.detectMarkupInRange(range, 'a')\n\n  if (hasLink) {\n    editor.toggleMarkup('a')\n  } else {\n    showPrompt('Enter a URL', defaultUrl, url => {\n      if (!url) {\n        return\n      }\n\n      editor.toggleMarkup('a', { href: url })\n    })\n  }\n}\n\n/**\n * Exposes the core behavior for editing an existing link, and allows for\n * customization of the URL input handler.\n * @param {HTMLAnchorElement} target The anchor (<a>) DOM element whose URL should be edited.\n * @param {Editor} editor An editor instance to operate on. If a range is selected,\n *        either prompt for a URL and add a link or un-link the\n *        currently linked text.\n * @param {module:UI~showPrompt} [showPrompt] An optional custom input handler. Defaults\n *        to using `window.prompt`.\n *\n * @public\n */\nexport function editLink(\n  target: HTMLAnchorElement,\n  editor: Editor,\n  showPrompt: ShowPromptCallback = defaultShowPrompt\n) {\n  showPrompt('Enter a URL', target.href, url => {\n    if (!url) {\n      return\n    }\n\n    const position = Position.fromNode(editor._renderTree, target.firstChild!)\n    const range = new Range(position, new Position(position.section, position.offset + target.textContent!.length))\n\n    editor.run(post => {\n      let markup = editor.builder.createMarkup('a', { href: url })\n\n      // This is the only way to \"update\" a markup with new attributes in the\n      // current API.\n      post.toggleMarkup(markup, range)\n      post.toggleMarkup(markup, range)\n    })\n  })\n}\n\nexport default {\n  toggleLink,\n  editLink,\n}\n","import View from './view'\nimport {\n  positionElementCenteredBelow,\n  getEventTargetMatchingTag,\n  whenElementIsNotInDOM,\n  Cancelable,\n} from '../utils/element-utils'\nimport { editLink } from '../editor/ui'\n\nconst SHOW_DELAY = 200\nconst HIDE_DELAY = 600\n\ntype Editor = any\n\ninterface TooltipOptions {\n  rootElement: HTMLElement\n  editor: Editor\n  showForTag: string\n}\n\ninterface AddListenerOptions {\n  showForTag: string\n}\n\nexport default class Tooltip extends View {\n  rootElement: HTMLElement\n  editor: any\n  elementObserver: Cancelable | null = null\n\n  constructor(options: TooltipOptions) {\n    super({ ...options, classNames: ['__mobiledoc-tooltip'] })\n\n    this.rootElement = options.rootElement\n    this.editor = options.editor\n\n    this.addListeners(options)\n  }\n\n  showLink(linkEl: HTMLAnchorElement) {\n    const { editor, element: tooltipEl } = this\n    const { tooltipPlugin } = editor\n\n    tooltipPlugin.renderLink(tooltipEl, linkEl, {\n      editLink: () => {\n        editLink(linkEl, editor)\n        this.hide()\n      },\n    })\n\n    this.show()\n    positionElementCenteredBelow(this.element, linkEl)\n\n    this.elementObserver = whenElementIsNotInDOM(linkEl, () => this.hide())\n  }\n\n  addListeners(options: AddListenerOptions) {\n    const { rootElement, element: tooltipElement } = this\n    let showTimeout: number, hideTimeout: number\n\n    const scheduleHide = () => {\n      clearTimeout(hideTimeout)\n      hideTimeout = setTimeout(() => {\n        this.hide()\n      }, HIDE_DELAY)\n    }\n\n    this.addEventListener(tooltipElement, 'mouseenter', () => {\n      clearTimeout(hideTimeout)\n    })\n\n    this.addEventListener(tooltipElement, 'mouseleave', () => {\n      scheduleHide()\n    })\n\n    this.addEventListener(rootElement, 'mouseover', event => {\n      let target = getEventTargetMatchingTag(options.showForTag, event.target as HTMLElement, rootElement)\n\n      if (target && target.isContentEditable) {\n        clearTimeout(hideTimeout)\n        showTimeout = setTimeout(() => {\n          target && this.showLink(target as HTMLAnchorElement)\n        }, SHOW_DELAY)\n      }\n    })\n\n    this.addEventListener(rootElement, 'mouseout', () => {\n      clearTimeout(showTimeout)\n      if (this.elementObserver) {\n        this.elementObserver.cancel()\n      }\n      scheduleHide()\n    })\n  }\n}\n\ntype EditLinkCallback = () => void\nexport interface TooltipPlugin {\n  renderLink(tooltipEl: Element, linkEl: HTMLLinkElement, options: { editLink: EditLinkCallback }): void\n}\n\nexport const DEFAULT_TOOLTIP_PLUGIN: TooltipPlugin = {\n  renderLink(tooltipEl: Element, linkEl: HTMLLinkElement, { editLink }) {\n    const { href } = linkEl\n    tooltipEl.innerHTML = `<a href=\"${href}\" target=\"_blank\">${href}</a>`\n    const button = document.createElement('button')\n    button.classList.add('__mobiledoc-tooltip__edit-link')\n    button.innerText = 'Edit Link'\n    button.addEventListener('click', editLink)\n    tooltipEl.append(button)\n  },\n}\n","import assert from '../utils/assert'\n\ninterface Queue {\n  [name: string]: LifecycleCallback[]\n}\n\nexport type LifecycleCallback = (...args: any[]) => boolean | void\n\nexport default class LifecycleCallbacks {\n  callbackQueues: Queue = {}\n  removalQueues: Queue = {}\n\n  constructor(queueNames: string[] = []) {\n    queueNames.forEach(name => {\n      this.callbackQueues[name] = []\n      this.removalQueues[name] = []\n    })\n  }\n\n  runCallbacks(queueName: string, args: unknown[] = []) {\n    let queue = this._getQueue(queueName)\n    queue.forEach(cb => cb(...args))\n\n    let toRemove = this.removalQueues[queueName]\n    toRemove.forEach(cb => {\n      let index = queue.indexOf(cb)\n      if (index !== -1) {\n        queue.splice(index, 1)\n      }\n    })\n\n    this.removalQueues[queueName] = []\n  }\n\n  addCallback(queueName: string, callback: LifecycleCallback) {\n    this._getQueue(queueName).push(callback)\n  }\n\n  _scheduleCallbackForRemoval(queueName: string, callback: LifecycleCallback) {\n    this.removalQueues[queueName].push(callback)\n  }\n\n  addCallbackOnce(queueName: string, callback: LifecycleCallback) {\n    let queue = this._getQueue(queueName)\n    if (queue.indexOf(callback) === -1) {\n      queue.push(callback)\n      this._scheduleCallbackForRemoval(queueName, callback)\n    }\n  }\n\n  _getQueue(queueName: string) {\n    let queue = this.callbackQueues[queueName]\n    assert(`No queue found for \"${queueName}\"`, !!queue)\n    return queue\n  }\n}\n","import LinkedList from '../utils/linked-list'\nimport Section from './_section'\n\ntype HasChildSections<T extends Section = Section> = {\n  sections: LinkedList<T>\n}\n\n// eslint-disable-next-line no-undef\nexport default HasChildSections\n\nexport function hasChildSections(section: {}): section is HasChildSections {\n  return 'sections' in section\n}\n","import assert, { assertType } from '../../utils/assert'\nimport { Option } from '../../utils/types'\nimport { Type } from '../../models/types'\nimport Post from '../../models/post'\nimport PostEditor from '../post'\nimport PostNodeBuilder, { PostNode } from '../../models/post-node-builder'\nimport { Position } from '../../utils/cursor'\nimport Section, { WithParent, NestedSection } from '../../models/_section'\nimport MarkupSection from '../../models/markup-section'\nimport ListSection from '../../models/list-section'\nimport ListItem from '../../models/list-item'\nimport Card from '../../models/card'\nimport Image from '../../models/image'\nimport Markerable from '../../models/_markerable'\nimport { Cloneable } from '../../models/_cloneable'\nimport HasChildSections, { hasChildSections } from '../../models/_has-child-sections'\n\nconst MARKERABLE = 'markerable'\nconst NESTED_MARKERABLE = 'nested_markerable'\nconst NON_MARKERABLE = 'non_markerable'\n\nclass Visitor {\n  postEditor: PostEditor\n  builder: PostNodeBuilder\n  _post: Post\n  _hasInsertedFirstLeafSection: boolean\n  _cursorPosition!: Position\n\n  constructor({ postEditor, post }: Inserter, cursorPosition: Position) {\n    this.postEditor = postEditor\n    this._post = post\n    this.cursorPosition = cursorPosition\n    this.builder = this.postEditor.builder\n\n    this._hasInsertedFirstLeafSection = false\n  }\n\n  get cursorPosition() {\n    return this._cursorPosition\n  }\n\n  set cursorPosition(position) {\n    this._cursorPosition = position\n    this.postEditor.setRange(position)\n  }\n\n  visit(node: PostNode) {\n    let method = node.type\n    assertType<typeof method & keyof this>(`Cannot visit node of type ${node.type}`, method, method in this)\n    this[method](node as any)\n  }\n\n  _canMergeSection(section: Section) {\n    if (this._hasInsertedFirstLeafSection) {\n      return false\n    } else {\n      return this._isMarkerable && section.isMarkerable\n    }\n  }\n\n  get _isMarkerable() {\n    return this.cursorSection.isMarkerable\n  }\n\n  get cursorSection() {\n    return this.cursorPosition.section!\n  }\n\n  get cursorOffset() {\n    return this.cursorPosition.offset\n  }\n\n  get _isNested() {\n    return this.cursorSection.isNested\n  }\n\n  [Type.POST](node: Post) {\n    let { cursorSection } = this\n    if (cursorSection.isBlank && !cursorSection.isNested) {\n      // replace blank section with entire post\n      let newSections = node.sections.map(s => s.clone())\n      this._replaceSection(cursorSection as Section & WithParent<HasChildSections>, newSections)\n    } else {\n      node.sections.forEach(section => this.visit(section))\n    }\n  }\n\n  [Type.MARKUP_SECTION](node: MarkupSection) {\n    this[MARKERABLE](node)\n  }\n\n  [Type.LIST_SECTION](node: ListSection) {\n    let hasNext = !!node.next\n    node.items.forEach(item => this.visit(item))\n\n    if (this._isNested && hasNext) {\n      this._breakNestedAtCursor()\n    }\n  }\n\n  [Type.LIST_ITEM](node: ListItem) {\n    this[NESTED_MARKERABLE](node)\n  }\n\n  [Type.CARD](node: Card) {\n    this[NON_MARKERABLE](node)\n  }\n\n  [Type.IMAGE_SECTION](node: Image) {\n    this[NON_MARKERABLE](node)\n  }\n\n  [NON_MARKERABLE](section: Cloneable<Section>) {\n    if (this._isNested) {\n      this._breakNestedAtCursor()\n    } else if (!this.cursorSection.isBlank) {\n      this._breakAtCursor()\n    }\n\n    this._insertLeafSection(section)\n  }\n\n  [MARKERABLE](section: Markerable) {\n    if (this._canMergeSection(section)) {\n      this._mergeSection(section)\n    } else if (this._isNested && this._isMarkerable) {\n      // If we are attaching a markerable section to a list item,\n      // insert a linebreak then merge the section onto the resulting blank list item\n      this._breakAtCursor()\n\n      // Advance the cursor to the head of the blank list item\n      let nextPosition = this.cursorSection.next!.headPosition()\n      this.cursorPosition = nextPosition\n\n      // Merge this section onto the list item\n      this._mergeSection(section)\n    } else {\n      this._breakAtCursor()\n      this._insertLeafSection(section)\n    }\n  }\n\n  [NESTED_MARKERABLE](section: Markerable) {\n    if (this._canMergeSection(section)) {\n      this._mergeSection(section)\n      return\n    }\n\n    let insertedSection = this._isNested ? section : this._wrapNestedSection(section as ListItem)\n    this._breakAtCursor()\n    this._insertLeafSection(insertedSection)\n  }\n\n  // break out of a nested cursor position\n  _breakNestedAtCursor() {\n    assert('Cannot call _breakNestedAtCursor if not nested', this._isNested)\n\n    let parent = (this.cursorSection as NestedSection).parent\n    let cursorAtEndOfList = this.cursorPosition.isEqual(parent.tailPosition())\n\n    if (cursorAtEndOfList) {\n      let blank = this.builder.createMarkupSection()\n      this._insertSectionAfter(blank, parent)\n    } else {\n      let [, blank] = this._breakListAtCursor()\n      this.cursorPosition = blank.tailPosition()\n    }\n  }\n\n  _breakListAtCursor() {\n    assert('Cannot _splitParentSection if cursor position is not nested', this._isNested)\n\n    const list = this.cursorSection.parent as ListSection\n    const position = this.cursorPosition\n    const blank = this.builder.createMarkupSection()\n\n    let [pre, post] = this.postEditor._splitListAtPosition(list, position)\n\n    let collection = this._post.sections,\n      reference = post\n    this.postEditor.insertSectionBefore(collection, blank, reference)\n    return [pre, blank, post]\n  }\n\n  _wrapNestedSection(section: ListItem) {\n    let tagName = section.parent.tagName\n    let parent = this.builder.createListSection(tagName)\n    parent.items.append(section.clone())\n    return parent\n  }\n\n  _mergeSection(section: Markerable) {\n    assert('Can only merge markerable sections', this._isMarkerable && section.isMarkerable)\n    this._hasInsertedFirstLeafSection = true\n\n    let markers = section.markers.map(m => m.clone())\n    let position = this.postEditor.insertMarkers(this.cursorPosition, markers)\n\n    this.cursorPosition = position\n  }\n\n  // Can be called to add a line break when in a nested section or a parent\n  // section.\n  _breakAtCursor() {\n    if (this.cursorSection.isBlank) {\n      return\n    } else if (this._isMarkerable) {\n      this._breakMarkerableAtCursor()\n    } else {\n      this._breakNonMarkerableAtCursor()\n    }\n  }\n\n  // Inserts a blank section before/after the cursor,\n  // depending on cursor position.\n  _breakNonMarkerableAtCursor() {\n    const collection = this._post.sections\n    const blank = this.builder.createMarkupSection()\n    const reference = this.cursorPosition.isHead() ? this.cursorSection : this.cursorSection.next\n\n    this.postEditor.insertSectionBefore(collection, blank, reference)\n    this.cursorPosition = blank.tailPosition()\n  }\n\n  _breakMarkerableAtCursor() {\n    let [pre] = this.postEditor.splitSection(this.cursorPosition)\n\n    this.cursorPosition = pre!.tailPosition()\n  }\n\n  _replaceSection(section: Section, newSections: Section[]) {\n    assert('Cannot replace section that does not have parent.sections', hasChildSections(section.parent))\n    assert('Must pass enumerable to _replaceSection', !!newSections.forEach)\n\n    let collection = section.parent.sections\n    let reference = section.next\n    this.postEditor.removeSection(section)\n    newSections.forEach(section => {\n      this.postEditor.insertSectionBefore(collection, section, reference)\n    })\n    let lastSection = newSections[newSections.length - 1]\n\n    this.cursorPosition = lastSection.tailPosition()\n  }\n\n  _insertSectionBefore(section: Section, reference?: Option<Section>) {\n    assert('Cannot insert into section that does not have parent.sections', hasChildSections(this.cursorSection.parent))\n    let collection = this.cursorSection.parent.sections\n    this.postEditor.insertSectionBefore(collection, section, reference)\n\n    this.cursorPosition = section.tailPosition()\n  }\n\n  // Insert a section after the parent section.\n  // E.g., add a markup section after a list section\n  _insertSectionAfter(section: Section, parent: Section) {\n    assert('Cannot _insertSectionAfter nested section', !parent.isNested)\n    let reference = parent.next\n    let collection = this._post.sections\n    this.postEditor.insertSectionBefore(collection, section, reference)\n    this.cursorPosition = section.tailPosition()\n  }\n\n  _insertLeafSection(section: Cloneable<Section>) {\n    assert('Can only _insertLeafSection when cursor is at end of section', this.cursorPosition.isTail())\n\n    this._hasInsertedFirstLeafSection = true\n    section = section.clone()\n\n    if (this.cursorSection.isBlank) {\n      assert(\n        'Cannot insert leaf non-markerable section when cursor is nested',\n        !(section.isMarkerable && this._isNested)\n      )\n      this._replaceSection(this.cursorSection, [section])\n    } else if (this.cursorSection.next && this.cursorSection.next.isBlank) {\n      this._replaceSection(this.cursorSection.next, [section])\n    } else {\n      let reference = this.cursorSection.next\n      this._insertSectionBefore(section, reference)\n    }\n  }\n}\n\nexport default class Inserter {\n  postEditor: PostEditor\n  post: Post\n\n  constructor(postEditor: PostEditor, post: Post) {\n    this.postEditor = postEditor\n    this.post = post\n  }\n\n  insert(cursorPosition: Position, newPost: Post) {\n    let visitor = new Visitor(this, cursorPosition)\n    if (!newPost.isBlank) {\n      visitor.visit(newPost)\n    }\n    return visitor.cursorPosition\n  }\n}\n","/**\n * Usage:\n * Without a conditional, always prints deprecate message:\n *   `deprecate('This is deprecated')`\n *\n * Conditional deprecation, works similarly to `assert`, prints deprecation if\n * conditional is false:\n *   `deprecate('Deprecated only if foo !== bar', foo === bar)`\n */\nexport default function deprecate(message: string, conditional = false) {\n  if (!conditional) {\n    // eslint-disable-next-line no-console\n    console.log(`[mobiledoc-kit] [DEPRECATED]: ${message}`)\n  }\n}\n","import Range from './cursor/range'\nimport Position from './cursor/position'\nimport assert from './assert'\n\nexport default function toRange(rangeLike: Range | Position) {\n  assert(`Must pass non-blank object to \"toRange\"`, !!rangeLike)\n\n  if (rangeLike instanceof Range) {\n    return rangeLike\n  } else if (rangeLike instanceof Position) {\n    return rangeLike.toRange()\n  }\n\n  assert(`Incorrect structure for rangeLike: ${rangeLike}`, false)\n}\n","import { clearSelection, comparePosition, isFullSelection } from '../utils/selection-utils'\nimport { containsNode } from '../utils/dom-utils'\nimport Position from './cursor/position'\nimport Range from './cursor/range'\nimport { Direction } from '../utils/key'\nimport { constrainSelectionTo } from '../utils/selection-utils'\nimport Editor from '../editor/editor'\nimport RenderTree from '../models/render-tree'\nimport Post from '../models/post'\nimport { unwrap, assertNotNull, expect } from './assert'\nimport { isCardSection } from '../models/card'\nimport Section from '../models/_section'\nimport { Type } from '../models/types'\n\nexport { Position, Range }\n\nclass Cursor {\n  editor: Editor\n  renderTree: RenderTree\n  post: Post\n\n  constructor(editor: Editor) {\n    this.editor = editor\n    this.renderTree = editor._renderTree\n    this.post = editor.post\n  }\n\n  clearSelection() {\n    clearSelection()\n  }\n\n  /**\n   * @return {Boolean} true when there is either a collapsed cursor in the\n   * editor's element or a selection that is contained in the editor's element\n   */\n  hasCursor() {\n    return this.editor.hasRendered && (this._hasCollapsedSelection() || this._hasSelection())\n  }\n\n  hasSelection() {\n    return this.editor.hasRendered && this._hasSelection()\n  }\n\n  /**\n   * @return {Boolean} Can the cursor be on this element?\n   */\n  isAddressable(element: Node) {\n    let { renderTree } = this\n    let renderNode = renderTree.findRenderNodeFromElement(element)\n    if (renderNode && (renderNode.postNode as Section).isCardSection) {\n      let renderedElement = renderNode.element!\n\n      // card sections have addressable text nodes containing &zwnj;\n      // as their first and last child\n      if (\n        element !== renderedElement &&\n        element !== renderedElement.firstChild &&\n        element !== renderedElement.lastChild\n      ) {\n        return false\n      }\n    }\n\n    return !!renderNode\n  }\n\n  /*\n   * @return {Range} Cursor#Range object\n   */\n  get offsets() {\n    if (!this.hasCursor()) {\n      return Range.blankRange()\n    }\n\n    let { renderTree } = this\n    let parentNode = unwrap(this.editor.element)\n    let selection = constrainSelectionTo(this.selection, parentNode)\n\n    const { headNode, headOffset, tailNode, tailOffset, direction } = comparePosition(selection)\n\n    const headPosition = Position.fromNode(renderTree, headNode, headOffset)\n    const tailPosition = Position.fromNode(renderTree, tailNode, tailOffset)\n\n    return new Range(headPosition, tailPosition, direction)\n  }\n\n  _findNodeForPosition(position: Position) {\n    let section = unwrap(position.section)\n    let node, offset\n    assertNotNull('expected section to have render node', section.renderNode)\n\n    if (isCardSection(section)) {\n      offset = 0\n      if (position.offset === 0) {\n        node = section.renderNode.element!.firstChild\n      } else {\n        node = section.renderNode.element!.lastChild\n      }\n    } else if (section.isBlank || section.type === Type.IMAGE_SECTION) {\n      node = section.renderNode.cursorElement\n      offset = 0\n    } else {\n      let { marker, offsetInMarker } = position\n      assertNotNull('expected position to have marker', marker)\n      assertNotNull('expected marker to have render node', marker.renderNode)\n\n      if (marker.isAtom) {\n        if (offsetInMarker > 0) {\n          // FIXME -- if there is a next marker, focus on it?\n          offset = 0\n          node = marker.renderNode.tailTextNode\n        } else {\n          offset = 0\n          node = marker.renderNode.headTextNode\n        }\n      } else {\n        node = marker.renderNode.element\n        offset = offsetInMarker\n      }\n    }\n\n    return { node, offset }\n  }\n\n  selectRange(range: Range) {\n    if (range.isBlank) {\n      this.clearSelection()\n      return\n    }\n\n    const { head, tail, direction } = range\n    const { node: headNode, offset: headOffset } = this._findNodeForPosition(head),\n      { node: tailNode, offset: tailOffset } = this._findNodeForPosition(tail)\n    this._moveToNode(headNode! as Text, headOffset, tailNode! as Text, tailOffset, direction!)\n\n    // Firefox sometimes doesn't keep focus in the editor after adding a card\n    this.editor._ensureFocus()\n  }\n\n  get selection() {\n    return expect(window.getSelection(), 'expected window selection to not be null')\n  }\n\n  selectedText() {\n    // FIXME remove this\n    return this.selection.toString()\n  }\n\n  /**\n   * @param {textNode} node\n   * @param {integer} offset\n   * @param {textNode} endNode\n   * @param {integer} endOffset\n   * @param {integer} direction forward or backward, default forward\n   * @private\n   */\n  _moveToNode(node: Text, offset: number, endNode: Text, endOffset: number, direction: Direction = Direction.FORWARD) {\n    this.clearSelection()\n\n    if (direction === Direction.BACKWARD) {\n      ;[node, offset, endNode, endOffset] = [endNode, endOffset, node, offset]\n    }\n\n    const range = document.createRange()\n    range.setStart(node, offset)\n    if (direction === Direction.BACKWARD && isFullSelection(this.selection)) {\n      this.selection.addRange(range)\n      this.selection.extend(endNode, endOffset)\n    } else {\n      range.setEnd(endNode, endOffset)\n      this.selection.addRange(range)\n    }\n  }\n\n  _hasSelection() {\n    const element = unwrap(this.editor.element)\n    const { _selectionRange } = this\n    if (!_selectionRange || _selectionRange.collapsed) {\n      return false\n    }\n\n    return (\n      containsNode(element, unwrap(this.selection.anchorNode)) &&\n      containsNode(element, unwrap(this.selection.focusNode))\n    )\n  }\n\n  _hasCollapsedSelection() {\n    const { _selectionRange } = this\n    if (!_selectionRange) {\n      return false\n    }\n\n    const element = this.editor.element\n    return containsNode(unwrap(element), unwrap(this.selection.anchorNode))\n  }\n\n  get _selectionRange() {\n    const { selection } = this\n    if (selection.rangeCount === 0) {\n      return null\n    }\n    return selection.getRangeAt(0)\n  }\n}\n\nexport default Cursor\n","export default class Set<T> {\n  items: T[]\n\n  constructor(items = []) {\n    this.items = []\n    items.forEach(i => this.add(i))\n  }\n\n  add(item: T) {\n    if (!this.has(item)) {\n      this.items.push(item)\n    }\n  }\n\n  get length() {\n    return this.items.length\n  }\n\n  has(item: T) {\n    return this.items.indexOf(item) !== -1\n  }\n\n  toArray() {\n    return this.items\n  }\n}\n","import assert from './assert'\nimport { Maybe } from './types'\n\nconst PARENT_PROP = '__parent'\n\ninterface LinkedListOptions<T> {\n  adoptItem?: AdoptItemCallback<T>\n  freeItem?: FreeItemCallback<T>\n}\n\nexport interface LinkedListItem<T extends LinkedListItem<T>> {\n  next: T | null\n  prev: T | null\n}\n\ntype ItemCallback<T, U = void> = (item: T) => U\ntype AdoptItemCallback<T> = ItemCallback<T>\ntype FreeItemCallback<T> = ItemCallback<T>\n\nexport default class LinkedList<T extends LinkedListItem<T>> {\n  head: T | null\n  tail: T | null\n  length: number\n\n  _adoptItem?: AdoptItemCallback<T>\n  _freeItem?: FreeItemCallback<T>\n\n  constructor(options: LinkedListOptions<T>) {\n    this.head = null\n    this.tail = null\n    this.length = 0\n\n    if (options) {\n      const { adoptItem, freeItem } = options\n      this._adoptItem = adoptItem\n      this._freeItem = freeItem\n    }\n  }\n\n  adoptItem(item: T) {\n    ;(item as any)[PARENT_PROP] = this\n    this.length++\n    if (this._adoptItem) {\n      this._adoptItem(item)\n    }\n  }\n\n  freeItem(item: T) {\n    ;(item as any)[PARENT_PROP] = null\n    this.length--\n    if (this._freeItem) {\n      this._freeItem(item)\n    }\n  }\n\n  get isEmpty() {\n    return this.length === 0\n  }\n\n  prepend(item: T) {\n    this.insertBefore(item, this.head)\n  }\n\n  append(item: T) {\n    this.insertBefore(item, null)\n  }\n\n  insertAfter(item: T, prevItem: T) {\n    let nextItem = prevItem ? prevItem.next : this.head\n    this.insertBefore(item, nextItem)\n  }\n\n  _ensureItemIsNotAlreadyInList(item: T) {\n    assert(\n      'Cannot insert an item into a list if it is already in a list',\n      !item.next && !item.prev && this.head !== item\n    )\n  }\n\n  insertBefore(item: T, nextItem?: T | null) {\n    this._ensureItemIsNotInList(item)\n    this.adoptItem(item)\n\n    let insertPos: 'middle' | 'start' | 'end'\n    if (nextItem && nextItem.prev) {\n      insertPos = 'middle'\n    } else if (nextItem) {\n      insertPos = 'start'\n    } else {\n      insertPos = 'end'\n    }\n\n    switch (insertPos) {\n      case 'start':\n        if (this.head) {\n          item.next = this.head\n          this.head.prev = item\n        }\n        this.head = item\n\n        break\n      case 'middle': {\n        let prevItem = nextItem!.prev\n        item.next = nextItem!\n        item.prev = prevItem\n        nextItem!.prev = item\n        prevItem!.next = item\n\n        break\n      }\n      case 'end': {\n        let tail = this.tail\n        item.prev = tail\n\n        if (tail) {\n          tail.next = item\n        } else {\n          this.head = item\n        }\n        this.tail = item\n\n        break\n      }\n    }\n  }\n\n  remove(item: T) {\n    if (!getParent(item)) {\n      return\n    }\n    this._ensureItemIsInThisList(item)\n    this.freeItem(item)\n\n    let [prev, next] = [item.prev, item.next]\n    item.prev = null\n    item.next = null\n\n    if (prev) {\n      prev.next = next\n    } else {\n      this.head = next\n    }\n\n    if (next) {\n      next.prev = prev\n    } else {\n      this.tail = prev\n    }\n  }\n\n  forEach(callback: (item: T, idx: number) => void) {\n    let item = this.head\n    let index = 0\n    while (item) {\n      callback(item, index++)\n      item = item.next\n    }\n  }\n\n  map<U>(callback: (item: T) => U): U[] {\n    let result: U[] = []\n    this.forEach(i => result.push(callback(i)))\n    return result\n  }\n\n  walk(startItem: Maybe<T>, endItem: Maybe<T>, callback: ItemCallback<T>) {\n    let item: T | null = startItem || this.head\n    while (item) {\n      callback(item)\n      if (item === endItem) {\n        break\n      }\n      item = item.next\n    }\n  }\n\n  readRange(startItem?: Maybe<T>, endItem?: Maybe<T>) {\n    let items: T[] = []\n    this.walk(startItem, endItem, item => {\n      items.push(item)\n    })\n    return items\n  }\n\n  toArray() {\n    return this.readRange()\n  }\n\n  detect(callback: ItemCallback<T, boolean>, item = this.head, reverse = false) {\n    while (item) {\n      if (callback(item)) {\n        return item\n      }\n      item = reverse ? item.prev : item.next\n    }\n  }\n\n  any(callback: ItemCallback<T, boolean>) {\n    return !!this.detect(callback)\n  }\n\n  every(callback: ItemCallback<T, boolean>) {\n    let item = this.head\n    while (item) {\n      if (!callback(item)) {\n        return false\n      }\n      item = item.next\n    }\n    return true\n  }\n\n  objectAt(targetIndex: number) {\n    let index = -1\n    return this.detect(() => {\n      index++\n      return targetIndex === index\n    })\n  }\n\n  splice(targetItem: T, removalCount: number, newItems: T[]) {\n    let item: T | null = targetItem\n    let nextItem = item.next\n    let count = 0\n    while (item && count < removalCount) {\n      count++\n      nextItem = item.next\n      this.remove(item)\n      item = nextItem\n    }\n    newItems.forEach(newItem => {\n      this.insertBefore(newItem, nextItem)\n    })\n  }\n\n  removeBy(conditionFn: ItemCallback<T, boolean>) {\n    let item = this.head\n    while (item) {\n      let nextItem = item.next\n\n      if (conditionFn(item)) {\n        this.remove(item)\n      }\n\n      item = nextItem\n    }\n  }\n\n  _ensureItemIsNotInList(item: T) {\n    assert('Cannot insert an item into a list if it is already in a list', !(item as any)[PARENT_PROP])\n  }\n\n  _ensureItemIsInThisList(item: T) {\n    assert('Cannot remove item that is in another list', getParent(item) === this)\n  }\n}\n\nfunction getParent<T extends LinkedListItem<T>>(item: {}): LinkedList<T> | null {\n  return (item as any)[PARENT_PROP] || null\n}\n","import { normalizeTagName } from '../utils/dom-utils'\nimport assert, { assertType } from '../utils/assert'\nimport Section from './_section'\n\ntype Constructor<T = {}> = new (...args: any[]) => T\n\nexport interface TagNameable {\n  tagName: string\n  isValidTagName(normalizedTagName: string): boolean\n}\n\nexport function tagNameable(Base: Constructor<Section>) {\n  abstract class TagNameable extends Base {\n    _tagName: string | null = null\n\n    set tagName(val: string) {\n      let normalizedTagName = normalizeTagName(val)\n      assert(`Cannot set section tagName to ${val}`, this.isValidTagName(normalizedTagName))\n      this._tagName = normalizedTagName\n    }\n\n    get tagName() {\n      return this._tagName as string\n    }\n\n    abstract isValidTagName(normalizedTagName: string): boolean\n  }\n\n  return TagNameable\n}\n\nexport function isTagNameable(section: Section): section is Section & TagNameable {\n  return 'tagName' in section\n}\n\nexport function expectTagNameable(section: Section): Section & TagNameable {\n  assertType<Section & TagNameable>('expected section to be tag nameable', section, isTagNameable(section))\n  return section\n}\n","import { forEach, reduce } from '../utils/array-utils'\nimport { Range } from '../utils/cursor'\nimport Set from '../utils/set'\nimport LinkedList from '../utils/linked-list'\nimport assert from '../utils/assert'\nimport Position from '../utils/cursor/position'\nimport Section from './_section'\nimport Marker from './marker'\nimport { tagNameable } from './_tag-nameable'\nimport { Type } from './types'\nimport { Cloneable } from './_cloneable'\nimport Markuperable from '../utils/markuperable'\nimport Markup from './markup'\n\ntype MarkerableType = Type.LIST_ITEM | Type.MARKUP_SECTION\n\nexport default abstract class Markerable extends tagNameable(Section) implements Cloneable<Markerable> {\n  type: MarkerableType\n  markers: LinkedList<Markuperable>\n\n  constructor(type: MarkerableType, tagName: string, markers: Markuperable[] = []) {\n    super(type)\n    this.type = type\n    this.isMarkerable = true\n    this.tagName = tagName\n    this.markers = new LinkedList({\n      adoptItem: m => {\n        assert(`Can only insert markers and atoms into markerable (was: ${m.type})`, m.isMarker || m.isAtom)\n        m.section = m.parent = this\n      },\n      freeItem: m => (m.section = m.parent = null),\n    })\n\n    markers.forEach(m => this.markers.append(m))\n  }\n\n  canJoin(other: Markerable) {\n    return other.isMarkerable && other.type === this.type && other.tagName === this.tagName\n  }\n\n  clone(): this {\n    const newMarkers = this.markers.map(m => m.clone())\n    return (this.builder.createMarkerableSection(this.type, this.tagName, newMarkers) as any) as this\n  }\n\n  get isBlank() {\n    if (!this.markers.length) {\n      return true\n    }\n    return this.markers.every(m => m.isBlank)\n  }\n\n  textUntil(position: Position) {\n    assert(`Cannot get textUntil for a position not in this section`, position.section === this)\n    let { marker, offsetInMarker } = position\n    let text = ''\n    let currentMarker = this.markers.head\n    while (currentMarker) {\n      if (currentMarker === marker) {\n        text += currentMarker.textUntil(offsetInMarker)\n        break\n      } else {\n        text += currentMarker.text\n        currentMarker = currentMarker.next\n      }\n    }\n    return text\n  }\n\n  /**\n   * @param {Marker}\n   * @param {Number} markerOffset The offset relative to the start of the marker\n   *\n   * @return {Number} The offset relative to the start of this section\n   */\n  offsetOfMarker(marker: Markuperable, markerOffset = 0) {\n    assert(`Cannot get offsetOfMarker for marker that is not child of this`, marker.section === this)\n\n    // FIXME it is possible, when we get a cursor position before having finished reparsing,\n    // for markerOffset to be > marker.length. We shouldn't rely on this functionality.\n\n    let offset = 0\n    let currentMarker = this.markers.head\n    while (currentMarker && currentMarker !== marker.next) {\n      let length = currentMarker === marker ? markerOffset : currentMarker.length\n      offset += length\n      currentMarker = currentMarker.next\n    }\n\n    return offset\n  }\n\n  // puts clones of this.markers into beforeSection and afterSection,\n  // all markers before the marker/offset split go in beforeSection, and all\n  // after the marker/offset split go in afterSection\n  // @return {Array} [beforeSection, afterSection], two new sections\n  _redistributeMarkers(\n    beforeSection: Markerable,\n    afterSection: Markerable,\n    marker: Marker,\n    offset = 0\n  ): [Section, Section] {\n    let currentSection = beforeSection\n    forEach(this.markers, m => {\n      if (m === marker) {\n        const [beforeMarker, ...afterMarkers] = marker.split(offset)\n        beforeSection.markers.append(beforeMarker)\n        forEach(afterMarkers, _m => afterSection.markers.append(_m))\n        currentSection = afterSection\n      } else {\n        currentSection.markers.append(m.clone())\n      }\n    })\n\n    return [beforeSection, afterSection]\n  }\n\n  abstract splitAtMarker(marker: Markuperable, offset: number): [Section, Section]\n\n  /**\n   * Split this section's marker (if any) at the given offset, so that\n   * there is now a marker boundary at that offset (useful for later applying\n   * a markup to a range)\n   * @param {Number} sectionOffset The offset relative to start of this section\n   * @return {EditObject} An edit object with 'removed' and 'added' keys with arrays of Markers. The added markers may be blank.\n   * After calling `splitMarkerAtOffset(offset)`, there will always be a valid\n   * result returned from `markerBeforeOffset(offset)`.\n   */\n  splitMarkerAtOffset(sectionOffset: number) {\n    assert('Cannot splitMarkerAtOffset when offset is > length', sectionOffset <= this.length)\n    let markerOffset\n    let len = 0\n    let currentMarker = this.markers.head\n    let edit: { added: Markuperable[]; removed: Markuperable[] } = { added: [], removed: [] }\n\n    if (!currentMarker) {\n      let blankMarker = this.builder.createMarker()\n      this.markers.prepend(blankMarker)\n      edit.added.push(blankMarker)\n    } else {\n      while (currentMarker) {\n        len += currentMarker.length\n        if (len === sectionOffset) {\n          // nothing to do, there is a gap at the requested offset\n          break\n        } else if (len > sectionOffset) {\n          markerOffset = currentMarker.length - (len - sectionOffset)\n          let newMarkers = currentMarker.splitAtOffset(markerOffset)\n          edit.added.push(...newMarkers)\n          edit.removed.push(currentMarker)\n          this.markers.splice(currentMarker, 1, newMarkers)\n          break\n        } else {\n          currentMarker = currentMarker.next\n        }\n      }\n    }\n\n    return edit\n  }\n\n  splitAtPosition(position: Position) {\n    const { marker, offsetInMarker } = position\n    return this.splitAtMarker(marker!, offsetInMarker)\n  }\n\n  // returns the marker just before this offset.\n  // It is an error to call this method with an offset that is in the middle\n  // of a marker.\n  markerBeforeOffset(sectionOffset: number) {\n    let len = 0\n    let currentMarker = this.markers.head\n\n    while (currentMarker) {\n      len += currentMarker.length\n      if (len === sectionOffset) {\n        return currentMarker\n      } else {\n        assert('markerBeforeOffset called with sectionOffset not between markers', len < sectionOffset)\n        currentMarker = currentMarker.next\n      }\n    }\n  }\n\n  markerPositionAtOffset(offset: number) {\n    let currentOffset = 0\n    let currentMarker: Markuperable | null = null\n    let remaining = offset\n    this.markers.detect(marker => {\n      currentOffset = Math.min(remaining, marker.length)\n      remaining -= currentOffset\n      if (remaining === 0) {\n        currentMarker = marker\n        return true // break out of detect\n      }\n      return false\n    })\n\n    return { marker: currentMarker!, offset: currentOffset }\n  }\n\n  get text() {\n    return reduce(this.markers, (prev, m) => prev + m.value, '')\n  }\n\n  get length() {\n    return reduce(this.markers, (prev, m) => prev + m.length, 0)\n  }\n\n  /**\n   * @return {Array} New markers that match the boundaries of the\n   * range. Does not change the existing markers in this section.\n   */\n  markersFor(headOffset: number, tailOffset: number) {\n    const range = Range.create(this, headOffset, this, tailOffset)\n\n    let markers: Markuperable[] = []\n    this._markersInRange(range, (marker, { markerHead, markerTail, isContained }) => {\n      const cloned = marker.clone()\n      if (!isContained) {\n        // cannot do marker.value.slice if the marker is an atom -- this breaks the atom's \"atomic\" value\n        // If a marker is an atom `isContained` should always be true so\n        // we shouldn't hit this code path. FIXME add tests\n        cloned.value = marker.value.slice(markerHead, markerTail)\n      }\n      markers.push(cloned)\n    })\n    return markers\n  }\n\n  markupsInRange(range: Range) {\n    const markups = new Set<Markup>()\n    this._markersInRange(range, marker => {\n      marker.markups.forEach(m => markups.add(m))\n    })\n    return markups.toArray()\n  }\n\n  // calls the callback with (marker, {markerHead, markerTail, isContained})\n  // for each marker that is wholly or partially contained in the range.\n  _markersInRange(\n    range: Range,\n    callback: (marker: Markuperable, info: { markerHead: number; markerTail: number; isContained: boolean }) => void\n  ) {\n    const { head, tail } = range\n    assert(\n      'Cannot call #_markersInRange if range expands beyond this section',\n      head.section === this && tail.section === this\n    )\n    const { offset: headOffset } = head,\n      { offset: tailOffset } = tail\n\n    let currentHead = 0,\n      currentTail = 0,\n      currentMarker = this.markers.head\n\n    while (currentMarker) {\n      currentTail += currentMarker.length\n\n      if (currentTail > headOffset && currentHead < tailOffset) {\n        let markerHead = Math.max(headOffset - currentHead, 0)\n        let markerTail = currentMarker.length - Math.max(currentTail - tailOffset, 0)\n        let isContained = markerHead === 0 && markerTail === currentMarker.length\n\n        callback(currentMarker, { markerHead, markerTail, isContained })\n      }\n\n      currentHead += currentMarker.length\n      currentMarker = currentMarker.next\n\n      if (currentHead > tailOffset) {\n        break\n      }\n    }\n  }\n\n  // mutates this by appending the other section's (cloned) markers to it\n  join(otherSection: Markerable) {\n    let beforeMarker = this.markers.tail\n    let afterMarker: Markuperable | null = null\n\n    otherSection.markers.forEach(m => {\n      if (!m.isBlank) {\n        m = m.clone()\n        this.markers.append(m)\n        if (!afterMarker) {\n          afterMarker = m\n        }\n      }\n    })\n\n    return { beforeMarker, afterMarker }\n  }\n}\n\nexport function isMarkerable(section: Section): section is Markerable {\n  return section.isMarkerable\n}\n","export const MARKUP_SECTION_TYPE = 'markup-section'\nexport const LIST_SECTION_TYPE = 'list-section'\nexport const MARKUP_TYPE = 'markup'\nexport const MARKER_TYPE = 'marker'\nexport const POST_TYPE = 'post'\nexport const LIST_ITEM_TYPE = 'list-item'\nexport const CARD_TYPE = 'card-section'\nexport const IMAGE_SECTION_TYPE = 'image-section'\nexport const ATOM_TYPE = 'atom'\n\nexport const enum Type {\n  MARKUP_SECTION = 'markup-section',\n  LIST_SECTION = 'list-section',\n  MARKUP = 'markup',\n  MARKER = 'marker',\n  POST = 'post',\n  LIST_ITEM = 'list-item',\n  CARD = 'card-section',\n  IMAGE_SECTION = 'image-section',\n  ATOM = 'atom',\n}\n","export function entries<T extends { [key: string]: unknown }, K extends Extract<keyof T, string>>(obj: T): [K, T[K]][] {\n  const ownProps = Object.keys(obj) as K[]\n  let i = ownProps.length\n  const resArray = new Array<[K, T[K]]>(i)\n\n  while (i--) {\n    resArray[i] = [ownProps[i], obj[ownProps[i]]]\n  }\n\n  return resArray\n}\n\nexport function keys<T extends { [key: string]: unknown }>(obj: T): (keyof T)[] {\n  return Object.keys(obj)\n}\n","import { entries } from '../utils/object-utils'\nimport { contains } from '../utils/array-utils'\nimport { assertType } from '../utils/assert'\nimport Section, { isNested } from './_section'\nimport { Dict } from '../utils/types'\n\nexport const VALID_ATTRIBUTES = ['data-md-text-align']\n\nexport interface Attributable {\n  attributes: { [key: string]: string }\n  hasAttribute: (key: string) => boolean\n  setAttribute: (key: string, value: string) => void\n  removeAttribute: (key: string) => void\n  getAttribute: (key: string) => string\n  eachAttribute: (cb: (key: string, value: string) => void) => void\n}\n\ntype AbstractConstructor<T> = Function & { prototype: T }\ntype Constructor<T> = new (...args: any[]) => T\n\n/*\n * A \"mixin\" to add section attribute support\n * to markup and list sections.\n */\nexport function attributable<T extends unknown>(Base: AbstractConstructor<T>): Constructor<T & Attributable> {\n  return class extends (Base as any) {\n    attributes: Dict<string> = {}\n\n    hasAttribute(key: string) {\n      return key in this.attributes\n    }\n\n    setAttribute(key: string, value: string) {\n      if (!contains(VALID_ATTRIBUTES, key)) {\n        throw new Error(`Invalid attribute \"${key}\" was passed. Constrain attributes to the spec-compliant whitelist.`)\n      }\n      this.attributes[key] = value\n    }\n\n    removeAttribute(key: string) {\n      delete this.attributes[key]\n    }\n\n    getAttribute(key: string) {\n      return this.attributes[key]\n    }\n\n    eachAttribute(cb: (key: string | number, value: string) => void) {\n      entries(this.attributes).forEach(([k, v]) => cb(k, v))\n    }\n  } as Constructor<T & Attributable>\n}\n\nexport function expectAttributable(section: Section): Section & Attributable {\n  assertType<Section & Attributable>('expected section to be attributable', section, 'attributes' in section)\n  return section\n}\n\nexport function getSectionAttributes(section: Section): Dict<string> {\n  if (isNested(section)) {\n    return section.parent.attributes || {}\n  }\n  return section.attributes || {}\n}\n","import { LIST_SECTION_TYPE } from './types'\nimport Section from './_section'\nimport { attributable } from './_attributable'\nimport LinkedList from '../utils/linked-list'\nimport { forEach, contains } from '../utils/array-utils'\nimport { normalizeTagName } from '../utils/dom-utils'\nimport assert from '../utils/assert'\nimport { entries } from '../utils/object-utils'\nimport ListItem from './list-item'\nimport { tagNameable } from './_tag-nameable'\nimport HasChildSections from './_has-child-sections'\nimport { PostNode } from './post-node-builder'\nimport Markerable from './_markerable'\n\nexport const VALID_LIST_SECTION_TAGNAMES = ['ul', 'ol'].map(normalizeTagName)\n\nexport const DEFAULT_TAG_NAME = VALID_LIST_SECTION_TAGNAMES[0]\n\nexport default class ListSection extends attributable(tagNameable(Section)) implements HasChildSections<ListItem> {\n  isListSection = true\n  isLeafSection = false\n\n  items: LinkedList<ListItem>\n  sections: LinkedList<ListItem>\n\n  constructor(tagName = DEFAULT_TAG_NAME, items: ListItem[] = [], attributes = {}) {\n    super(LIST_SECTION_TYPE)\n    this.tagName = tagName\n\n    entries(attributes).forEach(([k, v]) => this.setAttribute(k, v))\n\n    this.items = new LinkedList<ListItem>({\n      adoptItem: i => {\n        assert(`Cannot insert non-list-item to list (is: ${i.type})`, i.isListItem)\n        i.section = i._parent = this\n      },\n      freeItem: i => (i.section = i._parent = null),\n    })\n    this.sections = this.items\n\n    items.forEach(i => this.items.append(i))\n  }\n\n  canJoin() {\n    return false\n  }\n\n  isValidTagName(normalizedTagName: string) {\n    return contains(VALID_LIST_SECTION_TAGNAMES, normalizedTagName)\n  }\n\n  headPosition() {\n    return this.items.head!.headPosition()\n  }\n\n  tailPosition() {\n    return this.items.tail!.tailPosition()\n  }\n\n  get isBlank() {\n    return this.items.isEmpty\n  }\n\n  clone() {\n    let newSection = this.builder.createListSection(this.tagName)\n    forEach(this.items, i => newSection.items.append(i.clone()))\n    return newSection\n  }\n\n  /**\n   * Mutates this list\n   * @param {ListSection|Markerable}\n   * @return null\n   */\n  join(other: ListSection | Markerable) {\n    if (isListSection(other)) {\n      other.items.forEach(i => this.join(i))\n    } else if (other.isMarkerable) {\n      let item = this.builder.createListItem()\n      item.join(other)\n      this.items.append(item)\n    }\n  }\n}\n\nexport function isListSection(section: PostNode): section is ListSection {\n  return (section as Section).isListSection\n}\n","import Markerable from './_markerable'\nimport { Type } from './types'\nimport { normalizeTagName } from '../utils/dom-utils'\nimport { contains } from '../utils/array-utils'\nimport Section from './_section'\nimport { expect } from '../utils/assert'\nimport Marker from './marker'\nimport Markuperable from '../utils/markuperable'\nimport ListSection from './list-section'\n\nexport const VALID_LIST_ITEM_TAGNAMES = ['li'].map(normalizeTagName)\n\nexport default class ListItem extends Markerable {\n  isListItem = true\n  isNested = true\n  section: Section | null = null\n  parent!: ListSection\n\n  constructor(tagName: string, markers: Markuperable[] = []) {\n    super(Type.LIST_ITEM, tagName, markers)\n  }\n\n  isValidTagName(normalizedTagName: string) {\n    return contains(VALID_LIST_ITEM_TAGNAMES, normalizedTagName)\n  }\n\n  splitAtMarker(marker: Marker, offset = 0): [Section, Section] {\n    // FIXME need to check if we are going to split into two list items\n    // or a list item and a new markup section:\n    const isLastItem = !this.next\n    const createNewSection = !marker && offset === 0 && isLastItem\n\n    let [beforeSection, afterSection] = [\n      this.builder.createListItem(),\n      createNewSection ? this.builder.createMarkupSection() : this.builder.createListItem(),\n    ]\n\n    return this._redistributeMarkers(beforeSection, afterSection, marker, offset)\n  }\n\n  get post() {\n    return expect(this.section, 'expected list item to have section').post\n  }\n}\n\nexport function isListItem(section: Section): section is ListItem {\n  return section.isListItem\n}\n","import Markerable from './_markerable'\nimport { attributable } from './_attributable'\nimport { MARKUP_SECTION_TYPE } from './types'\nimport { normalizeTagName } from '../utils/dom-utils'\nimport { contains } from '../utils/array-utils'\nimport { entries } from '../utils/object-utils'\nimport Marker from './marker'\nimport Markuperable from '../utils/markuperable'\nimport Section from './_section'\n\n// valid values of `tagName` for a MarkupSection\nexport const VALID_MARKUP_SECTION_TAGNAMES = ['aside', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p'].map(\n  normalizeTagName\n)\n\n// valid element names for a MarkupSection. A MarkupSection with a tagName\n// not in this will be rendered as a div with a className matching the\n// tagName\nexport const MARKUP_SECTION_ELEMENT_NAMES = ['aside', 'blockquote', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p'].map(\n  normalizeTagName\n)\nexport const DEFAULT_TAG_NAME = VALID_MARKUP_SECTION_TAGNAMES[8]\n\nexport default class MarkupSection extends attributable(Markerable) {\n  isMarkupSection = true\n  isGenerated = false\n\n  _inferredTagName: boolean = false\n\n  constructor(tagName = DEFAULT_TAG_NAME, markers: Markuperable[] = [], attributes = {}) {\n    super(MARKUP_SECTION_TYPE, tagName, markers)\n    entries(attributes).forEach(([k, v]) => this.setAttribute(k, v))\n  }\n\n  isValidTagName(normalizedTagName: string) {\n    return contains(VALID_MARKUP_SECTION_TAGNAMES, normalizedTagName)\n  }\n\n  splitAtMarker(marker: Marker, offset = 0) {\n    let [beforeSection, afterSection] = [\n      this.builder.createMarkupSection(this.tagName, [], false, this.attributes),\n      this.builder.createMarkupSection(),\n    ]\n\n    return this._redistributeMarkers(beforeSection, afterSection, marker, offset)\n  }\n}\n\nexport function isMarkupSection(section: Section): section is MarkupSection {\n  return (section as MarkupSection).isMarkupSection\n}\n\nexport function hasInferredTagName(section: Section): section is MarkupSection {\n  return isMarkupSection(section) && section._inferredTagName\n}\n","import Position from '../utils/cursor/position'\nimport Range from '../utils/cursor/range'\nimport { detect, forEach, reduce, filter, values, commonItems } from '../utils/array-utils'\nimport { Direction } from '../utils/key'\nimport LifecycleCallbacks, { LifecycleCallback } from '../models/lifecycle-callbacks'\nimport assert, { assertType } from '../utils/assert'\nimport { normalizeTagName } from '../utils/dom-utils'\nimport PostInserter from './post/post-inserter'\nimport deprecate from '../utils/deprecate'\nimport toRange from '../utils/to-range'\nimport { Option, Maybe } from '../utils/types'\nimport Editor, { TextUnit } from './editor'\nimport PostNodeBuilder, { PostNode } from '../models/post-node-builder'\nimport Markerable, { isMarkerable } from '../models/_markerable'\nimport Section from '../models/_section'\nimport Markuperable from '../utils/markuperable'\nimport Post from '../models/post'\nimport ListSection, { isListSection } from '../models/list-section'\nimport ListItem, { isListItem } from '../models/list-item'\nimport Card, { isCardSection } from '../models/card'\nimport LinkedList from '../utils/linked-list'\nimport { Cloneable } from '../models/_cloneable'\nimport HasChildSections, { hasChildSections } from '../models/_has-child-sections'\nimport { Attributable } from '../models/_attributable'\nimport Markup from '../models/markup'\nimport { isMarkupSection } from '../models/markup-section'\nimport { TagNameable } from '../models/_tag-nameable'\n\nconst { FORWARD, BACKWARD } = Direction\n\nfunction isListSectionTagName(tagName: string) {\n  return tagName === 'ul' || tagName === 'ol'\n}\n\nfunction shrinkRange(range: Range) {\n  const { head, tail } = range\n\n  if (tail.offset === 0 && head.section !== tail.section) {\n    range.tail = new Position(tail.section!.prev, tail.section!.prev!.length)\n  }\n\n  return range\n}\n\nconst CALLBACK_QUEUES = {\n  BEFORE_COMPLETE: 'beforeComplete',\n  COMPLETE: 'complete',\n  AFTER_COMPLETE: 'afterComplete',\n}\n\n// There are only two events that we're concerned about for Undo, that is inserting text and deleting content.\n// These are the only two states that go on a \"run\" and create a combined undo, everything else has it's own\n// deadicated undo.\nexport const enum EditAction {\n  INSERT_TEXT = 1,\n  DELETE = 2,\n}\n\ninterface SectionTransformation {\n  from: Section\n  to: Section\n}\n\n/**\n * The PostEditor is used to modify a post. It should not be instantiated directly.\n * Instead, a new instance of a PostEditor is created by the editor and passed\n * as the argument to the callback in {@link Editor#run}.\n *\n * Usage:\n * ```\n * editor.run((postEditor) => {\n *   // postEditor is an instance of PostEditor that can operate on the\n *   // editor's post\n * });\n * ```\n */\nexport default class PostEditor {\n  /**\n   * @private\n   */\n  editor: Editor\n  builder: PostNodeBuilder\n\n  editActionTaken: Option<EditAction>\n\n  _callbacks: LifecycleCallbacks\n  _range!: Range\n  _didComplete: boolean\n  _renderRange: () => void\n  _postDidChange: () => void\n  _rerender: () => void\n  _shouldCancelSnapshot!: boolean\n\n  constructor(editor: Editor) {\n    this.editor = editor\n    this.builder = this.editor.builder\n    this._callbacks = new LifecycleCallbacks(values(CALLBACK_QUEUES))\n\n    this._didComplete = false\n    this.editActionTaken = null\n\n    this._renderRange = () => this.editor.selectRange(this._range)\n    this._postDidChange = () => this.editor._postDidChange()\n    this._rerender = () => this.editor.rerender()\n  }\n\n  addCallback(queueName: string, callback: LifecycleCallback) {\n    this._callbacks.addCallback(queueName, callback)\n  }\n\n  addCallbackOnce(queueName: string, callback: LifecycleCallback) {\n    this._callbacks.addCallbackOnce(queueName, callback)\n  }\n\n  runCallbacks(queueName: string) {\n    this._callbacks.runCallbacks(queueName)\n  }\n\n  begin() {\n    // cache the editor's range\n    this._range = this.editor.range\n  }\n\n  /**\n   * Schedules to select the given range on the editor after the postEditor\n   * has completed its work. This also updates the postEditor's active range\n   * (so that multiple calls to range-changing methods on the postEditor will\n   * update the correct range).\n   *\n   * Usage:\n   *   let range = editor.range;\n   *   editor.run(postEditor => {\n   *     let nextPosition = postEditor.deleteRange(range);\n   *\n   *     // Will position the editor's cursor at `nextPosition` after\n   *     // the postEditor finishes work and the editor rerenders.\n   *     postEditor.setRange(nextPosition);\n   *   });\n   * @param {Range|Position} range\n   * @public\n   */\n  setRange(range: Range | Position) {\n    range = toRange(range)\n\n    // TODO validate that the range is valid\n    // (does not contain marked-for-removal head or tail sections?)\n    this._range = range\n    this.scheduleAfterRender(this._renderRange, true)\n  }\n\n  /**\n   * Delete a range from the post\n   *\n   * Usage:\n   * ```\n   *     let { range } = editor;\n   *     editor.run((postEditor) => {\n   *       let nextPosition = postEditor.deleteRange(range);\n   *       postEditor.setRange(nextPosition);\n   *     });\n   * ```\n   * @param {Range} range Cursor Range object with head and tail Positions\n   * @return {Position} The position where the cursor would go after deletion\n   * @public\n   */\n  deleteRange(range: Range): Position {\n    assert('Must pass MobiledocKit Range to `deleteRange`', range instanceof Range)\n\n    this.editActionTaken = EditAction.DELETE\n\n    const { head, tail } = range\n    let headSection = head.section!\n    let tailSection = tail.section!\n\n    const { editor } = this\n    const { post } = editor\n\n    if (headSection === tailSection) {\n      return this.cutSection(headSection, head, tail)\n    }\n\n    let nextSection = headSection!.nextLeafSection()\n\n    let nextPos = this.cutSection(headSection, head, headSection!.tailPosition())\n    // cutSection can replace the section, so re-read headSection here\n    headSection = nextPos.section!\n\n    // Remove sections in the middle of the range\n    while (nextSection !== tailSection) {\n      let tmp = nextSection!\n      nextSection = nextSection!.nextLeafSection()\n      this.removeSection(tmp)\n    }\n\n    let tailPos = this.cutSection(tailSection, tailSection!.headPosition(), tail)\n    // cutSection can replace the section, so re-read tailSection here\n    tailSection = tailPos.section!\n\n    if (tailSection.isBlank) {\n      this.removeSection(tailSection)\n    } else {\n      // If head and tail sections are markerable, join them\n      // Note: They may not be the same section type. E.g. this may join\n      // a tail section that was a list item onto a markup section, or vice versa.\n      // (This is the desired behavior.)\n      if (isMarkerable(headSection) && isMarkerable(tailSection)) {\n        headSection.join(tailSection)\n        this._markDirty(headSection)\n        this.removeSection(tailSection)\n      } else if (headSection.isBlank) {\n        this.removeSection(headSection)\n        nextPos = tailPos\n      }\n    }\n\n    if (post.isBlank) {\n      post.sections.append(this.builder.createMarkupSection('p'))\n      nextPos = post.headPosition()\n    }\n\n    return nextPos\n  }\n\n  /**\n   * Note: This method may replace `section` with a different section.\n   *\n   * \"Cut\" out the part of the section inside `headOffset` and `tailOffset`.\n   * If section is markerable this splits markers that straddle the head or tail (if necessary),\n   * and removes markers that are wholly inside the offsets.\n   * If section is a card, this may replace it with a blank markup section if the\n   * positions contain the entire card.\n   *\n   * @param {Section} section\n   * @param {Position} head\n   * @param {Position} tail\n   * @return {Position}\n   * @private\n   */\n  cutSection(section: Section, head: Position, tail: Position): Position {\n    assert(\n      'Must pass head position and tail position to `cutSection`',\n      head instanceof Position && tail instanceof Position\n    )\n    assert('Must pass positions within same section to `cutSection`', head.section === tail.section)\n\n    if (section.isBlank || head.isEqual(tail)) {\n      return head\n    }\n    if (section.isCardSection) {\n      if (head.isHead() && tail.isTail()) {\n        let newSection = this.builder.createMarkupSection()\n        this.replaceSection(section, newSection)\n        return newSection.headPosition()\n      } else {\n        return tail\n      }\n    }\n\n    let range = head.toRange(tail)\n    this.splitMarkers(range).forEach(m => this.removeMarker(m))\n\n    return head\n  }\n\n  _coalesceMarkers(section: Section) {\n    if (isMarkerable(section)) {\n      this._removeBlankMarkers(section)\n      this._joinSimilarMarkers(section)\n    }\n  }\n\n  _removeBlankMarkers(section: Markerable) {\n    forEach(\n      filter(section.markers, m => m.isBlank),\n      m => this.removeMarker(m)\n    )\n  }\n\n  // joins markers that have identical markups\n  _joinSimilarMarkers(section: Markerable) {\n    let marker = section.markers.head\n    let nextMarker: Markuperable\n    while (marker && marker.next) {\n      nextMarker = marker.next\n\n      if (marker.canJoin(nextMarker)) {\n        nextMarker.value = marker.value + nextMarker.value\n        this._markDirty(nextMarker)\n        this.removeMarker(marker)\n      }\n\n      marker = nextMarker\n    }\n  }\n\n  removeMarker(marker: Markuperable) {\n    this._scheduleForRemoval(marker)\n    if (marker.section) {\n      this._markDirty(marker.section)\n      marker.section.markers.remove(marker)\n    }\n  }\n\n  _scheduleForRemoval(postNode: Exclude<PostNode, Post>) {\n    if (postNode.renderNode) {\n      postNode.renderNode.scheduleForRemoval()\n\n      this.scheduleRerender()\n      this.scheduleDidUpdate()\n    }\n    let removedAdjacentToList =\n      (postNode.prev && isListSection(postNode.prev as Section)) ||\n      (postNode.next && isListSection(postNode.next as Section))\n    if (removedAdjacentToList) {\n      this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => this._joinContiguousListSections())\n    }\n  }\n\n  _joinContiguousListSections() {\n    let { post } = this.editor\n    let range = this._range\n    let prev: Section\n    let groups: ListSection[][] = []\n    let currentGroup!: Option<ListSection[]>\n\n    // FIXME do we need to force a re-render of the range if changed sections\n    // are contained within the range?\n    let updatedHead: Option<Position> = null\n    forEach(post.sections, section => {\n      if (prev && isListSection(prev) && isListSection(section) && prev.tagName === section.tagName) {\n        currentGroup = currentGroup || [prev]\n        currentGroup.push(section)\n      } else {\n        if (currentGroup) {\n          groups.push(currentGroup)\n        }\n        currentGroup = null\n      }\n      prev = section\n    })\n\n    if (currentGroup) {\n      groups.push(currentGroup)\n    }\n\n    forEach(groups, group => {\n      let list = group[0]\n      forEach(group, listSection => {\n        if (listSection === list) {\n          return\n        }\n\n        let currentHead = range.head\n        let prevPosition: Maybe<Position>\n\n        // FIXME is there a currentHead if there is no range?\n        // is the current head a list item in the section\n        if (!range.isBlank && isListItem(currentHead.section!) && currentHead.section.parent === listSection) {\n          prevPosition = list.tailPosition()\n        }\n        this._joinListSections(list, listSection)\n        if (prevPosition) {\n          updatedHead = prevPosition.move(FORWARD)\n        }\n      })\n    })\n\n    if (updatedHead) {\n      this.setRange(updatedHead)\n    }\n  }\n\n  _joinListSections(baseList: ListSection, nextList: ListSection) {\n    baseList.join(nextList)\n    this._markDirty(baseList)\n    this.removeSection(nextList)\n  }\n\n  _markDirty(postNode: PostNode) {\n    if (postNode.renderNode) {\n      postNode.renderNode.markDirty()\n\n      this.scheduleRerender()\n      this.scheduleDidUpdate()\n    }\n    if ('section' in postNode && postNode.section) {\n      this._markDirty(postNode.section)\n    }\n    if (isMarkerable(postNode as Section)) {\n      this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => this._coalesceMarkers(postNode as Markerable))\n    }\n  }\n\n  /**\n   * @param {Position} position object with {section, offset} the marker and offset to delete from\n   * @param {Number} direction The direction to delete in (default is BACKWARD)\n   * @return {Position} for positioning the cursor\n   * @public\n   * @deprecated after v0.10.3\n   */\n  deleteFrom(position: Position, direction: Direction = Direction.BACKWARD): Position {\n    deprecate(\n      \"`postEditor#deleteFrom is deprecated. Use `deleteAtPosition(position, direction=BACKWARD, {unit}={unit: 'char'})` instead\"\n    )\n    return this.deleteAtPosition(position, direction, { unit: TextUnit.CHAR })\n  }\n\n  /**\n   * Delete 1 `unit` (can be 'char' or 'word') in the given `direction` at the given\n   * `position`. In almost all cases this will be equivalent to deleting the range formed\n   * by expanding the position 1 unit in the given direction. The exception is when deleting\n   * backward from the beginning of a list item, which reverts the list item into a markup section\n   * instead of joining it with its previous list item (if any).\n   *\n   * Usage:\n   *\n   *     let position = section.tailPosition();\n   *     // Section has text of \"Howdy!\"\n   *     editor.run((postEditor) => {\n   *       postEditor.deleteAtPosition(position);\n   *     });\n   *     // section has text of \"Howdy\"\n   *\n   * @param {Position} position The position to delete at\n   * @param {Direction} [direction=DIRECTION.BACKWARD] direction The direction to delete in\n   * @param {Object} [options]\n   * @param {String} [options.unit=\"char\"] The unit of deletion (\"word\" or \"char\")\n   * @return {Position}\n   */\n  deleteAtPosition(\n    position: Position,\n    direction: Direction = Direction.BACKWARD,\n    { unit }: { unit: TextUnit } = { unit: TextUnit.CHAR }\n  ): Position {\n    if (direction === Direction.BACKWARD) {\n      return this._deleteAtPositionBackward(position, unit)\n    } else {\n      return this._deleteAtPositionForward(position, unit)\n    }\n  }\n\n  _deleteAtPositionBackward(position: Position, unit: TextUnit) {\n    if (position.isHead() && isListItem(position.section!)) {\n      this.toggleSection('p', position)\n      return this._range.head\n    } else {\n      let prevPosition = unit === 'word' ? position.moveWord(BACKWARD) : position.move(BACKWARD)\n      let range = prevPosition.toRange(position)\n      return this.deleteRange(range)\n    }\n  }\n\n  _deleteAtPositionForward(position: Position, unit: TextUnit) {\n    let nextPosition = unit === 'word' ? position.moveWord(FORWARD) : position.move(FORWARD)\n    let range = position.toRange(nextPosition)\n    return this.deleteRange(range)\n  }\n\n  /**\n   * Split markers at two positions, once at the head, and if necessary once\n   * at the tail.\n   *\n   * Usage:\n   * ```\n   *     let range = editor.range;\n   *     editor.run((postEditor) => {\n   *       postEditor.splitMarkers(range);\n   *     });\n   * ```\n   * The return value will be marker object completely inside the offsets\n   * provided. Markers outside of the split may also have been modified.\n   *\n   * @param {Range} markerRange\n   * @return {Array} of markers that are inside the split\n   * @private\n   */\n  splitMarkers(range: Range): Markuperable[] {\n    const { post } = this.editor\n    const { head, tail } = range\n\n    this.splitSectionMarkerAtOffset(head.section!, head.offset)\n    this.splitSectionMarkerAtOffset(tail.section!, tail.offset)\n\n    return post.markersContainedByRange(range)\n  }\n\n  splitSectionMarkerAtOffset(section: Section, offset: number) {\n    const edit = section.splitMarkerAtOffset(offset)\n    edit.removed.forEach(m => this.removeMarker(m))\n  }\n\n  /**\n   * Split the section at the position.\n   *\n   * Usage:\n   * ```\n   *     let position = editor.cursor.offsets.head;\n   *     editor.run((postEditor) => {\n   *       postEditor.splitSection(position);\n   *     });\n   *     // Will result in the creation of two new sections\n   *     // replacing the old one at the cursor position\n   * ```\n   * The return value will be the two new sections. One or both of these\n   * sections can be blank (contain only a blank marker), for example if the\n   * headMarkerOffset is 0.\n   *\n   * @param {Position} position\n   * @return {Array} new sections, one for the first half and one for the second (either one can be null)\n   * @public\n   */\n  splitSection(position: Position): [Option<Section>, Option<Section>] {\n    const section = position.section!\n\n    if (isCardSection(section)) {\n      return this._splitCardSection(section, position)\n    } else if (isListItem(section)) {\n      let isLastAndBlank = section.isBlank && !section.next\n      if (isLastAndBlank) {\n        // if is last, replace the item with a blank markup section\n        let parent = section.parent\n        let collection = this.editor.post.sections\n        let blank = this.builder.createMarkupSection()\n        this.removeSection(section)\n        this.insertSectionBefore(collection, blank, parent.next)\n\n        return [null, blank]\n      } else {\n        let [pre, post] = this._splitListItem(section, position)\n        return [pre, post]\n      }\n    } else {\n      let splitSections = (section as Markerable).splitAtPosition(position)\n      splitSections.forEach(s => this._coalesceMarkers(s))\n      this._replaceSection(section, splitSections)\n\n      return splitSections\n    }\n  }\n\n  /**\n   * @param {Section} cardSection\n   * @param {Position} position to split at\n   * @return {Section[]} 2-item array of pre and post-split sections\n   * @private\n   */\n  _splitCardSection(cardSection: Card, position: Position): [Section, Section] {\n    let { offset } = position\n    assert('Cards section must be split at offset 0 or 1', offset === 0 || offset === 1)\n\n    let newSection = this.builder.createMarkupSection()\n    let nextSection: Section\n    let surroundingSections: [Section, Section]\n\n    if (offset === 0) {\n      nextSection = cardSection\n      surroundingSections = [newSection, cardSection]\n    } else {\n      nextSection = cardSection.next!\n      surroundingSections = [cardSection, newSection]\n    }\n\n    let collection = this.editor.post.sections\n    this.insertSectionBefore(collection, newSection, nextSection)\n\n    return surroundingSections\n  }\n\n  /**\n   * @param {Section} section\n   * @param {Section} newSection\n   * @public\n   */\n  replaceSection(section: Section, newSection: Section) {\n    if (!section) {\n      // FIXME should a falsy section be a valid argument?\n      this.insertSectionBefore(this.editor.post.sections, newSection, null)\n    } else {\n      this._replaceSection(section, [newSection])\n    }\n  }\n\n  moveSectionBefore(\n    collection: LinkedList<Cloneable<Section>>,\n    renderedSection: Cloneable<Section>,\n    beforeSection: Section\n  ) {\n    const newSection = renderedSection.clone()\n    this.removeSection(renderedSection)\n    this.insertSectionBefore(collection, newSection, beforeSection)\n    return newSection\n  }\n\n  /**\n   * @param {Section} section A section that is already in DOM\n   * @public\n   */\n  moveSectionUp(renderedSection: Cloneable<Section>) {\n    const isFirst = !renderedSection.prev\n    if (isFirst) {\n      return renderedSection\n    }\n\n    const collection = renderedSection.parent.sections\n    const beforeSection = renderedSection.prev!\n    return this.moveSectionBefore(collection, renderedSection, beforeSection)\n  }\n\n  /**\n   * @param {Section} section A section that is already in DOM\n   * @public\n   */\n  moveSectionDown(renderedSection: Cloneable<Section>) {\n    const isLast = !renderedSection.next\n    if (isLast) {\n      return renderedSection\n    }\n\n    const beforeSection = renderedSection.next!.next!\n    const collection = renderedSection.parent.sections\n    return this.moveSectionBefore(collection, renderedSection, beforeSection)\n  }\n\n  /**\n   * Insert an array of markers at the given position. If the position is in\n   * a non-markerable section (like a card section), this method throws an error.\n   *\n   * @param {Position} position\n   * @param {Marker[]} markers\n   * @return {Position} The position that represents the end of the inserted markers.\n   * @public\n   */\n  insertMarkers(position: Position, markers: Markuperable[]): Position {\n    const section = position.section! as Markerable\n    let offset = position.offset\n\n    assert('Cannot insert markers at non-markerable position', section!.isMarkerable)\n\n    this.editActionTaken = EditAction.INSERT_TEXT\n\n    let edit = section.splitMarkerAtOffset(offset)\n    edit.removed.forEach(marker => this._scheduleForRemoval(marker))\n\n    let prevMarker = section.markerBeforeOffset(offset)\n    markers.forEach(marker => {\n      section.markers.insertAfter(marker, prevMarker!)\n      offset += marker.length\n      prevMarker = marker\n    })\n\n    this._coalesceMarkers(section)\n    this._markDirty(section)\n\n    let nextPosition = section.toPosition(offset)\n    this.setRange(nextPosition)\n    return nextPosition\n  }\n\n  /**\n   * Inserts text with the given markups, ignoring the existing markups at\n   * the position, if any.\n   *\n   * @param {Position} position\n   * @param {String} text\n   * @param {Markup[]} markups\n   * @return {Position} position at the end of the inserted text\n   */\n  insertTextWithMarkup(position: Position, text: string, markups: Markup[] = []): Maybe<Position> {\n    let { section } = position\n    if (!section!.isMarkerable) {\n      return\n    }\n    let marker = this.builder.createMarker(text, markups)\n    return this.insertMarkers(position, [marker])\n  }\n\n  /**\n   * Insert the text at the given position\n   * Inherits the markups already at that position, if any.\n   *\n   * @param {Position} position\n   * @param {String} text\n   * @return {Position} position at the end of the inserted text.\n   */\n  insertText(position: Position, text: string): Maybe<Position> {\n    let { section } = position\n    if (!section!.isMarkerable) {\n      return\n    }\n    let markups = position.marker && position.marker.markups\n    markups = markups || []\n    return this.insertTextWithMarkup(position, text, markups)\n  }\n\n  _replaceSection(section: Section, newSections: Section[]) {\n    let nextSection = section.next\n    let collection = ((section.parent as unknown) as HasChildSections).sections\n\n    let nextNewSection = newSections[0]\n    if (isMarkupSection(nextNewSection) && isListItem(section)) {\n      // put the new section after the ListSection (section.parent)\n      // instead of after the ListItem\n      collection = ((section.parent.parent as unknown) as HasChildSections).sections\n      nextSection = section.parent.next\n    }\n\n    newSections.forEach(s => this.insertSectionBefore(collection, s, nextSection))\n    this.removeSection(section)\n  }\n\n  /**\n   * Given a markerRange (for example `editor.range`) mark all markers\n   * inside it as a given markup. The markup must be provided as a post\n   * abstract node.\n   *\n   * Usage:\n   *\n   *     let range = editor.range;\n   *     let strongMarkup = editor.builder.createMarkup('strong');\n   *     editor.run((postEditor) => {\n   *       postEditor.addMarkupToRange(range, strongMarkup);\n   *     });\n   *     // Will result some markers possibly being split, and the markup\n   *     // being applied to all markers between the split.\n   *\n   * @param {Range} range\n   * @param {Markup} markup A markup post abstract node\n   * @public\n   */\n  addMarkupToRange(range: Range, markup: Markup) {\n    if (range.isCollapsed) {\n      return\n    }\n\n    let markers = this.splitMarkers(range)\n    if (markers.length) {\n      // We insert the new markup at a consistent index across the range.\n      // If we just push on the end of the list, it can end up in different positions\n      // of the markup stack. This results in unnecessary closing and re-opening of\n      // the markup each time it changes position.\n      // If we just push it at the beginning of the list, this causes unnecessary closing\n      // and re-opening of surrounding tags.\n      // So, we look for any tags open across the whole range, and push into the stack\n      // at the end of those.\n      // Prompted by https://github.com/bustle/mobiledoc-kit/issues/360\n\n      let markupsOpenAcrossRange = reduce(\n        markers,\n        function (soFar, marker) {\n          return commonItems(soFar, marker.markups)\n        },\n        markers[0].markups\n      )\n      let indexToInsert = markupsOpenAcrossRange.length\n\n      markers.forEach(marker => {\n        marker.addMarkupAtIndex(markup, indexToInsert)\n        this._markDirty(marker)\n      })\n    }\n  }\n\n  /**\n   * Given a markerRange (for example `editor.range`) remove the given\n   * markup from all contained markers.\n   *\n   * Usage:\n   * ```\n   *     let { range } = editor;\n   *     let markup = markerRange.headMarker.markups[0];\n   *     editor.run(postEditor => {\n   *       postEditor.removeMarkupFromRange(range, markup);\n   *     });\n   *     // Will result in some markers possibly being split, and the markup\n   *     // being removed from all markers between the split.\n   * ```\n   * @param {Range} range Object with offsets\n   * @param {Markup|Function} markupOrCallback A markup post abstract node or\n   * a function that returns true when passed a markup that should be removed\n   * @private\n   */\n  removeMarkupFromRange(range: Range, markupOrMarkupCallback: ((markup: Markup) => boolean) | Markup) {\n    if (range.isCollapsed) {\n      return\n    }\n\n    this.splitMarkers(range).forEach(marker => {\n      marker.removeMarkup(markupOrMarkupCallback)\n      this._markDirty(marker)\n    })\n  }\n\n  /**\n   * Toggle the given markup in the given range (or at the position given). If the range/position\n   * has the markup, the markup will be removed. If nothing in the range/position\n   * has the markup, the markup will be added to everything in the range/position.\n   *\n   * Usage:\n   * ```\n   * // Remove any 'strong' markup if it exists in the selection, otherwise\n   * // make it all 'strong'\n   * editor.run(postEditor => postEditor.toggleMarkup('strong'));\n   *\n   * // add/remove a link to 'bustle.com' to the selection\n   * editor.run(postEditor => {\n   *   const linkMarkup = postEditor.builder.createMarkup('a', {href: 'http://bustle.com'});\n   *   postEditor.toggleMarkup(linkMarkup);\n   * });\n   * ```\n   * @param {Markup|String} markupOrString Either a markup object created using\n   * the builder (useful when adding a markup with attributes, like an 'a' markup),\n   * or, if a string, the tag name of the markup (e.g. 'strong', 'em') to toggle.\n   * @param {Range|Position} range in which to toggle. Defaults to current editor range.\n   * @public\n   */\n  toggleMarkup(markupOrMarkupString: Markup | string, range: Range | Position = this._range) {\n    range = toRange(range)\n    const markup =\n      typeof markupOrMarkupString === 'string' ? this.builder.createMarkup(markupOrMarkupString) : markupOrMarkupString\n\n    const hasMarkup = this.editor.detectMarkupInRange(range, markup.tagName)\n    // FIXME: This implies only a single markup in a range. This may not be\n    // true for links (which are not the same object instance like multiple\n    // strong tags would be).\n    if (hasMarkup) {\n      this.removeMarkupFromRange(range, hasMarkup)\n    } else {\n      this.addMarkupToRange(range, markup)\n    }\n\n    this.setRange(range)\n  }\n\n  /**\n   * Toggles the tagName of the active section or sections in the given range/position.\n   * If every section has the tag name, they will all be reset to default sections.\n   * Otherwise, every section will be changed to the requested type\n   *\n   * @param {String} sectionTagName A valid markup section or\n   *        list section tag name (e.g. 'blockquote', 'h2', 'ul')\n   * @param {Range|Position} range The range over which to toggle.\n   *        Defaults to the current editor range.\n   * @public\n   */\n  toggleSection(sectionTagName: string, range: Range | Position = this._range) {\n    range = shrinkRange(toRange(range))\n\n    sectionTagName = normalizeTagName(sectionTagName)\n    let { post } = this.editor\n\n    let everySectionHasTagName = true\n    post.walkMarkerableSections(range, section => {\n      if (!this._isSameSectionType(section, sectionTagName)) {\n        everySectionHasTagName = false\n      }\n    })\n\n    let tagName = everySectionHasTagName ? 'p' : sectionTagName\n    let sectionTransformations: SectionTransformation[] = []\n    post.walkMarkerableSections(range, section => {\n      let changedSection = this.changeSectionTagName(section, tagName)\n\n      sectionTransformations.push({\n        from: section,\n        to: changedSection,\n      })\n    })\n\n    let nextRange = this._determineNextRangeAfterToggleSection(range, sectionTransformations)\n    this.setRange(nextRange)\n  }\n\n  _determineNextRangeAfterToggleSection(range: Range, sectionTransformations: SectionTransformation[]) {\n    if (sectionTransformations.length) {\n      let changedHeadSection = detect(sectionTransformations, ({ from }) => {\n        return from === range.headSection\n      })!.to\n      let changedTailSection = detect(sectionTransformations, ({ from }) => {\n        return from === range.tailSection\n      })!.to\n\n      if (changedHeadSection.isListSection || changedTailSection.isListSection) {\n        // We don't know to which ListItem's the original sections point at, so\n        // we don't have enough information to reconstruct the range when\n        // dealing with lists.\n        return sectionTransformations[0].to.headPosition().toRange()\n      } else {\n        return Range.create(\n          changedHeadSection as Markerable,\n          range.headSectionOffset,\n          changedTailSection as Markerable,\n          range.tailSectionOffset,\n          range.direction\n        )\n      }\n    } else {\n      return range\n    }\n  }\n\n  setAttribute(key: string, value: string, range: Range = this._range) {\n    this._mutateAttribute(key, range, (section, attribute) => {\n      if (section.getAttribute(attribute) !== value) {\n        section.setAttribute(attribute, value)\n        return true\n      }\n    })\n  }\n\n  removeAttribute(key: string, range: Range = this._range) {\n    this._mutateAttribute(key, range, (section, attribute) => {\n      if (section.hasAttribute(attribute)) {\n        section.removeAttribute(attribute)\n        return true\n      }\n    })\n  }\n\n  _mutateAttribute(key: string, range: Range, cb: (section: Attributable, attribute: string) => boolean | void) {\n    range = toRange(range)\n    let { post } = this.editor\n    let attribute = `data-md-${key}`\n\n    post.walkMarkerableSections(range, section => {\n      const cbSection: Attributable = isListItem(section) ? section.parent : ((section as unknown) as Attributable)\n\n      if (cb(cbSection, attribute) === true) {\n        this._markDirty(section)\n      }\n    })\n\n    this.setRange(range)\n  }\n\n  _isSameSectionType(section: Section & TagNameable, sectionTagName: string) {\n    return isListItem(section) ? section.parent.tagName === sectionTagName : section.tagName === sectionTagName\n  }\n\n  /**\n   * @param {Markerable} section\n   * @private\n   */\n  changeSectionTagName(section: Markerable & TagNameable, newTagName: string) {\n    assert('Cannot pass non-markerable section to `changeSectionTagName`', section.isMarkerable)\n\n    if (isListSectionTagName(newTagName)) {\n      return this._changeSectionToListItem(section, newTagName)\n    } else if (isListItem(section)) {\n      return this._changeSectionFromListItem(section, newTagName)\n    } else {\n      section.tagName = newTagName\n      this._markDirty(section)\n      return section\n    }\n  }\n\n  /**\n   * Splits the item at the position given.\n   * If the position is at the start or end of the item, the pre- or post-item\n   * will contain a single empty (\"\") marker.\n   * @param {ListItem} item\n   * @param {Position} position\n   * @return {Array} the pre-item and post-item on either side of the split\n   * @private\n   */\n  _splitListItem(item: ListItem, position: Position): [ListItem, ListItem] {\n    let { section, offset } = position\n    assert('Cannot split list item at position that does not include item', item === section)\n\n    item.splitMarkerAtOffset(offset)\n    let prevMarker = item.markerBeforeOffset(offset)\n    let preItem = this.builder.createListItem(),\n      postItem = this.builder.createListItem()\n\n    let currentItem = preItem\n    item.markers.forEach(marker => {\n      currentItem.markers.append(marker.clone())\n      if (marker === prevMarker) {\n        currentItem = postItem\n      }\n    })\n    this._replaceSection(item, [preItem, postItem])\n    return [preItem, postItem]\n  }\n\n  /**\n   * Splits the list at the position given.\n   * @return {Array} pre-split list and post-split list, either of which could\n   * be blank (0-item list) if the position is at the start or end of the list.\n   *\n   * Note: Contiguous list sections will be joined in the before_complete queue\n   * of the postEditor.\n   *\n   * @private\n   */\n  _splitListAtPosition(list: ListSection, position: Position): [ListSection, ListSection] {\n    assert('Cannot split list at position not in list', position.section!.parent === list)\n\n    let positionIsMiddle = !position.isHead() && !position.isTail()\n    if (positionIsMiddle) {\n      let item = position.section! as ListItem\n      let [pre] = this._splitListItem(item, position)\n      position = pre.tailPosition()\n    }\n\n    let preList = this.builder.createListSection(list.tagName)\n    let postList = this.builder.createListSection(list.tagName)\n\n    let preItem = position.section\n    let currentList = preList\n    list.items.forEach(item => {\n      // If this item matches the start item and the position is at its start,\n      // it should be appended to the postList instead of the preList\n      if (item === preItem && position.isEqual(item.headPosition())) {\n        currentList = postList\n      }\n      currentList.items.append(item.clone())\n      // If we just appended the preItem, append the remaining items to the postList\n      if (item === preItem) {\n        currentList = postList\n      }\n    })\n\n    this._replaceSection(list, [preList, postList])\n    return [preList, postList]\n  }\n\n  /**\n   * @return Array of [prev, mid, next] lists. `prev` and `next` can\n   *         be blank, depending on the position of `item`. `mid` will always\n   *         be a 1-item list containing `item`. `prev` and `next` will be\n   *         removed in the before_complete queue if they are blank\n   *         (and still attached).\n   *\n   * @private\n   */\n  _splitListAtItem(list: ListSection, item: ListItem) {\n    let next = list\n    let prev = this.builder.createListSection(next.tagName, [], next.attributes)\n    let mid = this.builder.createListSection(next.tagName)\n\n    let addToPrev = true\n    // must turn the LinkedList into an array so that we can remove items\n    // as we iterate through it\n    let items = next.items.toArray()\n    items.forEach(i => {\n      let listToAppend: ListSection\n      if (i === item) {\n        addToPrev = false\n        listToAppend = mid\n      } else if (addToPrev) {\n        listToAppend = prev\n      } else {\n        return // break after iterating prev and mid parts of the list\n      }\n      listToAppend.join(i)\n      this.removeSection(i)\n    })\n    let found = !addToPrev\n    assert('Cannot split list at item that is not present in the list', found)\n\n    let collection = this.editor.post.sections\n    this.insertSectionBefore(collection, mid, next)\n    this.insertSectionBefore(collection, prev, mid)\n\n    // Remove possibly blank prev/next lists\n    this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => {\n      ;[prev, next].forEach(_list => {\n        let isAttached = !!_list._parent\n        if (_list.isBlank && isAttached) {\n          this.removeSection(_list)\n        }\n      })\n    })\n\n    return [prev, mid, next]\n  }\n\n  _changeSectionFromListItem(section: Section, newTagName: string) {\n    assertType<ListItem>('Must pass list item to `_changeSectionFromListItem`', section, isListItem(section))\n\n    let listSection = section.parent as ListSection\n    let markupSection = this.builder.createMarkupSection(newTagName)\n    markupSection.join(section)\n\n    let [, mid] = this._splitListAtItem(listSection, section)\n    this.replaceSection(mid, markupSection)\n    return markupSection\n  }\n\n  _changeSectionToListItem(section: ListSection | Markerable, newTagName: string) {\n    let isAlreadyCorrectListItem =\n      section.isListItem && ((section.parent as unknown) as TagNameable).tagName === newTagName\n\n    if (isAlreadyCorrectListItem) {\n      return section\n    }\n\n    let listSection = this.builder.createListSection(newTagName)\n    listSection.join(section)\n\n    let sectionToReplace: Section\n    if (isListItem(section)) {\n      let [, mid] = this._splitListAtItem(section.parent, section)\n      sectionToReplace = mid\n    } else {\n      sectionToReplace = section\n    }\n    this.replaceSection(sectionToReplace, listSection)\n    return listSection\n  }\n\n  /**\n   * Insert a given section before another one, updating the post abstract\n   * and the rendered UI.\n   *\n   * Usage:\n   * ```\n   *     let markerRange = editor.range;\n   *     let sectionWithCursor = markerRange.headMarker.section;\n   *     let section = editor.builder.createCardSection('my-image');\n   *     let collection = sectionWithCursor.parent.sections;\n   *     editor.run((postEditor) => {\n   *       postEditor.insertSectionBefore(collection, section, sectionWithCursor);\n   *     });\n   * ```\n   * @param {LinkedList} collection The list of sections to insert into\n   * @param {Object} section The new section\n   * @param {Object} beforeSection Optional The section \"before\" is relative to,\n   *        if falsy the new section will be appended to the collection\n   * @public\n   */\n  insertSectionBefore(\n    collection: LinkedList<Section> | LinkedList<Cloneable<Section>>,\n    section: Section,\n    beforeSection?: Option<Section>\n  ) {\n    ;(collection as LinkedList<Section>).insertBefore(section, beforeSection)\n    this._markDirty(section.parent)\n  }\n\n  /**\n   * Insert the given section after the current active section, or, if no\n   * section is active, at the end of the document.\n   * @param {Section} section\n   * @public\n   */\n  insertSection(section: Section) {\n    const activeSection = this.editor.activeSection\n    const nextSection = activeSection && activeSection.next\n\n    const collection = (this.editor.post.sections as unknown) as LinkedList<Section>\n    this.insertSectionBefore(collection, section, nextSection)\n  }\n\n  /**\n   * Insert the given section at the end of the document.\n   * @param {Section} section\n   * @public\n   */\n  insertSectionAtEnd(section: Section) {\n    this.insertSectionBefore(this.editor.post.sections, section, null)\n  }\n\n  /**\n   * Insert the `post` at the given position in the editor's post.\n   * @param {Position} position\n   * @param {Post} post\n   * @private\n   */\n  insertPost(position: Position, newPost: Post) {\n    let post = this.editor.post\n    let inserter = new PostInserter(this, post)\n    let nextPosition = inserter.insert(position, newPost)\n    return nextPosition\n  }\n\n  /**\n   * Remove a given section from the post abstract and the rendered UI.\n   *\n   * Usage:\n   * ```\n   *     let { range } = editor;\n   *     let sectionWithCursor = range.head.section;\n   *     editor.run((postEditor) => {\n   *       postEditor.removeSection(sectionWithCursor);\n   *     });\n   * ```\n   * @param {Object} section The section to remove\n   * @public\n   */\n  removeSection(section: Section) {\n    let parent = section.parent\n\n    assertType<HasChildSections>('expected section to have child sections', parent, hasChildSections(parent))\n\n    this._scheduleForRemoval(section)\n    parent.sections.remove(section)\n\n    if (isListSection(parent)) {\n      this._scheduleListRemovalIfEmpty(parent)\n    }\n  }\n\n  removeAllSections() {\n    this.editor.post.sections.toArray().forEach(section => {\n      this.removeSection(section)\n    })\n  }\n\n  migrateSectionsFromPost(post: Post) {\n    post.sections.toArray().forEach(section => {\n      post.sections.remove(section)\n      this.insertSectionBefore(this.editor.post.sections, section, null)\n    })\n  }\n\n  _scheduleListRemovalIfEmpty(listSection: ListSection) {\n    this.addCallback(CALLBACK_QUEUES.BEFORE_COMPLETE, () => {\n      // if the list is attached and blank after we do other rendering stuff,\n      // remove it\n      let isAttached = !!listSection._parent\n      if (isAttached && listSection.isBlank) {\n        this.removeSection(listSection)\n      }\n    })\n  }\n\n  /**\n   * A method for adding work the deferred queue\n   *\n   * @param {Function} callback to run during completion\n   * @param {Boolean} [once=false] Whether to only schedule the callback once.\n   * @public\n   */\n  schedule(callback: LifecycleCallback, once: boolean = false) {\n    assert('Work can only be scheduled before a post edit has completed', !this._didComplete)\n    if (once) {\n      this.addCallbackOnce(CALLBACK_QUEUES.COMPLETE, callback)\n    } else {\n      this.addCallback(CALLBACK_QUEUES.COMPLETE, callback)\n    }\n  }\n\n  /**\n   * A method for adding work the deferred queue. The callback will only\n   * be added to the queue once, even if `scheduleOnce` is called multiple times.\n   * The function cannot be an anonymous function.\n   *\n   * @param {Function} callback to run during completion\n   * @public\n   */\n  scheduleOnce(callback: LifecycleCallback) {\n    this.schedule(callback, true)\n  }\n\n  /**\n   * Add a rerender job to the queue\n   *\n   * @public\n   */\n  scheduleRerender() {\n    this.scheduleOnce(this._rerender)\n  }\n\n  /**\n   * Schedule a notification that the post has been changed.\n   * The notification will result in the editor firing its `postDidChange`\n   * hook after the postEditor completes its work (at the end of {@link Editor#run}).\n   *\n   * @public\n   */\n  scheduleDidUpdate() {\n    this.scheduleOnce(this._postDidChange)\n  }\n\n  scheduleAfterRender(callback: LifecycleCallback, once = false) {\n    if (once) {\n      this.addCallbackOnce(CALLBACK_QUEUES.AFTER_COMPLETE, callback)\n    } else {\n      this.addCallback(CALLBACK_QUEUES.AFTER_COMPLETE, callback)\n    }\n  }\n\n  /**\n   * Flush any work on the queue. {@link Editor#run} calls this method; it\n   * should not be called directly.\n   *\n   * @private\n   */\n  complete() {\n    assert('Post editing can only be completed once', !this._didComplete)\n\n    this.runCallbacks(CALLBACK_QUEUES.BEFORE_COMPLETE)\n    this._didComplete = true\n    this.runCallbacks(CALLBACK_QUEUES.COMPLETE)\n    this.runCallbacks(CALLBACK_QUEUES.AFTER_COMPLETE)\n  }\n\n  undoLastChange() {\n    this.editor._editHistory.stepBackward(this)\n  }\n\n  redoLastChange() {\n    this.editor._editHistory.stepForward(this)\n  }\n\n  cancelSnapshot() {\n    this._shouldCancelSnapshot = true\n  }\n}\n","const placeholderImageSrc =\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAMFBMVEXp7vG6vsHm6+63u77Hy868wMPe4+bO09bh5unr8fTR1djAxMfM0NPX3N/c4eTBxcjXRf5TAAACh0lEQVR4nO3b6ZKqMBSFUSQMYZL3f9tbBq/NEEDiqUqOfusn1ZXKbjcQlGQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACC6RkbsGHuabChEtHmiGYfS3EQYM+Sxw/gMQvmcNnYaj6oTDHi73WPn2eqnj9B8zo3TJXcq5uNjXmVff86VwSR3JtryMa1BYqi7S1hJDCVpSigyLcGhJJEwzlCSNtPKrbVhVwsdCfOhH7uuaG3ARV9DwsaOzxt3N1yPqCHhvXytTUz92VDpmE/LLhZwl++R6Sds6sUa/PL6K/2E2fIhw1xdRKefsFolrPc+xNx/N0k/4fpBsdhL2HfeiN+TsDCms8dDpeRyS3P3QDl6Iqaf8L0rTf+80m6Lmn7Ct+4Wxf+/2RY1/YRv3PHz/u+fsCmqgoTnq7Z+8SGviqoh4dnKu1ieqauiakh4/PQ0r6ivqDoSHj0B97eNRVG1JNxV+L4bnxdVecJtRTdFVZ7QU9F1UXUn9FZ0VVRlCav5ob2KLouqKmFjy676u2HsVnRRVFUJq3J+8KCi86IqSthMvyl209Hjijqm3RsqAZ5pNfa5PJ2KelJRjQmr1/r7cfy0ouoSNvOfvbvhvKLaEr4qOin9kTQnrN7LpDZhE/Zmhp6Eq4p+YcKgiipKGFhRRQkDK6ooYfgLbiSMioQkJGF8P5XwHv4O+7AaKiXzaeXh1kMl5AffTUxiKEm/krD94BR8Gdxl1fceSlR58ZhXKbEpyD2amNiBtmrJLTMHL1LF8/rpXkSZXEmz8K8uvAFFNm6Iq0aBLUFOmeCuJ6exrcCmoLpN7kYx891bSAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgh/wDdr8peyRHLogAAAAASUVORK5CYII='\n\nexport default placeholderImageSrc\n","import placeholderImageSrc from '../utils/placeholder-image-src'\nimport { CardData } from '../models/card-node'\n\ninterface ImagePayload {\n  src?: string\n}\n\nexport default {\n  name: 'image',\n  type: 'dom',\n\n  render({ payload }: { payload: ImagePayload }) {\n    let img = document.createElement('img')\n    img.src = payload.src || placeholderImageSrc\n    return img\n  },\n} as CardData\n","import {\n  MobiledocMarkerType,\n  MobiledocV0_2,\n  MobiledocSection,\n  MobiledocMarker,\n  MobiledocCardSection,\n  MobiledocImageSection,\n  MobiledocMarkupSection,\n  MobiledocListSection,\n} from '../../renderers/mobiledoc/0-2'\nimport { MobiledocSectionKind } from '../../renderers/mobiledoc/constants'\nimport { kvArrayToObject, filter, ForEachable } from '../../utils/array-utils'\nimport assert from '../../utils/assert'\nimport PostNodeBuilder from '../../models/post-node-builder'\nimport Post from '../../models/post'\nimport Markup from '../../models/markup'\nimport ListSection from '../../models/list-section'\nimport Markerable from '../../models/_markerable'\n\n/*\n * Parses from mobiledoc -> post\n */\nexport default class MobiledocParser {\n  builder: PostNodeBuilder\n  markups!: Markup[]\n  markerTypes!: Markup[]\n\n  constructor(builder: PostNodeBuilder) {\n    this.builder = builder\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections: sectionData }: MobiledocV0_2): Post {\n    try {\n      const markerTypes = sectionData[0]\n      const sections = sectionData[1]\n\n      const post = this.builder.createPost()\n\n      this.markups = []\n      this.markerTypes = this.parseMarkerTypes(markerTypes)\n      this.parseSections(sections, post)\n\n      return post\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false)\n    }\n  }\n\n  parseMarkerTypes(markerTypes: MobiledocMarkerType[]) {\n    return markerTypes.map(markerType => this.parseMarkerType(markerType))\n  }\n\n  parseMarkerType([tagName, attributesArray]: MobiledocMarkerType) {\n    const attributesObject = kvArrayToObject(attributesArray || [])\n    return this.builder.createMarkup(tagName, attributesObject)\n  }\n\n  parseSections(sections: ForEachable<MobiledocSection>, post: Post) {\n    sections.forEach(section => this.parseSection(section, post))\n  }\n\n  parseSection(section: MobiledocSection, post: Post) {\n    switch (section[0]) {\n      case MobiledocSectionKind.MARKUP:\n        this.parseMarkupSection(section, post)\n        break\n      case MobiledocSectionKind.IMAGE:\n        this.parseImageSection(section, post)\n        break\n      case MobiledocSectionKind.CARD:\n        this.parseCardSection(section, post)\n        break\n      case MobiledocSectionKind.LIST:\n        this.parseListSection(section, post)\n        break\n      default:\n        assert(`Unexpected section type ${section[0]}`, false)\n    }\n  }\n\n  parseCardSection([, name, payload]: MobiledocCardSection, post: Post) {\n    const section = this.builder.createCardSection(name, payload)\n    post.sections.append(section)\n  }\n\n  parseImageSection([, src]: MobiledocImageSection, post: Post) {\n    const section = this.builder.createImageSection(src)\n    post.sections.append(section)\n  }\n\n  parseMarkupSection([, tagName, markers]: MobiledocMarkupSection, post: Post) {\n    const section = this.builder.createMarkupSection(tagName.toLowerCase() === 'pull-quote' ? 'aside' : tagName)\n    post.sections.append(section)\n    this.parseMarkers(markers, section)\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m)\n    })\n  }\n\n  parseListSection([, tagName, items]: MobiledocListSection, post: Post) {\n    const section = this.builder.createListSection(tagName)\n    post.sections.append(section)\n    this.parseListItems(items, section)\n  }\n\n  parseListItems(items: MobiledocMarker[][], section: ListSection) {\n    items.forEach(i => this.parseListItem(i, section))\n  }\n\n  parseListItem(markers: MobiledocMarker[], section: ListSection) {\n    const item = this.builder.createListItem()\n    this.parseMarkers(markers, item)\n    section.items.append(item)\n  }\n\n  parseMarkers(markers: MobiledocMarker[], parent: Markerable) {\n    markers.forEach(m => this.parseMarker(m, parent))\n  }\n\n  parseMarker([markerTypeIndexes, closeCount, value]: [number[], number, string], parent: Markerable) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index])\n    })\n    const marker = this.builder.createMarker(value, this.markups.slice())\n    parent.markers.append(marker)\n    this.markups = this.markups.slice(0, this.markups.length - closeCount)\n  }\n}\n","import {\n  MobiledocMarkerType,\n  MobiledocMarkupSection,\n  MobiledocSection,\n  MobiledocCard,\n  MobiledocAtom,\n  MobiledocV0_3,\n  MobiledocMarker,\n  MobiledocCardSection,\n  MobiledocImageSection,\n  MobiledocListSection,\n} from '../../renderers/mobiledoc/0-3'\nimport { kvArrayToObject, filter, ForEachable } from '../../utils/array-utils'\nimport assert from '../../utils/assert'\nimport PostNodeBuilder from '../../models/post-node-builder'\nimport Markup from '../../models/markup'\nimport Post from '../../models/post'\nimport { MobiledocSectionKind, MobiledocMarkerKind } from '../../renderers/mobiledoc/constants'\nimport ListSection from '../../models/list-section'\nimport Markerable from '../../models/_markerable'\n\n/*\n * Parses from mobiledoc -> post\n */\nexport default class MobiledocParser {\n  builder: PostNodeBuilder\n  markups!: Markup[]\n  markerTypes!: Markup[]\n  cardTypes!: MobiledocCard[]\n  atomTypes!: MobiledocAtom[]\n\n  constructor(builder: PostNodeBuilder) {\n    this.builder = builder\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }: MobiledocV0_3): Post {\n    try {\n      const post = this.builder.createPost()\n\n      this.markups = []\n      this.markerTypes = this.parseMarkerTypes(markerTypes)\n      this.cardTypes = this.parseCardTypes(cardTypes)\n      this.atomTypes = this.parseAtomTypes(atomTypes)\n      this.parseSections(sections, post)\n\n      return post\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false)\n    }\n  }\n\n  parseMarkerTypes(markerTypes: MobiledocMarkerType[]) {\n    return markerTypes.map(markerType => this.parseMarkerType(markerType))\n  }\n\n  parseMarkerType([tagName, attributesArray]: MobiledocMarkerType) {\n    const attributesObject = kvArrayToObject(attributesArray || [])\n    return this.builder.createMarkup(tagName, attributesObject)\n  }\n\n  parseCardTypes(cardTypes: MobiledocCard[]) {\n    return cardTypes.map(cardType => this.parseCardType(cardType))\n  }\n\n  parseCardType([cardName, cardPayload]: MobiledocCard): MobiledocCard {\n    return [cardName, cardPayload]\n  }\n\n  parseAtomTypes(atomTypes: MobiledocAtom[]) {\n    return atomTypes.map(atomType => this.parseAtomType(atomType))\n  }\n\n  parseAtomType([atomName, atomValue, atomPayload]: MobiledocAtom): MobiledocAtom {\n    return [atomName, atomValue, atomPayload]\n  }\n\n  parseSections(sections: ForEachable<MobiledocSection>, post: Post) {\n    sections.forEach(section => this.parseSection(section, post))\n  }\n\n  parseSection(section: MobiledocSection, post: Post) {\n    switch (section[0]) {\n      case MobiledocSectionKind.MARKUP:\n        this.parseMarkupSection(section, post)\n        break\n      case MobiledocSectionKind.IMAGE:\n        this.parseImageSection(section, post)\n        break\n      case MobiledocSectionKind.CARD:\n        this.parseCardSection(section, post)\n        break\n      case MobiledocSectionKind.LIST:\n        this.parseListSection(section, post)\n        break\n      default:\n        assert(`Unexpected section type ${section[0]}`, false)\n    }\n  }\n\n  getAtomTypeFromIndex(index: number) {\n    const atomType = this.atomTypes[index]\n    assert(`No atom definition found at index ${index}`, !!atomType)\n    return atomType\n  }\n\n  getCardTypeFromIndex(index: number) {\n    const cardType = this.cardTypes[index]\n    assert(`No card definition found at index ${index}`, !!cardType)\n    return cardType\n  }\n\n  parseCardSection([, cardIndex]: MobiledocCardSection, post: Post) {\n    const [name, payload] = this.getCardTypeFromIndex(cardIndex)\n    const section = this.builder.createCardSection(name, payload)\n    post.sections.append(section)\n  }\n\n  parseImageSection([, src]: MobiledocImageSection, post: Post) {\n    const section = this.builder.createImageSection(src)\n    post.sections.append(section)\n  }\n\n  parseMarkupSection([, tagName, markers]: MobiledocMarkupSection, post: Post) {\n    const section = this.builder.createMarkupSection(tagName.toLowerCase() === 'pull-quote' ? 'aside' : tagName)\n    post.sections.append(section)\n    this.parseMarkers(markers, section)\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m)\n    })\n  }\n\n  parseListSection([, tagName, items]: MobiledocListSection, post: Post) {\n    const section = this.builder.createListSection(tagName)\n    post.sections.append(section)\n    this.parseListItems(items, section)\n  }\n\n  parseListItems(items: MobiledocMarker[][], section: ListSection) {\n    items.forEach(i => this.parseListItem(i, section))\n  }\n\n  parseListItem(markers: MobiledocMarker[], section: ListSection) {\n    const item = this.builder.createListItem()\n    this.parseMarkers(markers, item)\n    section.items.append(item)\n  }\n\n  parseMarkers(markers: MobiledocMarker[], parent: Markerable) {\n    markers.forEach(m => this.parseMarker(m, parent))\n  }\n\n  parseMarker([type, markerTypeIndexes, closeCount, value]: MobiledocMarker, parent: Markerable) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index])\n    })\n\n    const marker = this.buildMarkerType(type, value)\n    parent.markers.append(marker)\n\n    this.markups = this.markups.slice(0, this.markups.length - closeCount)\n  }\n\n  buildMarkerType(type: MobiledocMarkerKind, value: string | number) {\n    switch (type) {\n      case MobiledocMarkerKind.MARKUP:\n        return this.builder.createMarker(value as string, this.markups.slice())\n      case MobiledocMarkerKind.ATOM: {\n        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value as number)\n        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice())\n      }\n      default:\n        assert(`Unexpected marker type ${type}`, false)\n    }\n  }\n}\n","import {\n  MobiledocMarkerType,\n  MobiledocMarkupSection,\n  MobiledocSection,\n  MobiledocCard,\n  MobiledocAtom,\n  MobiledocCardSection,\n  MobiledocImageSection,\n  MobiledocListSection,\n  MobiledocMarker,\n} from '../../renderers/mobiledoc/0-3'\nimport { kvArrayToObject, filter, ForEachable } from '../../utils/array-utils'\nimport assert from '../../utils/assert'\nimport { MobiledocMarkerKind, MobiledocSectionKind } from '../../renderers/mobiledoc/constants'\nimport PostNodeBuilder from '../../models/post-node-builder'\nimport { MobiledocV0_3_1 } from '../../renderers/mobiledoc/0-3-1'\nimport Markup from '../../models/markup'\nimport Post from '../../models/post'\nimport ListSection from '../../models/list-section'\nimport Markerable from '../../models/_markerable'\n\n/*\n * Parses from mobiledoc -> post\n */\nexport default class MobiledocParser {\n  builder: PostNodeBuilder\n  markups!: Markup[]\n  markerTypes!: Markup[]\n  cardTypes!: MobiledocCard[]\n  atomTypes!: MobiledocAtom[]\n\n  constructor(builder: PostNodeBuilder) {\n    this.builder = builder\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }: MobiledocV0_3_1): Post {\n    try {\n      const post = this.builder.createPost()\n\n      this.markups = []\n      this.markerTypes = this.parseMarkerTypes(markerTypes)\n      this.cardTypes = this.parseCardTypes(cardTypes)\n      this.atomTypes = this.parseAtomTypes(atomTypes)\n      this.parseSections(sections, post)\n\n      return post\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false)\n    }\n  }\n\n  parseMarkerTypes(markerTypes: MobiledocMarkerType[]) {\n    return markerTypes.map(markerType => this.parseMarkerType(markerType))\n  }\n\n  parseMarkerType([tagName, attributesArray]: MobiledocMarkerType) {\n    const attributesObject = kvArrayToObject(attributesArray || [])\n    return this.builder.createMarkup(tagName, attributesObject)\n  }\n\n  parseCardTypes(cardTypes: MobiledocCard[]) {\n    return cardTypes.map(cardType => this.parseCardType(cardType))\n  }\n\n  parseCardType([cardName, cardPayload]: MobiledocCard): MobiledocCard {\n    return [cardName, cardPayload]\n  }\n\n  parseAtomTypes(atomTypes: MobiledocAtom[]) {\n    return atomTypes.map(atomType => this.parseAtomType(atomType))\n  }\n\n  parseAtomType([atomName, atomValue, atomPayload]: MobiledocAtom): MobiledocAtom {\n    return [atomName, atomValue, atomPayload]\n  }\n\n  parseSections(sections: ForEachable<MobiledocSection>, post: Post) {\n    sections.forEach(section => this.parseSection(section, post))\n  }\n\n  parseSection(section: MobiledocSection, post: Post) {\n    switch (section[0]) {\n      case MobiledocSectionKind.MARKUP:\n        this.parseMarkupSection(section, post)\n        break\n      case MobiledocSectionKind.IMAGE:\n        this.parseImageSection(section, post)\n        break\n      case MobiledocSectionKind.CARD:\n        this.parseCardSection(section, post)\n        break\n      case MobiledocSectionKind.LIST:\n        this.parseListSection(section, post)\n        break\n      default:\n        assert(`Unexpected section type ${section[0]}`, false)\n    }\n  }\n\n  getAtomTypeFromIndex(index: number) {\n    const atomType = this.atomTypes[index]\n    assert(`No atom definition found at index ${index}`, !!atomType)\n    return atomType\n  }\n\n  getCardTypeFromIndex(index: number) {\n    const cardType = this.cardTypes[index]\n    assert(`No card definition found at index ${index}`, !!cardType)\n    return cardType\n  }\n\n  parseCardSection([, cardIndex]: MobiledocCardSection, post: Post) {\n    const [name, payload] = this.getCardTypeFromIndex(cardIndex)\n    const section = this.builder.createCardSection(name, payload)\n    post.sections.append(section)\n  }\n\n  parseImageSection([, src]: MobiledocImageSection, post: Post) {\n    const section = this.builder.createImageSection(src)\n    post.sections.append(section)\n  }\n\n  parseMarkupSection([, tagName, markers]: MobiledocMarkupSection, post: Post) {\n    const section = this.builder.createMarkupSection(tagName)\n    post.sections.append(section)\n    this.parseMarkers(markers, section)\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m)\n    })\n  }\n\n  parseListSection([, tagName, items]: MobiledocListSection, post: Post) {\n    const section = this.builder.createListSection(tagName)\n    post.sections.append(section)\n    this.parseListItems(items, section)\n  }\n\n  parseListItems(items: MobiledocMarker[][], section: ListSection) {\n    items.forEach(i => this.parseListItem(i, section))\n  }\n\n  parseListItem(markers: MobiledocMarker[], section: ListSection) {\n    const item = this.builder.createListItem()\n    this.parseMarkers(markers, item)\n    section.items.append(item)\n  }\n\n  parseMarkers(markers: MobiledocMarker[], parent: Markerable) {\n    markers.forEach(m => this.parseMarker(m, parent))\n  }\n\n  parseMarker([type, markerTypeIndexes, closeCount, value]: MobiledocMarker, parent: Markerable) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index])\n    })\n\n    const marker = this.buildMarkerType(type, value)\n    parent.markers.append(marker)\n\n    this.markups = this.markups.slice(0, this.markups.length - closeCount)\n  }\n\n  buildMarkerType(type: MobiledocMarkerKind, value: string | number) {\n    switch (type) {\n      case MobiledocMarkerKind.MARKUP:\n        return this.builder.createMarker(value as string, this.markups.slice())\n      case MobiledocMarkerKind.ATOM: {\n        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value as number)\n        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice())\n      }\n      default:\n        assert(`Unexpected marker type ${type}`, false)\n    }\n  }\n}\n","import {\n  MobiledocMarkerType,\n  MobiledocCard,\n  MobiledocAtom,\n  MobiledocMarker,\n  MobiledocCardSection,\n  MobiledocImageSection,\n  MobiledocMarkupSection,\n  MobiledocListSection,\n} from '../../renderers/mobiledoc/0-3'\n\nimport { kvArrayToObject, filter, ForEachable } from '../../utils/array-utils'\nimport assert from '../../utils/assert'\nimport { entries } from '../../utils/object-utils'\nimport Markup from '../../models/markup'\nimport PostNodeBuilder from '../../models/post-node-builder'\nimport {\n  MobiledocV0_3_2,\n  MobiledocAttributedMarkupSection,\n  MobiledocAttributedListSection,\n  MobiledocAttributedSection,\n} from '../../renderers/mobiledoc/0-3-2'\nimport Post from '../../models/post'\nimport { MobiledocSectionKind, MobiledocMarkerKind } from '../../renderers/mobiledoc/constants'\nimport ListSection from '../../models/list-section'\nimport Markerable from '../../models/_markerable'\n\n/*\n * Parses from mobiledoc -> post\n */\nexport default class MobiledocParser {\n  builder: PostNodeBuilder\n  markups!: Markup[]\n  markerTypes!: Markup[]\n  cardTypes!: MobiledocCard[]\n  atomTypes!: MobiledocAtom[]\n\n  constructor(builder: PostNodeBuilder) {\n    this.builder = builder\n  }\n\n  /**\n   * @param {Mobiledoc}\n   * @return {Post}\n   */\n  parse({ sections, markups: markerTypes, cards: cardTypes, atoms: atomTypes }: MobiledocV0_3_2): Post {\n    try {\n      const post = this.builder.createPost()\n\n      this.markups = []\n      this.markerTypes = this.parseMarkerTypes(markerTypes)\n      this.cardTypes = this.parseCardTypes(cardTypes)\n      this.atomTypes = this.parseAtomTypes(atomTypes)\n      this.parseSections(sections, post)\n\n      return post\n    } catch (e) {\n      assert(`Unable to parse mobiledoc: ${e.message}`, false)\n    }\n  }\n\n  parseMarkerTypes(markerTypes: MobiledocMarkerType[]) {\n    return markerTypes.map(markerType => this.parseMarkerType(markerType))\n  }\n\n  parseMarkerType([tagName, attributesArray]: MobiledocMarkerType) {\n    const attributesObject = kvArrayToObject(attributesArray || [])\n    return this.builder.createMarkup(tagName, attributesObject)\n  }\n\n  parseCardTypes(cardTypes: MobiledocCard[]) {\n    return cardTypes.map(cardType => this.parseCardType(cardType))\n  }\n\n  parseCardType([cardName, cardPayload]: MobiledocCard): MobiledocCard {\n    return [cardName, cardPayload]\n  }\n\n  parseAtomTypes(atomTypes: MobiledocAtom[]) {\n    return atomTypes.map(atomType => this.parseAtomType(atomType))\n  }\n\n  parseAtomType([atomName, atomValue, atomPayload]: MobiledocAtom): MobiledocAtom {\n    return [atomName, atomValue, atomPayload]\n  }\n\n  parseSections(sections: ForEachable<MobiledocAttributedSection>, post: Post) {\n    sections.forEach(section => this.parseSection(section, post))\n  }\n\n  parseSection(section: MobiledocAttributedSection, post: Post) {\n    switch (section[0]) {\n      case MobiledocSectionKind.MARKUP:\n        this.parseMarkupSection(section, post)\n        break\n      case MobiledocSectionKind.IMAGE:\n        this.parseImageSection(section, post)\n        break\n      case MobiledocSectionKind.CARD:\n        this.parseCardSection(section, post)\n        break\n      case MobiledocSectionKind.LIST:\n        this.parseListSection(section, post)\n        break\n      default:\n        assert(`Unexpected section type ${section[0]}`, false)\n    }\n  }\n\n  getAtomTypeFromIndex(index: number) {\n    const atomType = this.atomTypes[index]\n    assert(`No atom definition found at index ${index}`, !!atomType)\n    return atomType\n  }\n\n  getCardTypeFromIndex(index: number) {\n    const cardType = this.cardTypes[index]\n    assert(`No card definition found at index ${index}`, !!cardType)\n    return cardType\n  }\n\n  parseCardSection([, cardIndex]: MobiledocCardSection, post: Post) {\n    const [name, payload] = this.getCardTypeFromIndex(cardIndex)\n    const section = this.builder.createCardSection(name, payload)\n    post.sections.append(section)\n  }\n\n  parseImageSection([, src]: MobiledocImageSection, post: Post) {\n    const section = this.builder.createImageSection(src)\n    post.sections.append(section)\n  }\n\n  parseMarkupSection(\n    [, tagName, markers, attributesArray]: MobiledocMarkupSection | MobiledocAttributedMarkupSection,\n    post: Post\n  ) {\n    const section = this.builder.createMarkupSection(tagName)\n    post.sections.append(section)\n    if (attributesArray) {\n      entries(kvArrayToObject(attributesArray)).forEach(([key, value]) => {\n        section.setAttribute(key, value)\n      })\n    }\n    this.parseMarkers(markers, section)\n    // Strip blank markers after they have been created. This ensures any\n    // markup they include has been correctly populated.\n    filter(section.markers, m => m.isBlank).forEach(m => {\n      section.markers.remove(m)\n    })\n  }\n\n  parseListSection(\n    [, tagName, items, attributesArray]: MobiledocListSection | MobiledocAttributedListSection,\n    post: Post\n  ) {\n    const section = this.builder.createListSection(tagName)\n    post.sections.append(section)\n    if (attributesArray) {\n      entries(kvArrayToObject(attributesArray)).forEach(([key, value]) => {\n        section.setAttribute(key, value)\n      })\n    }\n    this.parseListItems(items, section)\n  }\n\n  parseListItems(items: MobiledocMarker[][], section: ListSection) {\n    items.forEach(i => this.parseListItem(i, section))\n  }\n\n  parseListItem(markers: MobiledocMarker[], section: ListSection) {\n    const item = this.builder.createListItem()\n    this.parseMarkers(markers, item)\n    section.items.append(item)\n  }\n\n  parseMarkers(markers: MobiledocMarker[], parent: Markerable) {\n    markers.forEach(m => this.parseMarker(m, parent))\n  }\n\n  parseMarker([type, markerTypeIndexes, closeCount, value]: MobiledocMarker, parent: Markerable) {\n    markerTypeIndexes.forEach(index => {\n      this.markups.push(this.markerTypes[index])\n    })\n\n    const marker = this.buildMarkerType(type, value)\n    parent.markers.append(marker)\n\n    this.markups = this.markups.slice(0, this.markups.length - closeCount)\n  }\n\n  buildMarkerType(type: MobiledocMarkerKind, value: string | number) {\n    switch (type) {\n      case MobiledocMarkerKind.MARKUP:\n        return this.builder.createMarker(value as string, this.markups.slice())\n      case MobiledocMarkerKind.ATOM: {\n        const [atomName, atomValue, atomPayload] = this.getAtomTypeFromIndex(value as number)\n        return this.builder.createAtom(atomName, atomValue, atomPayload, this.markups.slice())\n      }\n      default:\n        assert(`Unexpected marker type ${type}`, false)\n    }\n  }\n}\n","import { forEach, ForEachable, HasLength } from './array-utils'\nimport { assertExistsIn } from './assert'\nimport { Type } from '../models/types'\nimport Post from '../models/post'\nimport Image from '../models/image'\nimport ListSection from '../models/list-section'\nimport MarkupSection from '../models/markup-section'\nimport ListItem from '../models/list-item'\nimport Card from '../models/card'\nimport Marker from '../models/marker'\nimport Markup from '../models/markup'\nimport Section from '../models/_section'\nimport Markuperable from './markuperable'\n\nexport type OpcodeName =\n  | 'openPost'\n  | 'openMarkupSection'\n  | 'openListSection'\n  | 'openListItem'\n  | 'openImageSection'\n  | 'openCardSection'\n  | 'openMarker'\n  | 'openAtom'\n  | 'openMarkup'\n  | 'openAtom'\nexport type Opcode = [OpcodeName, ...unknown[]]\nexport type Opcodes = Opcode[]\nexport type Compiler = { [key in OpcodeName]?: (...params: any[]) => void }\n\nexport type CompileNode = Section | Markup | Markuperable | Post\n\ninterface Visitor {\n  [Type.POST]: (node: Post, opcodes: Opcodes) => void\n  [Type.MARKUP_SECTION]: (node: MarkupSection, opcodes: Opcodes) => void\n  [Type.LIST_SECTION]: (node: ListSection, opcodes: Opcodes) => void\n  [Type.LIST_ITEM]: (node: ListItem, opcodes: Opcodes) => void\n  [Type.IMAGE_SECTION]: (node: Image, opcodes: Opcodes) => void\n  [Type.CARD]: (node: Card, opcodes: Opcodes) => void\n  [Type.MARKER]: (node: Marker, opcodes: Opcodes) => void\n  [Type.MARKUP]: (node: Markup, opcodes: Opcodes) => void\n}\n\nexport function visit(visitor: Visitor, node: CompileNode, opcodes: Opcodes) {\n  const method = node.type\n  assertExistsIn(`Cannot visit unknown type ${method}`, method, visitor)\n  visitor[method](node as any, opcodes)\n}\n\nexport function compile(compiler: Compiler, opcodes: Opcodes) {\n  for (let i = 0, l = opcodes.length; i < l; i++) {\n    let [method, ...params] = opcodes[i]\n    compiler[method]!.apply(compiler, params)\n  }\n}\n\ntype CompileNodes = ForEachable<CompileNode> & HasLength<CompileNode>\n\nexport function visitArray(visitor: Visitor, nodes: CompileNodes, opcodes: Opcodes) {\n  if (!nodes || nodes.length === 0) {\n    return\n  }\n  forEach(nodes, node => {\n    visit(visitor, node, opcodes)\n  })\n}\n","import { visit, visitArray, compile, Opcodes } from '../../utils/compiler'\nimport { objectToSortedKVArray } from '../../utils/array-utils'\nimport { Type } from '../../models/types'\nimport Post from '../../models/post'\nimport MarkupSection from '../../models/markup-section'\nimport ListSection from '../../models/list-section'\nimport ListItem from '../../models/list-item'\nimport Image from '../../models/image'\nimport Card from '../../models/card'\nimport Marker from '../../models/marker'\nimport Markup from '../../models/markup'\nimport { MobiledocSectionKind } from './constants'\n\nexport const MOBILEDOC_VERSION = '0.2.0'\n\nconst visitor = {\n  [Type.POST](node: Post, opcodes: Opcodes) {\n    opcodes.push(['openPost'])\n    visitArray(visitor, node.sections, opcodes)\n  },\n  [Type.MARKUP_SECTION](node: MarkupSection, opcodes: Opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.LIST_SECTION](node: ListSection, opcodes: Opcodes) {\n    opcodes.push(['openListSection', node.tagName])\n    visitArray(visitor, node.items, opcodes)\n  },\n  [Type.LIST_ITEM](node: ListItem, opcodes: Opcodes) {\n    opcodes.push(['openListItem'])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.IMAGE_SECTION](node: Image, opcodes: Opcodes) {\n    opcodes.push(['openImageSection', node.src])\n  },\n  [Type.CARD](node: Card, opcodes: Opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload])\n  },\n  [Type.MARKER](node: Marker, opcodes: Opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n  [Type.MARKUP](node: Markup, opcodes: Opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)])\n  },\n}\n\nexport type MobiledocMarker = [number[], number, string]\nexport type MobiledocMarkerType = [string, string[]?]\n\nexport type MobiledocMarkupSection = [MobiledocSectionKind.MARKUP, string, MobiledocMarker[]]\nexport type MobiledocListSection = [MobiledocSectionKind.LIST, string, MobiledocMarker[][]]\nexport type MobiledocImageSection = [MobiledocSectionKind.IMAGE, string]\nexport type MobiledocCardSection = [MobiledocSectionKind.CARD, string, {}]\n\nexport type MobiledocSection =\n  | MobiledocMarkupSection\n  | MobiledocListSection\n  | MobiledocImageSection\n  | MobiledocCardSection\n\nclass PostOpcodeCompiler {\n  markupMarkerIds!: number[]\n  markers!: MobiledocMarker[]\n  sections!: MobiledocSection[]\n  items!: MobiledocMarker[][]\n  markerTypes!: MobiledocMarkerType[]\n  result!: MobiledocV0_2\n\n  _markerTypeCache!: { [key: string]: number }\n\n  openMarker(closeCount: number, value: string) {\n    this.markupMarkerIds = []\n    this.markers.push([this.markupMarkerIds, closeCount, value || ''])\n  }\n\n  openMarkupSection(tagName: string) {\n    this.markers = []\n    this.sections.push([MobiledocSectionKind.MARKUP, tagName, this.markers])\n  }\n\n  openListSection(tagName: string) {\n    this.items = []\n    this.sections.push([MobiledocSectionKind.LIST, tagName, this.items])\n  }\n\n  openListItem() {\n    this.markers = []\n    this.items.push(this.markers)\n  }\n\n  openImageSection(url: string) {\n    this.sections.push([MobiledocSectionKind.IMAGE, url])\n  }\n\n  openCardSection(name: string, payload: {}) {\n    this.sections.push([MobiledocSectionKind.CARD, name, payload])\n  }\n\n  openPost() {\n    this.markerTypes = []\n    this.sections = []\n    this.result = {\n      version: MOBILEDOC_VERSION,\n      sections: [this.markerTypes, this.sections],\n    }\n  }\n\n  openMarkup(tagName: string, attributes: string[]) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes)\n    this.markupMarkerIds.push(index)\n  }\n\n  _findOrAddMarkerTypeIndex(tagName: string, attributesArray: string[]) {\n    if (!this._markerTypeCache) {\n      this._markerTypeCache = {}\n    }\n    const key = `${tagName}-${attributesArray.join('-')}`\n\n    let index = this._markerTypeCache[key]\n    if (index === undefined) {\n      let markerType: MobiledocMarkerType = [tagName]\n      if (attributesArray.length) {\n        markerType.push(attributesArray)\n      }\n      this.markerTypes.push(markerType)\n\n      index = this.markerTypes.length - 1\n      this._markerTypeCache[key] = index\n    }\n\n    return index\n  }\n}\n\nexport interface MobiledocV0_2 {\n  version: typeof MOBILEDOC_VERSION\n  sections: [MobiledocMarkerType[], MobiledocSection[]]\n}\n\n/**\n * Render from post -> mobiledoc\n */\nexport default {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post: Post): MobiledocV0_2 {\n    let opcodes: Opcodes = []\n    visit(visitor, post, opcodes)\n    let compiler = new PostOpcodeCompiler()\n    compile(compiler, opcodes)\n    return compiler.result\n  },\n}\n","import { visit, visitArray, compile, Opcodes } from '../../utils/compiler'\nimport { objectToSortedKVArray } from '../../utils/array-utils'\nimport { Type } from '../../models/types'\nimport Post from '../../models/post'\nimport MarkupSection from '../../models/markup-section'\nimport ListSection from '../../models/list-section'\nimport ListItem from '../../models/list-item'\nimport Image from '../../models/image'\nimport Card from '../../models/card'\nimport Marker from '../../models/marker'\nimport Markup from '../../models/markup'\nimport Atom from '../../models/atom'\nimport { Dict } from '../../utils/types'\nimport { MobiledocSectionKind, MobiledocMarkerKind } from './constants'\n\nexport const MOBILEDOC_VERSION = '0.3.0'\n\nconst visitor = {\n  [Type.POST](node: Post, opcodes: Opcodes) {\n    opcodes.push(['openPost'])\n    visitArray(visitor, node.sections, opcodes)\n  },\n  [Type.MARKUP_SECTION](node: MarkupSection, opcodes: Opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.LIST_SECTION](node: ListSection, opcodes: Opcodes) {\n    opcodes.push(['openListSection', node.tagName])\n    visitArray(visitor, node.items, opcodes)\n  },\n  [Type.LIST_ITEM](node: ListItem, opcodes: Opcodes) {\n    opcodes.push(['openListItem'])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.IMAGE_SECTION](node: Image, opcodes: Opcodes) {\n    opcodes.push(['openImageSection', node.src])\n  },\n  [Type.CARD](node: Card, opcodes: Opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload])\n  },\n  [Type.MARKER](node: Marker, opcodes: Opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n  [Type.MARKUP](node: Markup, opcodes: Opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)])\n  },\n  [Type.ATOM](node: Atom, opcodes: Opcodes) {\n    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n}\n\nexport type MobiledocMarkupMarker = [MobiledocMarkerKind.MARKUP, number[], number, string]\nexport type MobiledocAtomMarker = [MobiledocMarkerKind.ATOM, number[], number, number]\n\nexport type MobiledocMarker = MobiledocMarkupMarker | MobiledocAtomMarker\n\nexport type MobiledocMarkupSection = [MobiledocSectionKind.MARKUP, string, MobiledocMarker[]]\nexport type MobiledocListSection = [MobiledocSectionKind.LIST, string, MobiledocMarker[][]]\nexport type MobiledocImageSection = [MobiledocSectionKind.IMAGE, string]\nexport type MobiledocCardSection = [MobiledocSectionKind.CARD, number]\n\nexport type MobiledocSection =\n  | MobiledocMarkupSection\n  | MobiledocListSection\n  | MobiledocImageSection\n  | MobiledocCardSection\n\nexport type MobiledocAtom = [string, string, {}]\nexport type MobiledocCard = [string, {}]\nexport type MobiledocMarkerType = [string, string[]?]\n\nclass PostOpcodeCompiler {\n  markupMarkerIds!: number[]\n  markers!: MobiledocMarker[]\n  sections!: MobiledocSection[]\n  items!: MobiledocMarker[][]\n  markerTypes!: MobiledocMarkerType[]\n  atomTypes!: MobiledocAtom[]\n  cardTypes!: MobiledocCard[]\n  result!: MobiledocV0_3\n\n  _markerTypeCache!: Dict<number>\n\n  openMarker(closeCount: number, value: string) {\n    this.markupMarkerIds = []\n    this.markers.push([MobiledocMarkerKind.MARKUP, this.markupMarkerIds, closeCount, value || ''])\n  }\n\n  openAtom(closeCount: number, name: string, value: string, payload: {}) {\n    const index = this._addAtomTypeIndex(name, value, payload)\n    this.markupMarkerIds = []\n    this.markers.push([MobiledocMarkerKind.ATOM, this.markupMarkerIds, closeCount, index])\n  }\n\n  openMarkupSection(tagName: string) {\n    this.markers = []\n    this.sections.push([MobiledocSectionKind.MARKUP, tagName, this.markers])\n  }\n\n  openListSection(tagName: string) {\n    this.items = []\n    this.sections.push([MobiledocSectionKind.LIST, tagName, this.items])\n  }\n\n  openListItem() {\n    this.markers = []\n    this.items.push(this.markers)\n  }\n\n  openImageSection(url: string) {\n    this.sections.push([MobiledocSectionKind.IMAGE, url])\n  }\n\n  openCardSection(name: string, payload: {}) {\n    const index = this._addCardTypeIndex(name, payload)\n    this.sections.push([MobiledocSectionKind.CARD, index])\n  }\n\n  openPost() {\n    this.atomTypes = []\n    this.cardTypes = []\n    this.markerTypes = []\n    this.sections = []\n    this.result = {\n      version: MOBILEDOC_VERSION,\n      atoms: this.atomTypes,\n      cards: this.cardTypes,\n      markups: this.markerTypes,\n      sections: this.sections,\n    }\n  }\n\n  openMarkup(tagName: string, attributes: string[]) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes)\n    this.markupMarkerIds.push(index)\n  }\n\n  _addCardTypeIndex(cardName: string, payload: {}) {\n    let cardType: MobiledocCard = [cardName, payload]\n    this.cardTypes.push(cardType)\n    return this.cardTypes.length - 1\n  }\n\n  _addAtomTypeIndex(atomName: string, atomValue: string, payload: {}) {\n    let atomType: MobiledocAtom = [atomName, atomValue, payload]\n    this.atomTypes.push(atomType)\n    return this.atomTypes.length - 1\n  }\n\n  _findOrAddMarkerTypeIndex(tagName: string, attributesArray: string[]) {\n    if (!this._markerTypeCache) {\n      this._markerTypeCache = {}\n    }\n    const key = `${tagName}-${attributesArray.join('-')}`\n\n    let index = this._markerTypeCache[key]\n    if (index === undefined) {\n      let markerType: MobiledocMarkerType = [tagName]\n      if (attributesArray.length) {\n        markerType.push(attributesArray)\n      }\n      this.markerTypes.push(markerType)\n\n      index = this.markerTypes.length - 1\n      this._markerTypeCache[key] = index\n    }\n\n    return index\n  }\n}\n\nexport interface MobiledocV0_3 {\n  version: typeof MOBILEDOC_VERSION\n  atoms: MobiledocAtom[]\n  cards: MobiledocCard[]\n  markups: MobiledocMarkerType[]\n  sections: MobiledocSection[]\n}\n\n/**\n * Render from post -> mobiledoc\n */\nexport default {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post: Post): MobiledocV0_3 {\n    let opcodes: Opcodes = []\n    visit(visitor, post, opcodes)\n    let compiler = new PostOpcodeCompiler()\n    compile(compiler, opcodes)\n    return compiler.result\n  },\n}\n","import { visit, visitArray, compile, Opcodes } from '../../utils/compiler'\nimport { objectToSortedKVArray } from '../../utils/array-utils'\nimport { Type } from '../../models/types'\nimport Post from '../../models/post'\nimport MarkupSection from '../../models/markup-section'\nimport ListSection from '../../models/list-section'\nimport ListItem from '../../models/list-item'\nimport Image from '../../models/image'\nimport Card from '../../models/card'\nimport Marker from '../../models/marker'\nimport Markup from '../../models/markup'\nimport Atom from '../../models/atom'\nimport { Dict } from '../../utils/types'\nimport { MobiledocSectionKind, MobiledocMarkerKind } from './constants'\nimport { MobiledocMarker, MobiledocSection, MobiledocMarkerType, MobiledocAtom, MobiledocCard } from './0-3'\n\nexport const MOBILEDOC_VERSION = '0.3.1'\n\nconst visitor = {\n  [Type.POST](node: Post, opcodes: Opcodes) {\n    opcodes.push(['openPost'])\n    visitArray(visitor, node.sections, opcodes)\n  },\n  [Type.MARKUP_SECTION](node: MarkupSection, opcodes: Opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.LIST_SECTION](node: ListSection, opcodes: Opcodes) {\n    opcodes.push(['openListSection', node.tagName])\n    visitArray(visitor, node.items, opcodes)\n  },\n  [Type.LIST_ITEM](node: ListItem, opcodes: Opcodes) {\n    opcodes.push(['openListItem'])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.IMAGE_SECTION](node: Image, opcodes: Opcodes) {\n    opcodes.push(['openImageSection', node.src])\n  },\n  [Type.CARD](node: Card, opcodes: Opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload])\n  },\n  [Type.MARKER](node: Marker, opcodes: Opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n  [Type.MARKUP](node: Markup, opcodes: Opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)])\n  },\n  [Type.ATOM](node: Atom, opcodes: Opcodes) {\n    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n}\n\nclass PostOpcodeCompiler {\n  markupMarkerIds!: number[]\n  markers!: MobiledocMarker[]\n  sections!: MobiledocSection[]\n  items!: MobiledocMarker[][]\n  markerTypes!: MobiledocMarkerType[]\n  atomTypes!: MobiledocAtom[]\n  cardTypes!: MobiledocCard[]\n  result!: MobiledocV0_3_1\n\n  _markerTypeCache!: Dict<number>\n\n  openMarker(closeCount: number, value: string) {\n    this.markupMarkerIds = []\n    this.markers.push([MobiledocMarkerKind.MARKUP, this.markupMarkerIds, closeCount, value || ''])\n  }\n\n  openAtom(closeCount: number, name: string, value: string, payload: {}) {\n    const index = this._addAtomTypeIndex(name, value, payload)\n    this.markupMarkerIds = []\n    this.markers.push([MobiledocMarkerKind.ATOM, this.markupMarkerIds, closeCount, index])\n  }\n\n  openMarkupSection(tagName: string) {\n    this.markers = []\n    this.sections.push([MobiledocSectionKind.MARKUP, tagName, this.markers])\n  }\n\n  openListSection(tagName: string) {\n    this.items = []\n    this.sections.push([MobiledocSectionKind.LIST, tagName, this.items])\n  }\n\n  openListItem() {\n    this.markers = []\n    this.items.push(this.markers)\n  }\n\n  openImageSection(url: string) {\n    this.sections.push([MobiledocSectionKind.IMAGE, url])\n  }\n\n  openCardSection(name: string, payload: {}) {\n    const index = this._addCardTypeIndex(name, payload)\n    this.sections.push([MobiledocSectionKind.CARD, index])\n  }\n\n  openPost() {\n    this.atomTypes = []\n    this.cardTypes = []\n    this.markerTypes = []\n    this.sections = []\n    this.result = {\n      version: MOBILEDOC_VERSION,\n      atoms: this.atomTypes,\n      cards: this.cardTypes,\n      markups: this.markerTypes,\n      sections: this.sections,\n    }\n  }\n\n  openMarkup(tagName: string, attributes: string[]) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes)\n    this.markupMarkerIds.push(index)\n  }\n\n  _addCardTypeIndex(cardName: string, payload: {}) {\n    let cardType: MobiledocCard = [cardName, payload]\n    this.cardTypes.push(cardType)\n    return this.cardTypes.length - 1\n  }\n\n  _addAtomTypeIndex(atomName: string, atomValue: string, payload: {}) {\n    let atomType: MobiledocAtom = [atomName, atomValue, payload]\n    this.atomTypes.push(atomType)\n    return this.atomTypes.length - 1\n  }\n\n  _findOrAddMarkerTypeIndex(tagName: string, attributesArray: string[]) {\n    if (!this._markerTypeCache) {\n      this._markerTypeCache = {}\n    }\n    const key = `${tagName}-${attributesArray.join('-')}`\n\n    let index = this._markerTypeCache[key]\n    if (index === undefined) {\n      let markerType: MobiledocMarkerType = [tagName]\n      if (attributesArray.length) {\n        markerType.push(attributesArray)\n      }\n      this.markerTypes.push(markerType)\n\n      index = this.markerTypes.length - 1\n      this._markerTypeCache[key] = index\n    }\n\n    return index\n  }\n}\n\nexport interface MobiledocV0_3_1 {\n  version: typeof MOBILEDOC_VERSION\n  atoms: MobiledocAtom[]\n  cards: MobiledocCard[]\n  markups: MobiledocMarkerType[]\n  sections: MobiledocSection[]\n}\n\n/**\n * Render from post -> mobiledoc\n */\nexport default {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post: Post): MobiledocV0_3_1 {\n    let opcodes: Opcodes = []\n    visit(visitor, post, opcodes)\n    let compiler = new PostOpcodeCompiler()\n    compile(compiler, opcodes)\n    return compiler.result\n  },\n}\n","import { visit, visitArray, compile, Opcodes } from '../../utils/compiler'\nimport { objectToSortedKVArray } from '../../utils/array-utils'\nimport { Type } from '../../models/types'\nimport Post from '../../models/post'\nimport MarkupSection from '../../models/markup-section'\nimport ListSection from '../../models/list-section'\nimport ListItem from '../../models/list-item'\nimport Image from '../../models/image'\nimport Card from '../../models/card'\nimport Marker from '../../models/marker'\nimport Markup from '../../models/markup'\nimport Atom from '../../models/atom'\nimport { Dict } from '../../utils/types'\nimport { MobiledocSectionKind, MobiledocMarkerKind } from './constants'\nimport { MobiledocCard, MobiledocAtom, MobiledocMarker, MobiledocSection, MobiledocMarkerType } from './0-3'\n\nexport const MOBILEDOC_VERSION = '0.3.2'\n\nexport type MobiledocAttributedMarkupSection = [MobiledocSectionKind.MARKUP, string, MobiledocMarker[], string[]]\nexport type MobiledocAttributedListSection = [MobiledocSectionKind.LIST, string, MobiledocMarker[][], string[]]\n\nexport type MobiledocAttributedSection =\n  | MobiledocSection\n  | MobiledocAttributedMarkupSection\n  | MobiledocAttributedListSection\n\nconst visitor = {\n  [Type.POST](node: Post, opcodes: Opcodes) {\n    opcodes.push(['openPost'])\n    visitArray(visitor, node.sections, opcodes)\n  },\n  [Type.MARKUP_SECTION](node: MarkupSection, opcodes: Opcodes) {\n    opcodes.push(['openMarkupSection', node.tagName, objectToSortedKVArray(node.attributes)])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.LIST_SECTION](node: ListSection, opcodes: Opcodes) {\n    opcodes.push(['openListSection', node.tagName, objectToSortedKVArray(node.attributes)])\n    visitArray(visitor, node.items, opcodes)\n  },\n  [Type.LIST_ITEM](node: ListItem, opcodes: Opcodes) {\n    opcodes.push(['openListItem'])\n    visitArray(visitor, node.markers, opcodes)\n  },\n  [Type.IMAGE_SECTION](node: Image, opcodes: Opcodes) {\n    opcodes.push(['openImageSection', node.src])\n  },\n  [Type.CARD](node: Card, opcodes: Opcodes) {\n    opcodes.push(['openCardSection', node.name, node.payload])\n  },\n  [Type.MARKER](node: Marker, opcodes: Opcodes) {\n    opcodes.push(['openMarker', node.closedMarkups.length, node.value])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n  [Type.MARKUP](node: Markup, opcodes: Opcodes) {\n    opcodes.push(['openMarkup', node.tagName, objectToSortedKVArray(node.attributes)])\n  },\n  [Type.ATOM](node: Atom, opcodes: Opcodes) {\n    opcodes.push(['openAtom', node.closedMarkups.length, node.name, node.value, node.payload])\n    visitArray(visitor, node.openedMarkups, opcodes)\n  },\n}\nclass PostOpcodeCompiler {\n  markupMarkerIds!: number[]\n  markers!: MobiledocMarker[]\n  sections!: MobiledocAttributedSection[]\n  items!: MobiledocMarker[][]\n  markerTypes!: MobiledocMarkerType[]\n  atomTypes!: MobiledocAtom[]\n  cardTypes!: MobiledocCard[]\n  result!: MobiledocV0_3_2\n\n  _markerTypeCache!: Dict<number>\n\n  openMarker(closeCount: number, value: string) {\n    this.markupMarkerIds = []\n    this.markers.push([MobiledocMarkerKind.MARKUP, this.markupMarkerIds, closeCount, value || ''])\n  }\n\n  openAtom(closeCount: number, name: string, value: string, payload: {}) {\n    const index = this._addAtomTypeIndex(name, value, payload)\n    this.markupMarkerIds = []\n    this.markers.push([MobiledocMarkerKind.ATOM, this.markupMarkerIds, closeCount, index])\n  }\n\n  openMarkupSection(tagName: string, attributes: string[]) {\n    this.markers = []\n    if (attributes && attributes.length !== 0) {\n      this.sections.push([MobiledocSectionKind.MARKUP, tagName, this.markers, attributes])\n    } else {\n      this.sections.push([MobiledocSectionKind.MARKUP, tagName, this.markers])\n    }\n  }\n\n  openListSection(tagName: string, attributes: string[]) {\n    this.items = []\n    if (attributes && attributes.length !== 0) {\n      this.sections.push([MobiledocSectionKind.LIST, tagName, this.items, attributes])\n    } else {\n      this.sections.push([MobiledocSectionKind.LIST, tagName, this.items])\n    }\n  }\n\n  openListItem() {\n    this.markers = []\n    this.items.push(this.markers)\n  }\n\n  openImageSection(url: string) {\n    this.sections.push([MobiledocSectionKind.IMAGE, url])\n  }\n\n  openCardSection(name: string, payload: {}) {\n    const index = this._addCardTypeIndex(name, payload)\n    this.sections.push([MobiledocSectionKind.CARD, index])\n  }\n\n  openPost() {\n    this.atomTypes = []\n    this.cardTypes = []\n    this.markerTypes = []\n    this.sections = []\n    this.result = {\n      version: MOBILEDOC_VERSION,\n      atoms: this.atomTypes,\n      cards: this.cardTypes,\n      markups: this.markerTypes,\n      sections: this.sections,\n    }\n  }\n\n  openMarkup(tagName: string, attributes: string[]) {\n    const index = this._findOrAddMarkerTypeIndex(tagName, attributes)\n    this.markupMarkerIds.push(index)\n  }\n\n  _addCardTypeIndex(cardName: string, payload: {}) {\n    let cardType: MobiledocCard = [cardName, payload]\n    this.cardTypes.push(cardType)\n    return this.cardTypes.length - 1\n  }\n\n  _addAtomTypeIndex(atomName: string, atomValue: string, payload: {}) {\n    let atomType: MobiledocAtom = [atomName, atomValue, payload]\n    this.atomTypes.push(atomType)\n    return this.atomTypes.length - 1\n  }\n\n  _findOrAddMarkerTypeIndex(tagName: string, attributesArray: string[]) {\n    if (!this._markerTypeCache) {\n      this._markerTypeCache = {}\n    }\n    const key = `${tagName}-${attributesArray.join('-')}`\n\n    let index = this._markerTypeCache[key]\n    if (index === undefined) {\n      let markerType: MobiledocMarkerType = [tagName]\n      if (attributesArray.length) {\n        markerType.push(attributesArray)\n      }\n      this.markerTypes.push(markerType)\n\n      index = this.markerTypes.length - 1\n      this._markerTypeCache[key] = index\n    }\n\n    return index\n  }\n}\n\nexport interface MobiledocV0_3_2 {\n  version: typeof MOBILEDOC_VERSION\n  atoms: MobiledocAtom[]\n  cards: MobiledocCard[]\n  markups: MobiledocMarkerType[]\n  sections: MobiledocAttributedSection[]\n}\n\n/**\n * Render from post -> mobiledoc\n */\nexport default {\n  /**\n   * @param {Post}\n   * @return {Mobiledoc}\n   */\n  render(post: Post): MobiledocV0_3_2 {\n    let opcodes: Opcodes = []\n    visit(visitor, post, opcodes)\n    let compiler = new PostOpcodeCompiler()\n    compile(compiler, opcodes)\n    return compiler.result\n  },\n}\n","import MobiledocParser_0_2 from './0-2'\nimport MobiledocParser_0_3 from './0-3'\nimport MobiledocParser_0_3_1 from './0-3-1'\nimport MobiledocParser_0_3_2 from './0-3-2'\n\nimport { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_2, MobiledocV0_2 } from '../../renderers/mobiledoc/0-2'\nimport { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_3, MobiledocV0_3 } from '../../renderers/mobiledoc/0-3'\nimport { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_3_1, MobiledocV0_3_1 } from '../../renderers/mobiledoc/0-3-1'\nimport { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_3_2, MobiledocV0_3_2 } from '../../renderers/mobiledoc/0-3-2'\nimport assert from '../../utils/assert'\nimport PostNodeBuilder from '../../models/post-node-builder'\nimport Post from '../../models/post'\n\ntype Mobiledoc = MobiledocV0_2 | MobiledocV0_3 | MobiledocV0_3_1 | MobiledocV0_3_2\n\nexport default {\n  parse(builder: PostNodeBuilder, mobiledoc: Mobiledoc): Post {\n    switch (mobiledoc.version) {\n      case MOBILEDOC_VERSION_0_2:\n        return new MobiledocParser_0_2(builder).parse(mobiledoc)\n      case MOBILEDOC_VERSION_0_3:\n        return new MobiledocParser_0_3(builder).parse(mobiledoc)\n      case MOBILEDOC_VERSION_0_3_1:\n        return new MobiledocParser_0_3_1(builder).parse(mobiledoc)\n      case MOBILEDOC_VERSION_0_3_2:\n        return new MobiledocParser_0_3_2(builder).parse(mobiledoc)\n      default:\n        assert(`Unknown version of mobiledoc parser requested: ${(mobiledoc as any).version}`, false)\n    }\n  },\n}\n","import Card, { CardMode } from './card'\nimport assert from '../utils/assert'\nimport { Dict, Maybe } from '../utils/types'\n\nexport type CardNodeOptions = Dict<unknown>\n\nexport type CardRenderHook = (...args: any[]) => void | Maybe<Element>\n\ntype DidRenderCallback = null | (() => void)\ntype TeardownCallback = null | (() => void)\n\ntype CardDataType = 'dom'\n\nexport interface CardData {\n  name: string\n  type?: CardDataType\n\n  render: CardRenderHook\n  edit?: CardRenderHook\n}\n\ntype CardRenderMethodName = 'render' | 'edit'\n\nexport default class CardNode {\n  editor: any\n  card: CardData\n  section: Card\n  element: Element\n  options?: CardNodeOptions\n\n  mode!: CardMode\n  _rendered: Element | null = null\n  _teardownCallback: TeardownCallback = null\n  _didRenderCallback: DidRenderCallback = null\n\n  constructor(editor: any, card: CardData, section: Card, element: Element, options?: CardNodeOptions) {\n    this.editor = editor\n    this.card = card\n    this.section = section\n    this.element = element\n    this.options = options\n  }\n\n  render(mode: CardMode) {\n    if (this.mode === mode) {\n      return\n    }\n\n    this.teardown()\n\n    this.mode = mode\n\n    let methodName: CardRenderMethodName = mode === 'display' ? 'render' : 'edit'\n    let method = this.card[methodName]\n\n    assert(`Card is missing \"${methodName}\" (tried to render mode: \"${mode}\")`, !!method)\n    let rendered =\n      method({\n        env: this.env,\n        options: this.options,\n        payload: this.section.payload,\n      }) || null\n\n    this._validateAndAppendRenderResult(rendered)\n  }\n\n  teardown() {\n    if (this._teardownCallback) {\n      this._teardownCallback()\n      this._teardownCallback = null\n    }\n    if (this._rendered) {\n      this.element.removeChild(this._rendered)\n      this._rendered = null\n    }\n  }\n\n  didRender() {\n    if (this._didRenderCallback) {\n      this._didRenderCallback()\n    }\n  }\n\n  get env() {\n    return {\n      name: this.card.name,\n      isInEditor: true,\n      onTeardown: (callback: TeardownCallback) => (this._teardownCallback = callback),\n      didRender: (callback: DidRenderCallback) => (this._didRenderCallback = callback),\n      edit: () => this.edit(),\n      save: (payload: {}, transition = true) => {\n        this.section.payload = payload\n\n        this.editor._postDidChange()\n        if (transition) {\n          this.display()\n        }\n      },\n      cancel: () => this.display(),\n      remove: () => this.remove(),\n      postModel: this.section,\n    }\n  }\n\n  display() {\n    this.render(CardMode.DISPLAY)\n  }\n\n  edit() {\n    this.render(CardMode.EDIT)\n  }\n\n  remove() {\n    this.editor.run((postEditor: any) => postEditor.removeSection(this.section))\n  }\n\n  _validateAndAppendRenderResult(rendered: Maybe<Element>) {\n    if (!rendered) {\n      return\n    }\n\n    let {\n      card: { name },\n    } = this\n    assert(`Card \"${name}\" must render dom (render value was: \"${rendered}\")`, !!rendered.nodeType)\n    this.element.appendChild(rendered)\n    this._rendered = rendered\n    this.didRender()\n  }\n}\n","import Atom from './atom'\nimport assert from '../utils/assert'\nimport { JsonData, Dict, Maybe } from '../utils/types'\n\nexport type AtomOptions = Dict<unknown>\n\nexport type TeardownCallback = () => void\nexport interface AtomRenderOptions {\n  options: AtomOptions\n  env: any\n  value: unknown\n  payload: JsonData\n}\n\nexport type AtomRenderHook = (options: AtomRenderOptions) => Maybe<Element | Text> | void\n\nexport type AtomData = {\n  name: string\n  type: 'dom'\n  render: AtomRenderHook\n}\n\nexport default class AtomNode {\n  editor: any\n  atom: AtomData\n  model: Atom\n  element: Element\n  atomOptions: AtomOptions\n\n  _teardownCallback: TeardownCallback | null = null\n  _rendered: Maybe<Node>\n\n  constructor(editor: any, atom: AtomData, model: Atom, element: Element, atomOptions: AtomOptions) {\n    this.editor = editor\n    this.atom = atom\n    this.model = model\n    this.atomOptions = atomOptions\n    this.element = element\n  }\n\n  render() {\n    if (!this._rendered) {\n      let {\n        atomOptions: options,\n        env,\n        model: { value, payload },\n      } = this\n      // cache initial render\n      this._rendered = this.atom.render({ options, env, value, payload }) || null\n    }\n\n    this._validateAndAppendRenderResult(this._rendered!)\n  }\n\n  get env() {\n    return {\n      name: this.atom.name,\n      onTeardown: (callback: TeardownCallback) => (this._teardownCallback = callback),\n      save: (value: string, payload = {}) => {\n        this.model.value = value\n        this.model.payload = payload\n\n        this.editor._postDidChange()\n        this.teardown()\n        this.render()\n      },\n    }\n  }\n\n  teardown() {\n    if (this._teardownCallback) {\n      this._teardownCallback()\n      this._teardownCallback = null\n    }\n    if (this._rendered) {\n      this.element.removeChild(this._rendered)\n      this._rendered = null\n    }\n  }\n\n  _validateAndAppendRenderResult(rendered: Node) {\n    if (!rendered) {\n      return\n    }\n\n    let {\n      atom: { name },\n    } = this\n    assert(`Atom \"${name}\" must return a DOM node (returned value was: \"${rendered}\")`, !!rendered.nodeType)\n    this.element.appendChild(rendered)\n  }\n}\n","import CardNode, { CardData, CardRenderHook } from '../models/card-node'\nimport { detect, forEach, ForEachable } from '../utils/array-utils'\nimport AtomNode, { AtomData, AtomRenderHook } from '../models/atom-node'\nimport { Type } from '../models/types'\nimport { startsWith, endsWith } from '../utils/string-utils'\nimport { addClassName, removeClassName } from '../utils/dom-utils'\nimport MarkupSection, { MARKUP_SECTION_ELEMENT_NAMES } from '../models/markup-section'\nimport assert, { unwrap, assertNotNull, assertExistsIn } from '../utils/assert'\nimport { TAB } from '../utils/characters'\nimport Markup from '../models/markup'\nimport Marker from '../models/marker'\nimport Section from '../models/_section'\nimport { Attributable } from '../models/_attributable'\nimport { TagNameable } from '../models/_tag-nameable'\nimport ListSection from '../models/list-section'\nimport RenderNode from '../models/render-node'\nimport { Option, Maybe, Dict } from '../utils/types'\nimport Atom from '../models/atom'\nimport Editor from '../editor/editor'\nimport { hasChildSections } from '../models/_has-child-sections'\nimport Post from '../models/post'\nimport ListItem from '../models/list-item'\nimport Image from '../models/image'\nimport Card from '../models/card'\nimport RenderTree from '../models/render-tree'\nimport { PostNode } from '../models/post-node-builder'\n\nexport const CARD_ELEMENT_CLASS_NAME = '__mobiledoc-card'\nexport const NO_BREAK_SPACE = '\\u00A0'\nexport const TAB_CHARACTER = '\\u2003'\nexport const SPACE = ' '\nexport const ZWNJ = '\\u200c'\nexport const ATOM_CLASS_NAME = '-mobiledoc-kit__atom'\nexport const EDITOR_HAS_NO_CONTENT_CLASS_NAME = '__has-no-content'\nexport const EDITOR_ELEMENT_CLASS_NAME = '__mobiledoc-editor'\n\nfunction createElementFromMarkup(doc: Document, markup: Markup) {\n  let element = doc.createElement(markup.tagName)\n  Object.keys(markup.attributes).forEach(k => {\n    element.setAttribute(k, markup.attributes[k])\n  })\n  return element\n}\n\nconst TWO_SPACES = `${SPACE}${SPACE}`\nconst SPACE_AND_NO_BREAK = `${SPACE}${NO_BREAK_SPACE}`\nconst SPACES_REGEX = new RegExp(TWO_SPACES, 'g')\nconst TAB_REGEX = new RegExp(TAB, 'g')\nconst endsWithSpace = function (text: string) {\n  return endsWith(text, SPACE)\n}\nconst startsWithSpace = function (text: string) {\n  return startsWith(text, SPACE)\n}\n\n// FIXME: This can be done more efficiently with a single pass\n// building a correct string based on the original.\nfunction renderHTMLText(marker: Marker) {\n  let text = marker.value\n  text = text.replace(SPACES_REGEX, SPACE_AND_NO_BREAK).replace(TAB_REGEX, TAB_CHARACTER)\n\n  // If the first marker has a leading space or the last marker has a\n  // trailing space, the browser will collapse the space when we position\n  // the cursor.\n  // See https://github.com/bustle/mobiledoc-kit/issues/68\n  //   and https://github.com/bustle/mobiledoc-kit/issues/75\n  if (marker.isMarker && endsWithSpace(text) && !marker.next) {\n    text = text.substr(0, text.length - 1) + NO_BREAK_SPACE\n  }\n  if (\n    marker.isMarker &&\n    startsWithSpace(text) &&\n    (!marker.prev || (marker.prev.isMarker && endsWithSpace(marker.prev.value)))\n  ) {\n    text = NO_BREAK_SPACE + text.substr(1)\n  }\n  return text\n}\n\n// ascends from element upward, returning the last parent node that is not\n// parentElement\nfunction penultimateParentOf(element: Node, parentElement: Node) {\n  while (\n    parentElement &&\n    element.parentNode !== parentElement &&\n    element.parentNode !== document.body // ensure the while loop stops\n  ) {\n    element = element.parentNode as Node\n  }\n  return element\n}\n\nfunction setSectionAttributesOnElement(section: Attributable, element: HTMLElement) {\n  section.eachAttribute((key, value) => {\n    element.setAttribute(key, value)\n  })\n}\n\nfunction renderMarkupSection(section: TagNameable & Attributable) {\n  let element: HTMLElement\n\n  if (MARKUP_SECTION_ELEMENT_NAMES.indexOf(section.tagName) !== -1) {\n    element = document.createElement(section.tagName)\n  } else {\n    element = document.createElement('div')\n    addClassName(element, section.tagName)\n  }\n\n  setSectionAttributesOnElement(section, element)\n\n  return element\n}\n\nfunction renderListSection(section: ListSection) {\n  let element = document.createElement(section.tagName)\n\n  setSectionAttributesOnElement(section, element)\n\n  return element\n}\n\nfunction renderListItem() {\n  return document.createElement('li')\n}\n\nfunction renderCursorPlaceholder() {\n  return document.createElement('br')\n}\n\nfunction renderInlineCursorPlaceholder() {\n  return document.createTextNode(ZWNJ)\n}\n\nfunction renderCard() {\n  let wrapper = document.createElement('div')\n  let cardElement = document.createElement('div')\n  cardElement.contentEditable = 'false'\n  addClassName(cardElement, CARD_ELEMENT_CLASS_NAME)\n  wrapper.appendChild(renderInlineCursorPlaceholder())\n  wrapper.appendChild(cardElement)\n  wrapper.appendChild(renderInlineCursorPlaceholder())\n  return { wrapper, cardElement }\n}\n\n/**\n * Wrap the element in all of the opened markups\n * @return {DOMElement} the wrapped element\n * @private\n */\nfunction wrapElement(element: Node, openedMarkups: Markup[]): Node {\n  let wrappedElement = element\n\n  for (let i = openedMarkups.length - 1; i >= 0; i--) {\n    let markup = openedMarkups[i]\n    let openedElement = createElementFromMarkup(document, markup)\n    openedElement.appendChild(wrappedElement)\n    wrappedElement = openedElement\n  }\n\n  return wrappedElement\n}\n\n// Attach the element to its parent element at the correct position based on the\n// previousRenderNode\nfunction attachElementToParent(element: Node, parentElement: Node, previousRenderNode: Option<RenderNode> = null) {\n  if (previousRenderNode) {\n    let previousSibling = previousRenderNode.element!\n    let previousSiblingPenultimate = penultimateParentOf(previousSibling, parentElement)\n    parentElement.insertBefore(element, previousSiblingPenultimate.nextSibling)\n  } else {\n    parentElement.insertBefore(element, parentElement.firstChild)\n  }\n}\n\nfunction renderAtom(atom: Atom, element: HTMLElement, previousRenderNode: Option<RenderNode>) {\n  let atomElement = document.createElement('span')\n  atomElement.contentEditable = 'false'\n\n  let wrapper = document.createElement('span')\n  addClassName(wrapper, ATOM_CLASS_NAME)\n  let headTextNode = renderInlineCursorPlaceholder()\n  let tailTextNode = renderInlineCursorPlaceholder()\n\n  wrapper.appendChild(headTextNode)\n  wrapper.appendChild(atomElement)\n  wrapper.appendChild(tailTextNode)\n\n  let wrappedElement = wrapElement(wrapper, atom.openedMarkups)\n  attachElementToParent(wrappedElement, element, previousRenderNode)\n\n  return {\n    markupElement: wrappedElement,\n    wrapper,\n    atomElement,\n    headTextNode,\n    tailTextNode,\n  }\n}\n\nfunction getNextMarkerElement(renderNode: RenderNode) {\n  let element = renderNode.element!.parentNode\n  let marker = renderNode.postNode! as Marker\n  let closedCount = marker.closedMarkups.length\n\n  while (closedCount--) {\n    element = element!.parentNode\n  }\n  return element\n}\n\ninterface RenderMarkerResult {\n  element: Node\n  markupElement: Node\n}\n\n/**\n * Render the marker\n * @param {Marker} marker the marker to render\n * @param {DOMNode} element the element to attach the rendered marker to\n * @param {RenderNode} [previousRenderNode] The render node before this one, which\n *        affects the determination of where to insert this rendered marker.\n * @return {Object} With properties `element` and `markupElement`.\n *         The node (textNode) that has the text for\n *         this marker, and the outermost rendered element. If the marker has no\n *         markups, element and markupElement will be the same textNode\n * @private\n */\nfunction renderMarker(marker: Marker, parentElement: Node, previousRenderNode: Option<RenderNode>): RenderMarkerResult {\n  let text = renderHTMLText(marker)\n\n  let element = document.createTextNode(text)\n  let markupElement = wrapElement(element, marker.openedMarkups)\n  attachElementToParent(markupElement, parentElement, previousRenderNode)\n\n  return { element, markupElement }\n}\n\n// Attach the render node's element to the DOM,\n// replacing the originalElement if it exists\nfunction attachRenderNodeElementToDOM(renderNode: RenderNode, originalElement: Option<Node> = null) {\n  const element = unwrap(renderNode.element)\n\n  assertNotNull('expected RenderNode to have a parent', renderNode.parent)\n\n  if (originalElement) {\n    // RenderNode has already rendered\n    let parentElement = renderNode.parent.element!\n    parentElement.replaceChild(element, originalElement)\n  } else {\n    // RenderNode has not yet been rendered\n    let parentElement: Node\n    let nextSiblingElement: Option<Node>\n\n    if (renderNode.prev) {\n      let previousElement = unwrap(renderNode.prev.element)\n      parentElement = unwrap(previousElement.parentNode)\n      nextSiblingElement = previousElement.nextSibling\n    } else {\n      parentElement = renderNode.parent.element!\n      nextSiblingElement = parentElement.firstChild\n    }\n    parentElement.insertBefore(element, nextSiblingElement)\n  }\n}\n\nfunction removeRenderNodeSectionFromParent(renderNode: RenderNode, section: Section) {\n  assertNotNull('expected RenderNode to have a parent', renderNode.parent)\n  assertNotNull('expected parent RenderNode to have a PostNode', renderNode.parent.postNode)\n\n  const parent = renderNode.parent.postNode\n  assert('expected PostNode to have sections', hasChildSections(parent))\n\n  parent.sections.remove(section)\n}\n\nfunction removeRenderNodeElementFromParent(renderNode: RenderNode) {\n  if (renderNode.element && renderNode.element.parentNode) {\n    renderNode.element.parentNode.removeChild(renderNode.element)\n  }\n}\n\nfunction validateCards(cards: CardData[] = []) {\n  forEach(cards, card => {\n    assert(`Card \"${card.name}\" must define type \"dom\", has: \"${card.type}\"`, card.type === 'dom')\n    assert(`Card \"${card.name}\" must define \\`render\\` method`, !!card.render)\n  })\n  return cards\n}\n\nfunction validateAtoms(atoms: AtomData[] = []) {\n  forEach(atoms, atom => {\n    assert(`Atom \"${atom.name}\" must define type \"dom\", has: \"${atom.type}\"`, atom.type === 'dom')\n    assert(`Atom \"${atom.name}\" must define \\`render\\` method`, !!atom.render)\n  })\n  return atoms\n}\n\ntype VisitArgs = [RenderNode, ForEachable<PostNode>, boolean?]\ntype VisitFn = (...args: VisitArgs) => void\n\nclass Visitor {\n  editor: Editor\n  cards: CardData[]\n  atoms: AtomData[]\n\n  unknownCardHandler: CardRenderHook\n  unknownAtomHandler: AtomRenderHook\n\n  options: Dict<unknown>\n\n  constructor(\n    editor: Editor,\n    cards: CardData[],\n    atoms: AtomData[],\n    unknownCardHandler: CardRenderHook,\n    unknownAtomHandler: AtomRenderHook,\n    options: Dict<unknown>\n  ) {\n    this.editor = editor\n    this.cards = validateCards(cards)\n    this.atoms = validateAtoms(atoms)\n    this.unknownCardHandler = unknownCardHandler\n    this.unknownAtomHandler = unknownAtomHandler\n    this.options = options\n  }\n\n  _findCard(cardName: string) {\n    let card = detect(this.cards, card => card.name === cardName)\n    return card || this._createUnknownCard(cardName)\n  }\n\n  _createUnknownCard(cardName: string): CardData {\n    assert(`Unknown card \"${cardName}\" found, but no unknownCardHandler is defined`, !!this.unknownCardHandler)\n\n    return {\n      name: cardName,\n      type: 'dom',\n      render: this.unknownCardHandler,\n      edit: this.unknownCardHandler,\n    }\n  }\n\n  _findAtom(atomName: string) {\n    let atom = detect(this.atoms, atom => atom.name === atomName)\n    return atom || this._createUnknownAtom(atomName)\n  }\n\n  _createUnknownAtom(atomName: string): AtomData {\n    assert(`Unknown atom \"${atomName}\" found, but no unknownAtomHandler is defined`, !!this.unknownAtomHandler)\n\n    return {\n      name: atomName,\n      type: 'dom',\n      render: this.unknownAtomHandler,\n    }\n  }\n\n  [Type.POST](renderNode: RenderNode, post: Post, visit: VisitFn) {\n    if (!renderNode.element) {\n      renderNode.element = document.createElement('div')\n    }\n\n    let element = renderNode.element as Element\n    addClassName(element, EDITOR_ELEMENT_CLASS_NAME)\n\n    if (post.hasContent) {\n      removeClassName(element, EDITOR_HAS_NO_CONTENT_CLASS_NAME)\n    } else {\n      addClassName(element, EDITOR_HAS_NO_CONTENT_CLASS_NAME)\n    }\n\n    visit(renderNode, post.sections)\n  }\n\n  [Type.MARKUP_SECTION](renderNode: RenderNode, section: MarkupSection, visit: VisitFn) {\n    const originalElement = renderNode.element\n\n    // Always rerender the section -- its tag name or attributes may have changed.\n    // TODO make this smarter, only rerendering and replacing the element when necessary\n    renderNode.element = renderMarkupSection(section)\n    renderNode.cursorElement = null\n    attachRenderNodeElementToDOM(renderNode, originalElement)\n\n    if (section.isBlank) {\n      let cursorPlaceholder = renderCursorPlaceholder()\n      renderNode.element.appendChild(cursorPlaceholder)\n      renderNode.cursorElement = cursorPlaceholder\n    } else {\n      const visitAll = true\n      visit(renderNode, section.markers, visitAll)\n    }\n  }\n\n  [Type.LIST_SECTION](renderNode: RenderNode, section: ListSection, visit: VisitFn) {\n    const originalElement = renderNode.element\n\n    renderNode.element = renderListSection(section)\n    attachRenderNodeElementToDOM(renderNode, originalElement)\n\n    const visitAll = true\n    visit(renderNode, section.items, visitAll)\n  }\n\n  [Type.LIST_ITEM](renderNode: RenderNode, item: ListItem, visit: VisitFn) {\n    // FIXME do we need to do anything special for rerenders?\n    renderNode.element = renderListItem()\n    renderNode.cursorElement = null\n    attachRenderNodeElementToDOM(renderNode, null)\n\n    if (item.isBlank) {\n      let cursorPlaceholder = renderCursorPlaceholder()\n      renderNode.element.appendChild(cursorPlaceholder)\n      renderNode.cursorElement = cursorPlaceholder\n    } else {\n      const visitAll = true\n      visit(renderNode, item.markers, visitAll)\n    }\n  }\n\n  [Type.MARKER](renderNode: RenderNode, marker: Marker) {\n    let parentElement: Node\n\n    if (renderNode.prev) {\n      parentElement = getNextMarkerElement(renderNode.prev)!\n    } else {\n      parentElement = renderNode.parent!.element!\n    }\n\n    let { element, markupElement } = renderMarker(marker, parentElement, renderNode.prev)\n\n    renderNode.element = element\n    renderNode.markupElement = markupElement\n  }\n\n  [Type.IMAGE_SECTION](renderNode: RenderNode<HTMLImageElement>, section: Image) {\n    if (renderNode.element) {\n      if (renderNode.element.src !== section.src) {\n        renderNode.element.src = section.src || ''\n      }\n    } else {\n      let element = document.createElement('img')\n      element.src = section.src || ''\n      if (renderNode.prev) {\n        let previousElement = renderNode.prev.element!\n        let nextElement = previousElement.nextSibling\n        if (nextElement) {\n          nextElement.parentNode!.insertBefore(element, nextElement)\n        }\n      }\n      if (!element.parentNode) {\n        renderNode.parent!.element!.appendChild(element)\n      }\n      renderNode.element = element\n    }\n  }\n\n  [Type.CARD](renderNode: RenderNode, section: Card) {\n    const originalElement = renderNode.element\n    const { editor, options } = this\n\n    const card = this._findCard(section.name)\n\n    let { wrapper, cardElement } = renderCard()\n    renderNode.element = wrapper\n    attachRenderNodeElementToDOM(renderNode, originalElement)\n\n    const cardNode = new CardNode(editor, card, section, cardElement, options)\n    renderNode.cardNode = cardNode\n\n    const initialMode = section._initialMode\n    cardNode[initialMode]()\n  }\n\n  [Type.ATOM](renderNode: RenderNode, atomModel: Atom) {\n    let parentElement: Node\n\n    if (renderNode.prev) {\n      parentElement = getNextMarkerElement(renderNode.prev)!\n    } else {\n      parentElement = renderNode.parent!.element!\n    }\n\n    const { editor, options } = this\n    const { wrapper, markupElement, atomElement, headTextNode, tailTextNode } = renderAtom(\n      atomModel,\n      parentElement as HTMLElement,\n      renderNode.prev\n    )\n    const atom = this._findAtom(atomModel.name)\n\n    let atomNode = renderNode.atomNode\n    if (!atomNode) {\n      // create new AtomNode\n      atomNode = new AtomNode(editor, atom, atomModel, atomElement, options)\n    } else {\n      // retarget atomNode to new atom element\n      atomNode.element = atomElement\n    }\n\n    atomNode.render()\n\n    renderNode.atomNode = atomNode\n    renderNode.element = wrapper\n    renderNode.headTextNode = headTextNode\n    renderNode.tailTextNode = tailTextNode\n    renderNode.markupElement = markupElement\n  }\n}\n\nlet destroyHooks = {\n  [Type.POST](/*renderNode, post*/) {\n    assert('post destruction is not supported by the renderer', false)\n  },\n\n  [Type.MARKUP_SECTION](renderNode: RenderNode, section: MarkupSection) {\n    removeRenderNodeSectionFromParent(renderNode, section)\n    removeRenderNodeElementFromParent(renderNode)\n  },\n\n  [Type.LIST_SECTION](renderNode: RenderNode, section: ListSection) {\n    removeRenderNodeSectionFromParent(renderNode, section)\n    removeRenderNodeElementFromParent(renderNode)\n  },\n\n  [Type.LIST_ITEM](renderNode: RenderNode, li: ListItem) {\n    removeRenderNodeSectionFromParent(renderNode, li)\n    removeRenderNodeElementFromParent(renderNode)\n  },\n\n  [Type.MARKER](renderNode: RenderNode, marker: Marker) {\n    // FIXME before we render marker, should delete previous renderNode's element\n    // and up until the next marker element\n\n    // If an atom throws during render we may end up later destroying a renderNode\n    // that has not rendered yet, so exit early here if so.\n    if (!renderNode.isRendered) {\n      return\n    }\n    let { markupElement } = renderNode\n\n    if (marker.section) {\n      marker.section.markers.remove(marker)\n    }\n\n    if (markupElement!.parentNode) {\n      // if no parentNode, the browser already removed this element\n      markupElement!.parentNode.removeChild(markupElement!)\n    }\n  },\n\n  [Type.IMAGE_SECTION](renderNode: RenderNode, section: Image) {\n    removeRenderNodeSectionFromParent(renderNode, section)\n    removeRenderNodeElementFromParent(renderNode)\n  },\n\n  [Type.CARD](renderNode: RenderNode, section: Card) {\n    if (renderNode.cardNode) {\n      renderNode.cardNode.teardown()\n    }\n    removeRenderNodeSectionFromParent(renderNode, section)\n    removeRenderNodeElementFromParent(renderNode)\n  },\n\n  [Type.ATOM](renderNode: RenderNode, atom: Atom) {\n    if (renderNode.atomNode) {\n      renderNode.atomNode.teardown()\n    }\n\n    // an atom is a kind of marker so just call its destroy hook vs copying here\n    destroyHooks[Type.MARKER](renderNode, (atom as unknown) as Marker)\n  },\n}\n\n// removes children from parentNode (a RenderNode) that are scheduled for removal\nfunction removeDestroyedChildren(parentNode: RenderNode, forceRemoval = false) {\n  let child = parentNode.childNodes.head\n  let nextChild: Option<RenderNode>, method: Type\n  while (child) {\n    nextChild = child.next\n    if (child.isRemoved || forceRemoval) {\n      removeDestroyedChildren(child, true)\n      method = child.postNode!.type\n      assertExistsIn(`editor-dom cannot destroy \"${method}\"`, method, destroyHooks)\n      ;(destroyHooks[method] as any)(child, child.postNode)\n      parentNode.childNodes.remove(child)\n    }\n    child = nextChild\n  }\n}\n\n// Find an existing render node for the given postNode, or\n// create one, insert it into the tree, and return it\nfunction lookupNode(renderTree: RenderTree, parentNode: RenderNode, postNode: PostNode, previousNode: RenderNode) {\n  if (postNode.renderNode) {\n    return postNode.renderNode\n  } else {\n    const renderNode = renderTree.buildRenderNode(postNode)\n    parentNode.childNodes.insertAfter(renderNode, previousNode)\n    return renderNode\n  }\n}\n\nexport default class Renderer {\n  editor: Editor\n  visitor: Visitor\n  nodes: RenderNode[]\n  hasRendered: boolean\n\n  renderTree: Option<RenderTree> = null\n\n  constructor(\n    editor: Editor,\n    cards: CardData[],\n    atoms: AtomData[],\n    unknownCardHandler: CardRenderHook,\n    unknownAtomHandler: AtomRenderHook,\n    options: {}\n  ) {\n    this.editor = editor\n    this.visitor = new Visitor(editor, cards, atoms, unknownCardHandler, unknownAtomHandler, options)\n    this.nodes = []\n    this.hasRendered = false\n  }\n\n  destroy() {\n    if (!this.hasRendered) {\n      return\n    }\n    let renderNode = unwrap(this.renderTree).rootNode\n    let force = true\n    removeDestroyedChildren(renderNode, force)\n  }\n\n  visit(renderTree: RenderTree, parentNode: RenderNode, postNodes: ForEachable<PostNode>, visitAll = false) {\n    let previousNode: RenderNode\n    postNodes.forEach(postNode => {\n      let node = lookupNode(renderTree, parentNode, postNode, previousNode)\n      if (node.isDirty || visitAll) {\n        this.nodes.push(node)\n      }\n      previousNode = node\n    })\n  }\n\n  render(renderTree: RenderTree) {\n    this.hasRendered = true\n    this.renderTree = renderTree\n    let renderNode: Maybe<RenderNode> = renderTree.rootNode\n    let method: Type\n    let postNode: PostNode\n\n    while (renderNode) {\n      removeDestroyedChildren(renderNode)\n      postNode = renderNode.postNode!\n\n      method = postNode.type\n      assertExistsIn(`EditorDom visitor cannot handle type ${method}`, method, this.visitor)\n      this.visitor[method](renderNode as any, postNode as any, (...args: VisitArgs) => this.visit(renderTree, ...args))\n      renderNode.markClean()\n      renderNode = this.nodes.shift()\n    }\n  }\n}\n","import { normalizeTagName } from '../utils/dom-utils'\nimport { filterObject } from '../utils/array-utils'\nimport { MARKUP_TYPE } from './types'\nimport assert from '../utils/assert'\nimport PostNodeBuilder from './post-node-builder'\n\nexport const VALID_MARKUP_TAGNAMES = [\n  'a',\n  'b',\n  'code',\n  'em',\n  'i',\n  's', // strikethrough\n  'del', // deleted text (also strikethrough)\n  'strong',\n  'sub', // subscript\n  'sup', // superscript\n  'u',\n].map(normalizeTagName)\n\nexport const VALID_ATTRIBUTES = ['href', 'rel']\n\n/**\n * A Markup is similar with an inline HTML tag that might be added to\n * text to modify its meaning and/or display. Examples of types of markup\n * that could be added are bold ('b'), italic ('i'), strikethrough ('s'), and `a` tags (links).\n * @property {String} tagName\n */\nexport default class Markup {\n  type = MARKUP_TYPE\n  tagName: string\n  attributes: { [key: string]: string }\n\n  builder!: PostNodeBuilder\n\n  /*\n   * @param {Object} attributes key-values\n   */\n  constructor(tagName: string, attributes = {}) {\n    assert(`Cannot create markup of tagName ${tagName}`, VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1)\n    this.tagName = normalizeTagName(tagName)\n\n    assert('Must use attributes object param (not array) for Markup', !Array.isArray(attributes))\n    this.attributes = filterObject(attributes, VALID_ATTRIBUTES)\n  }\n\n  /**\n   * Whether text in the forward direction of the cursor (i.e. to the right in ltr text)\n   * should be considered to have this markup applied to it.\n   * @private\n   */\n  isForwardInclusive() {\n    return this.tagName === normalizeTagName('a') ? false : true\n  }\n\n  isBackwardInclusive() {\n    return false\n  }\n\n  hasTag(tagName: string) {\n    return this.tagName === normalizeTagName(tagName)\n  }\n\n  /**\n   * Returns the attribute value\n   * @param {String} name, e.g. \"href\"\n   */\n  getAttribute(name: string) {\n    return this.attributes[name]\n  }\n\n  static isValidElement(element: Element) {\n    const tagName = normalizeTagName(element.tagName)\n    return VALID_MARKUP_TAGNAMES.indexOf(tagName) !== -1\n  }\n}\n","import MarkupSection, {\n  DEFAULT_TAG_NAME,\n  VALID_MARKUP_SECTION_TAGNAMES,\n  isMarkupSection as sectionIsMarkupSection,\n} from '../models/markup-section'\nimport { VALID_LIST_SECTION_TAGNAMES, isListSection as sectionIsListSection } from '../models/list-section'\nimport { VALID_LIST_ITEM_TAGNAMES, isListItem as sectionIsListItem } from '../models/list-item'\nimport { LIST_SECTION_TYPE, LIST_ITEM_TYPE, MARKUP_SECTION_TYPE } from '../models/types'\nimport Markup, { VALID_MARKUP_TAGNAMES } from '../models/markup'\nimport {\n  getAttributes,\n  normalizeTagName,\n  isTextNode,\n  isCommentNode,\n  NODE_TYPES,\n  isElementNode,\n} from '../utils/dom-utils'\nimport { any, forEach, contains } from '../utils/array-utils'\nimport { transformHTMLText, trimSectionText } from '../parsers/dom'\nimport assert, { assertType, expect } from '../utils/assert'\nimport PostNodeBuilder from '../models/post-node-builder'\nimport Section from '../models/_section'\nimport Marker from '../models/marker'\nimport Markerable, { isMarkerable } from '../models/_markerable'\nimport { Cloneable } from '../models/_cloneable'\n\nconst SKIPPABLE_ELEMENT_TAG_NAMES = ['style', 'head', 'title', 'meta'].map(normalizeTagName)\n\nconst NEWLINES = /\\s*\\n\\s*/g\nfunction sanitize(text: string) {\n  return text.replace(NEWLINES, ' ')\n}\n\n/**\n * parses an element into a section, ignoring any non-markup\n * elements contained within\n * @private\n */\n\ninterface SectionParserOptions {\n  plugins?: SectionParserPlugin[]\n}\n\ninterface SectionParserState {\n  section?: Cloneable<Section> | null\n  text?: string\n  markups?: Markup[]\n}\n\ninterface SectionParseEnv {\n  addSection: (section: Cloneable<Section>) => void\n  addMarkerable: (marker: Marker) => void\n  nodeFinished(): void\n}\n\nexport type SectionParserPlugin = (node: Node, builder: PostNodeBuilder, env: SectionParseEnv) => void\n\ntype SectionParserNode = HTMLElement | Text | Comment\n\nexport default class SectionParser {\n  builder: PostNodeBuilder\n  plugins: SectionParserPlugin[]\n\n  sections!: Cloneable<Section>[]\n  state!: SectionParserState\n\n  constructor(builder: PostNodeBuilder, options: SectionParserOptions = {}) {\n    this.builder = builder\n    this.plugins = options.plugins || []\n  }\n\n  parse(element: HTMLElement) {\n    if (this._isSkippable(element)) {\n      return []\n    }\n    this.sections = []\n    this.state = {}\n\n    this._updateStateFromElement(element)\n\n    let finished = false\n\n    // top-level text nodes will be run through parseNode later so avoid running\n    // the node through parserPlugins twice\n    if (!isTextNode(element)) {\n      finished = this.runPlugins(element)\n    }\n\n    if (!finished) {\n      let childNodes = isTextNode(element) ? [element] : element.childNodes\n\n      forEach(childNodes, el => {\n        this.parseNode(el as SectionParserNode)\n      })\n    }\n\n    this._closeCurrentSection()\n\n    return this.sections\n  }\n\n  runPlugins(node: Node) {\n    let isNodeFinished = false\n    let env = {\n      addSection: (section: Cloneable<Section>) => {\n        // avoid creating empty paragraphs due to wrapper elements around\n        // parser-plugin-handled elements\n        if (this.state.section && isMarkerable(this.state.section) && !this.state.section.text && !this.state.text) {\n          this.state.section = null\n        } else {\n          this._closeCurrentSection()\n        }\n        this.sections.push(section)\n      },\n      addMarkerable: (marker: Marker) => {\n        let { state } = this\n        let { section } = state\n        // if the first element doesn't create it's own state and it's plugin\n        // handler uses `addMarkerable` we won't have a section yet\n        if (!section) {\n          state.text = ''\n          state.section = this.builder.createMarkupSection(normalizeTagName('p'))\n          section = state.section\n        }\n        assertType<Markerable>(\n          'Markerables can only be appended to markup sections and list item sections',\n          section,\n          section && section.isMarkerable\n        )\n        if (state.text) {\n          this._createMarker()\n        }\n        section.markers.append(marker)\n      },\n      nodeFinished() {\n        isNodeFinished = true\n      },\n    }\n    for (let i = 0; i < this.plugins.length; i++) {\n      let plugin = this.plugins[i]\n      plugin(node, this.builder, env)\n      if (isNodeFinished) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /* eslint-disable complexity */\n  parseNode(node: SectionParserNode) {\n    if (!this.state.section) {\n      this._updateStateFromElement(node)\n    }\n\n    let nodeFinished = this.runPlugins(node)\n    if (nodeFinished) {\n      return\n    }\n\n    // handle closing the current section and starting a new one if we hit a\n    // new-section-creating element.\n    if (this.state.section && isElementNode(node) && node.tagName) {\n      let tagName = normalizeTagName(node.tagName)\n      let isListSection = contains(VALID_LIST_SECTION_TAGNAMES, tagName)\n      let isListItem = contains(VALID_LIST_ITEM_TAGNAMES, tagName)\n      let isMarkupSection = contains(VALID_MARKUP_SECTION_TAGNAMES, tagName)\n      let isNestedListSection = isListSection && this.state.section.isListItem\n      let lastSection = this.sections[this.sections.length - 1]\n\n      // lists can continue after breaking out for a markup section,\n      // in that situation, start a new list using the same list type\n      if (isListItem && sectionIsMarkupSection(this.state.section)) {\n        this._closeCurrentSection()\n        this._updateStateFromElement(node.parentElement!)\n      }\n\n      // we can hit a list item after parsing a nested list, when that happens\n      // and the lists are of different types we need to make sure we switch\n      // the list type back\n      if (isListItem && lastSection && sectionIsListSection(lastSection)) {\n        let parentElement = expect(node.parentElement, 'expected node to have parent element')\n        let parentElementTagName = normalizeTagName(parentElement.tagName)\n        if (parentElementTagName !== lastSection.tagName) {\n          this._closeCurrentSection()\n          this._updateStateFromElement(parentElement)\n        }\n      }\n\n      // if we've broken out of a list due to nested section-level elements we\n      // can hit the next list item without having a list section in the current\n      // state. In this instance we find the parent list node and use it to\n      // re-initialize the state with a new list section\n      if (\n        isListItem &&\n        !(this.state.section.isListItem || this.state.section.isListSection) &&\n        !lastSection.isListSection\n      ) {\n        this._closeCurrentSection()\n        this._updateStateFromElement(node.parentElement!)\n      }\n\n      // if we have consecutive list sections of different types (ul, ol) then\n      // ensure we close the current section and start a new one\n      let isNewListSection =\n        lastSection &&\n        sectionIsListSection(lastSection) &&\n        this.state.section.isListItem &&\n        isListSection &&\n        tagName !== lastSection.tagName\n\n      if (isNewListSection || (isListSection && !isNestedListSection) || isMarkupSection || isListItem) {\n        // don't break out of the list for list items that contain a single <p>.\n        // deals with typical case of <li><p>Text</p></li><li><p>Text</p></li>\n        if (\n          this.state.section.isListItem &&\n          tagName === 'p' &&\n          !node.nextSibling &&\n          contains(\n            VALID_LIST_ITEM_TAGNAMES,\n            normalizeTagName(expect(node.parentElement, 'expected node to have parent element').tagName)\n          )\n        ) {\n          this.parseElementNode(node)\n          return\n        }\n\n        // avoid creating empty paragraphs due to wrapper elements around\n        // section-creating elements\n        if (isMarkerable(this.state.section) && !this.state.text && this.state.section.markers.length === 0) {\n          this.state.section = null\n        } else {\n          this._closeCurrentSection()\n        }\n\n        this._updateStateFromElement(node)\n      }\n\n      if (this.state.section && this.state.section.isListSection) {\n        // ensure the list section is closed and added to the sections list.\n        // _closeCurrentSection handles pushing list items onto the list section\n        this._closeCurrentSection()\n\n        forEach(node.childNodes, node => {\n          this.parseNode(node as SectionParserNode)\n        })\n        return\n      }\n    }\n\n    switch (node.nodeType) {\n      case NODE_TYPES.TEXT:\n        this.parseTextNode(node as Text)\n        break\n      case NODE_TYPES.ELEMENT:\n        this.parseElementNode(node as HTMLElement)\n        break\n    }\n  }\n\n  parseElementNode(element: HTMLElement) {\n    let { state } = this\n    assert('expected markups to be non-null', state.markups)\n\n    const markups = this._markupsFromElement(element)\n    if (markups.length && state.text!.length && isMarkerable(state.section!)) {\n      this._createMarker()\n    }\n    state.markups.push(...markups)\n\n    forEach(element.childNodes, node => {\n      this.parseNode(node as SectionParserNode)\n    })\n\n    if (markups.length && state.text!.length && state.section!.isMarkerable) {\n      // create the marker started for this node\n      this._createMarker()\n    }\n\n    // pop the current markups from the stack\n    state.markups.splice(-markups.length, markups.length)\n  }\n\n  parseTextNode(textNode: Text) {\n    let { state } = this\n    state.text += sanitize(textNode.textContent!)\n  }\n\n  _updateStateFromElement(element: SectionParserNode) {\n    if (isCommentNode(element)) {\n      return\n    }\n\n    let { state } = this\n    state.section = this._createSectionFromElement(element)\n    state.markups = this._markupsFromElement(element)\n    state.text = ''\n  }\n\n  _closeCurrentSection() {\n    let { sections, state } = this\n    let lastSection = sections[sections.length - 1]\n\n    if (!state.section) {\n      return\n    }\n\n    // close a trailing text node if it exists\n    if (state.text!.length && state.section.isMarkerable) {\n      this._createMarker()\n    }\n\n    // push listItems onto the listSection or add a new section\n    if (sectionIsListItem(state.section) && lastSection && sectionIsListSection(lastSection)) {\n      trimSectionText(state.section)\n      lastSection.items.append(state.section)\n    } else {\n      // avoid creating empty markup sections, especially useful for indented source\n      if (\n        isMarkerable(state.section) &&\n        !state.section.text.trim() &&\n        !any(state.section.markers, marker => marker.isAtom)\n      ) {\n        state.section = null\n        state.text = ''\n        return\n      }\n\n      // remove empty list sections before creating a new section\n      if (lastSection && sectionIsListSection(lastSection) && lastSection.items.length === 0) {\n        sections.pop()\n      }\n\n      sections.push(state.section)\n    }\n\n    state.section = null\n    state.text = ''\n  }\n\n  _markupsFromElement(element: HTMLElement | Text) {\n    let { builder } = this\n    let markups: Markup[] = []\n    if (isTextNode(element)) {\n      return markups\n    }\n\n    const tagName = normalizeTagName(element.tagName)\n    if (this._isValidMarkupForElement(tagName, element)) {\n      markups.push(builder.createMarkup(tagName, getAttributes(element)))\n    }\n\n    this._markupsFromElementStyle(element).forEach(markup => markups.push(markup))\n\n    return markups\n  }\n\n  _isValidMarkupForElement(tagName: string, element: HTMLElement) {\n    if (VALID_MARKUP_TAGNAMES.indexOf(tagName) === -1) {\n      return false\n    } else if (tagName === 'b') {\n      // google docs add a <b style=\"font-weight: normal;\"> that should not\n      // create a \"b\" markup\n      return element.style.fontWeight !== 'normal'\n    }\n    return true\n  }\n\n  _markupsFromElementStyle(element: HTMLElement) {\n    let { builder } = this\n    let markups: Markup[] = []\n    let { fontStyle, fontWeight } = element.style\n    if (fontStyle === 'italic') {\n      markups.push(builder.createMarkup('em'))\n    }\n    if (fontWeight === 'bold' || fontWeight === '700') {\n      markups.push(builder.createMarkup('strong'))\n    }\n    return markups\n  }\n\n  _createMarker() {\n    let { state } = this\n    let text = transformHTMLText(state.text!)\n    let marker = this.builder.createMarker(text, state.markups)\n    assertType<Markerable>('expected section to be markerable', state.section, isMarkerable(state.section!))\n    state.section.markers.append(marker)\n    state.text = ''\n  }\n\n  _getSectionDetails(element: HTMLElement | Text) {\n    let sectionType: string,\n      tagName: string,\n      inferredTagName = false\n\n    if (isTextNode(element)) {\n      tagName = DEFAULT_TAG_NAME\n      sectionType = MARKUP_SECTION_TYPE\n      inferredTagName = true\n    } else {\n      tagName = normalizeTagName(element.tagName)\n\n      // blockquote>p is valid html and should be treated as a blockquote section\n      // rather than a plain markup section\n      if (\n        tagName === 'p' &&\n        element.parentElement &&\n        normalizeTagName(element.parentElement.tagName) === 'blockquote'\n      ) {\n        tagName = 'blockquote'\n      }\n\n      if (contains(VALID_LIST_SECTION_TAGNAMES, tagName)) {\n        sectionType = LIST_SECTION_TYPE\n      } else if (contains(VALID_LIST_ITEM_TAGNAMES, tagName)) {\n        sectionType = LIST_ITEM_TYPE\n      } else if (contains(VALID_MARKUP_SECTION_TAGNAMES, tagName)) {\n        sectionType = MARKUP_SECTION_TYPE\n      } else {\n        sectionType = MARKUP_SECTION_TYPE\n        tagName = DEFAULT_TAG_NAME\n        inferredTagName = true\n      }\n    }\n\n    return { sectionType, tagName, inferredTagName }\n  }\n\n  _createSectionFromElement(element: Comment | HTMLElement) {\n    if (isCommentNode(element)) {\n      return\n    }\n\n    let { builder } = this\n    let section: Cloneable<Section>\n    let { tagName, sectionType, inferredTagName } = this._getSectionDetails(element)\n\n    switch (sectionType) {\n      case LIST_SECTION_TYPE:\n        section = builder.createListSection(tagName)\n        break\n      case LIST_ITEM_TYPE:\n        section = builder.createListItem()\n        break\n      case MARKUP_SECTION_TYPE:\n        section = builder.createMarkupSection(tagName)\n        ;(section as MarkupSection)._inferredTagName = inferredTagName\n        break\n      default:\n        assert('Cannot parse section from element', false)\n    }\n\n    return section\n  }\n\n  _isSkippable(element: Node) {\n    return isElementNode(element) && contains(SKIPPABLE_ELEMENT_TAG_NAMES, normalizeTagName(element.tagName))\n  }\n}\n","import { NO_BREAK_SPACE, TAB_CHARACTER, ATOM_CLASS_NAME } from '../renderers/editor-dom'\nimport { MARKUP_SECTION_TYPE, LIST_SECTION_TYPE, LIST_ITEM_TYPE } from '../models/types'\nimport { isTextNode, isElementNode, getAttributes, normalizeTagName } from '../utils/dom-utils'\nimport { any, detect, forEach, Indexable, ForEachable } from '../utils/array-utils'\nimport { TAB } from '../utils/characters'\nimport { ZWNJ } from '../renderers/editor-dom'\nimport SectionParser from '../parsers/section'\nimport Markup from '../models/markup'\nimport Markerable, { isMarkerable } from '../models/_markerable'\nimport PostNodeBuilder from '../models/post-node-builder'\nimport { Dict } from '../utils/types'\nimport Section from '../models/_section'\nimport Post from '../models/post'\nimport { Cloneable } from '../models/_cloneable'\nimport MarkupSection, { hasInferredTagName } from '../models/markup-section'\nimport RenderTree from '../models/render-tree'\nimport { isMarker } from '../models/marker'\nimport { isAtom } from '../models/atom'\nimport RenderNode from '../models/render-node'\nimport Markuperable from '../utils/markuperable'\nimport ListItem from '../models/list-item'\nimport ListSection from '../models/list-section'\n\nconst GOOGLE_DOCS_CONTAINER_ID_REGEX = /^docs-internal-guid/\n\nconst NO_BREAK_SPACE_REGEX = new RegExp(NO_BREAK_SPACE, 'g')\nconst TAB_CHARACTER_REGEX = new RegExp(TAB_CHARACTER, 'g')\n\nexport function transformHTMLText(textContent: string) {\n  let text = textContent\n  text = text.replace(NO_BREAK_SPACE_REGEX, ' ')\n  text = text.replace(TAB_CHARACTER_REGEX, TAB)\n  return text\n}\n\nexport function trimSectionText(section: Section) {\n  if (isMarkerable(section) && section.markers.length) {\n    let { head, tail } = section.markers\n    head!.value = head!.value.replace(/^\\s+/, '')\n    tail!.value = tail!.value.replace(/\\s+$/, '')\n  }\n}\n\nfunction isGoogleDocsContainer(element: Node) {\n  return (\n    isElementNode(element) &&\n    normalizeTagName(element.tagName) === normalizeTagName('b') &&\n    GOOGLE_DOCS_CONTAINER_ID_REGEX.test(element.id)\n  )\n}\n\nfunction detectRootElement(element: HTMLElement) {\n  let childNodes: Indexable<Node> = element.childNodes || []\n  let googleDocsContainer = detect(childNodes, isGoogleDocsContainer)\n\n  if (googleDocsContainer) {\n    return googleDocsContainer\n  } else {\n    return element\n  }\n}\n\nconst TAG_REMAPPING: Dict<string> = {\n  b: 'strong',\n  i: 'em',\n}\n\nfunction remapTagName(tagName: string) {\n  let normalized = normalizeTagName(tagName)\n  let remapped = TAG_REMAPPING[normalized]\n  return remapped || normalized\n}\n\nfunction trim(str: string) {\n  return str.replace(/^\\s+/, '').replace(/\\s+$/, '')\n}\n\nfunction walkMarkerableNodes(parent: Node, callback: (node: Node) => void) {\n  let currentNode: Node | null = parent\n\n  if (isTextNode(currentNode) || (isElementNode(currentNode) && currentNode.classList.contains(ATOM_CLASS_NAME))) {\n    callback(currentNode)\n  } else {\n    currentNode = currentNode.firstChild\n    while (currentNode) {\n      walkMarkerableNodes(currentNode, callback)\n      currentNode = currentNode.nextSibling\n    }\n  }\n}\n\n/**\n * Parses DOM element -> Post\n * @private\n */\nexport default class DOMParser {\n  builder: PostNodeBuilder\n  sectionParser: SectionParser\n\n  constructor(builder: PostNodeBuilder, options = {}) {\n    this.builder = builder\n    this.sectionParser = new SectionParser(this.builder, options)\n  }\n\n  parse(element: HTMLElement) {\n    const post = this.builder.createPost()\n    let rootElement = detectRootElement(element)\n\n    this._eachChildNode(rootElement, child => {\n      let sections = this.parseSections(child as HTMLElement)\n      this.appendSections(post, sections)\n    })\n\n    // trim leading/trailing whitespace of markerable sections to avoid\n    // unnessary whitespace from indented HTML input\n    forEach(post.sections, section => trimSectionText(section))\n\n    return post\n  }\n\n  appendSections(post: Post, sections: ForEachable<Cloneable<Section>>) {\n    forEach(sections, section => this.appendSection(post, section))\n  }\n\n  appendSection(post: Post, section: Cloneable<Section>) {\n    if (\n      section.isBlank ||\n      (isMarkerable(section) && trim(section.text) === '' && !any(section.markers, marker => marker.isAtom))\n    ) {\n      return\n    }\n\n    let lastSection = post.sections.tail\n    if (\n      lastSection &&\n      hasInferredTagName(lastSection) &&\n      hasInferredTagName(section) &&\n      lastSection.tagName === section.tagName\n    ) {\n      lastSection.join(section)\n    } else {\n      post.sections.append(section)\n    }\n  }\n\n  _eachChildNode(element: Node, callback: (element: Node) => void) {\n    let nodes = isTextNode(element) ? [element] : element.childNodes\n    forEach(nodes, node => callback(node))\n  }\n\n  parseSections(element: HTMLElement) {\n    return this.sectionParser.parse(element)\n  }\n\n  // walk up from the textNode until the rootNode, converting each\n  // parentNode into a markup\n  collectMarkups(textNode: Text, rootNode: Node) {\n    let markups: Markup[] = []\n    let currentNode = textNode.parentNode\n    while (currentNode && currentNode !== rootNode) {\n      let markup = this.markupFromNode(currentNode)\n      if (markup) {\n        markups.push(markup)\n      }\n\n      currentNode = currentNode.parentNode\n    }\n    return markups\n  }\n\n  // Turn an element node into a markup\n  markupFromNode(node: Node) {\n    if (isElementNode(node) && Markup.isValidElement(node)) {\n      let tagName = remapTagName(node.tagName)\n      let attributes = getAttributes(node)\n      return this.builder.createMarkup(tagName, attributes)\n    }\n  }\n\n  // FIXME should move to the section parser?\n  // FIXME the `collectMarkups` logic could simplify the section parser?\n  reparseSection(section: Section, renderTree: RenderTree) {\n    switch (section.type) {\n      case LIST_SECTION_TYPE:\n        return this.reparseListSection(section as ListSection, renderTree)\n      case LIST_ITEM_TYPE:\n        return this.reparseListItem(section as ListItem, renderTree)\n      case MARKUP_SECTION_TYPE:\n        return this.reparseMarkupSection(section as MarkupSection, renderTree)\n      default:\n        return // can only parse the above types\n    }\n  }\n\n  reparseMarkupSection(section: MarkupSection, renderTree: RenderTree) {\n    return this._reparseSectionContainingMarkers(section, renderTree)\n  }\n\n  reparseListItem(listItem: ListItem, renderTree: RenderTree) {\n    return this._reparseSectionContainingMarkers(listItem, renderTree)\n  }\n\n  reparseListSection(listSection: ListSection, renderTree: RenderTree) {\n    listSection.items.forEach(li => this.reparseListItem(li, renderTree))\n  }\n\n  _reparseSectionContainingMarkers(section: Markerable, renderTree: RenderTree) {\n    let element = section.renderNode.element!\n    let seenRenderNodes: RenderNode[] = []\n    let previousMarker: Markuperable\n\n    walkMarkerableNodes(element, node => {\n      let marker!: Markuperable\n      let renderNode = renderTree.getElementRenderNode(node)\n      if (renderNode) {\n        if (isMarker(renderNode.postNode!)) {\n          let text = transformHTMLText(node.textContent || '')\n          let markups = this.collectMarkups(node as Text, element)\n          if (text.length) {\n            marker = renderNode.postNode!\n            marker.value = text\n            marker.markups = markups\n          } else {\n            renderNode.scheduleForRemoval()\n          }\n        } else if (isAtom(renderNode.postNode!)) {\n          let { headTextNode, tailTextNode } = renderNode\n          if (headTextNode!.textContent !== ZWNJ) {\n            let value = headTextNode!.textContent!.replace(new RegExp(ZWNJ, 'g'), '')\n            headTextNode!.textContent = ZWNJ\n            if (previousMarker && previousMarker.isMarker) {\n              previousMarker.value += value\n              if (previousMarker.renderNode) {\n                previousMarker.renderNode.markDirty()\n              }\n            } else {\n              let postNode = renderNode.postNode\n              let newMarkups = postNode.markups.slice()\n              let newPreviousMarker = this.builder.createMarker(value, newMarkups)\n              section.markers.insertBefore(newPreviousMarker, postNode)\n\n              let newPreviousRenderNode = renderTree.buildRenderNode(newPreviousMarker)\n              newPreviousRenderNode.markDirty()\n              section.renderNode.markDirty()\n\n              seenRenderNodes.push(newPreviousRenderNode)\n              section.renderNode.childNodes.insertBefore(newPreviousRenderNode, renderNode)\n            }\n          }\n          if (tailTextNode!.textContent !== ZWNJ) {\n            let value = tailTextNode!.textContent!.replace(new RegExp(ZWNJ, 'g'), '')\n            tailTextNode!.textContent = ZWNJ\n\n            if (renderNode.postNode.next && renderNode.postNode.next.isMarker) {\n              let nextMarker = renderNode.postNode.next\n\n              if (nextMarker.renderNode) {\n                let nextValue = nextMarker.renderNode.element!.textContent\n                nextMarker.renderNode.element!.textContent = value + nextValue\n              } else {\n                let nextValue = value + nextMarker.value\n                nextMarker.value = nextValue\n              }\n            } else {\n              let postNode = renderNode.postNode\n              let newMarkups = postNode.markups.slice()\n              let newMarker = this.builder.createMarker(value, newMarkups)\n\n              section.markers.insertAfter(newMarker, postNode)\n\n              let newRenderNode = renderTree.buildRenderNode(newMarker)\n              seenRenderNodes.push(newRenderNode)\n\n              newRenderNode.markDirty()\n              section.renderNode.markDirty()\n\n              section.renderNode.childNodes.insertAfter(newRenderNode, renderNode)\n            }\n          }\n          if (renderNode) {\n            marker = renderNode.postNode\n          }\n        }\n      } else if (isTextNode(node)) {\n        let text = transformHTMLText(node.textContent!)\n        let markups = this.collectMarkups(node, element)\n        marker = this.builder.createMarker(text, markups)\n\n        renderNode = renderTree.buildRenderNode(marker)\n        renderNode.element = node\n        renderNode.markClean()\n        section.renderNode.markDirty()\n\n        let previousRenderNode = previousMarker && previousMarker.renderNode\n        section.markers.insertAfter(marker, previousMarker)\n        section.renderNode.childNodes.insertAfter(renderNode, previousRenderNode!)\n      }\n\n      if (renderNode) {\n        seenRenderNodes.push(renderNode)\n      }\n      previousMarker = marker\n    })\n\n    let renderNode = section.renderNode.childNodes.head\n    while (renderNode) {\n      if (seenRenderNodes.indexOf(renderNode) === -1) {\n        renderNode.scheduleForRemoval()\n      }\n      renderNode = renderNode.next\n    }\n  }\n}\n","import { parseHTML } from '../utils/dom-utils'\nimport assert from '../utils/assert'\nimport DOMParser from './dom'\nimport PostNodeBuilder from '../models/post-node-builder'\nimport Post from '../models/post'\n\nexport default class HTMLParser {\n  builder: PostNodeBuilder\n  options: {}\n\n  constructor(builder: PostNodeBuilder, options = {}) {\n    assert('Must pass builder to HTMLParser', builder)\n    this.builder = builder\n    this.options = options\n  }\n\n  /**\n   * @param {String} html to parse\n   * @return {Post} A post abstract\n   */\n  parse(html: string): Post {\n    let dom = parseHTML(html)\n    let parser = new DOMParser(this.builder, this.options)\n    return parser.parse(dom)\n  }\n}\n","import LinkedItem from '../utils/linked-item'\nimport LinkedList from '../utils/linked-list'\nimport { containsNode } from '../utils/dom-utils'\nimport assert, { unwrap } from '../utils/assert'\nimport RenderTree from './render-tree'\nimport { Option } from '../utils/types'\nimport CardNode from './card-node'\nimport AtomNode from './atom-node'\nimport Section from './_section'\nimport Markuperable from '../utils/markuperable'\nimport { PostNode } from './post-node-builder'\n\nexport default class RenderNode<T extends Node = Node> extends LinkedItem {\n  parent: Option<RenderNode> = null\n  isDirty = true\n  isRemoved = false\n\n  postNode: Option<PostNode>\n  renderTree: Option<RenderTree>\n\n  // RenderNodes for Markers keep track of their markupElement\n  markupElement: Option<Node> = null\n\n  // RenderNodes for Atoms use these properties\n  headTextNode: Option<Text> = null\n  tailTextNode: Option<Text> = null\n  atomNode: Option<AtomNode> = null\n\n  // RenderNodes for cards use this property\n  cardNode: Option<CardNode> = null\n\n  _childNodes: Option<LinkedList<RenderNode>> = null\n  _element: Option<T> = null\n  _cursorElement: Option<Node> = null // blank render nodes need a cursor element\n\n  constructor(postNode: PostNode, renderTree: RenderTree) {\n    super()\n    this.postNode = postNode\n    this.renderTree = renderTree\n  }\n\n  isAttached() {\n    assert('Cannot check if a renderNode is attached without an element.', !!this.element)\n    return containsNode(unwrap(unwrap(this.renderTree).rootElement), this.element)\n  }\n\n  get childNodes(): LinkedList<RenderNode> {\n    if (!this._childNodes) {\n      this._childNodes = new LinkedList({\n        adoptItem: item => (item.parent = this),\n        freeItem: item => item.destroy(),\n      })\n    }\n    return this._childNodes\n  }\n\n  scheduleForRemoval() {\n    this.isRemoved = true\n    if (this.parent) {\n      this.parent.markDirty()\n    }\n  }\n\n  markDirty() {\n    this.isDirty = true\n    if (this.parent) {\n      this.parent.markDirty()\n    }\n  }\n\n  get isRendered() {\n    return !!this.element\n  }\n\n  markClean() {\n    this.isDirty = false\n  }\n\n  get element() {\n    return this._element\n  }\n\n  set element(element) {\n    const currentElement = this._element\n    this._element = element\n\n    if (currentElement) {\n      this.renderTree!.removeElementRenderNode(currentElement)\n    }\n\n    if (element) {\n      this.renderTree!.setElementRenderNode(element, this)\n    }\n  }\n\n  set cursorElement(cursorElement: Node | null) {\n    this._cursorElement = cursorElement\n  }\n\n  get cursorElement() {\n    return this._cursorElement || this.element\n  }\n\n  destroy() {\n    this.element = null\n    this.parent = null\n    this.postNode = null\n    this.renderTree = null\n  }\n\n  reparsesMutationOfChildNode(node: Node) {\n    if ((this.postNode as Section).isCardSection) {\n      return !containsNode(this.cardNode!.element, node)\n    } else if ((this.postNode as Markuperable).isAtom) {\n      return !containsNode(this.atomNode!.element, node)\n    }\n    return true\n  }\n}\n","import assert from './assert'\n\n// start at one to make the falsy semantics easier\nlet uuidGenerator = 1\n\ninterface ElementKey {\n  _uuid?: string\n}\n\nexport default class ElementMap<T> {\n  _map: {\n    [key: string]: T\n  } = {}\n\n  set(key: object, value: T) {\n    let uuid = (key as ElementKey)._uuid\n    if (!uuid) {\n      ;(key as ElementKey)._uuid = uuid = '' + uuidGenerator++\n    }\n    this._map[uuid] = value\n  }\n\n  get(key: object) {\n    if ((key as ElementKey)._uuid) {\n      return this._map[(key as ElementKey)._uuid!]\n    }\n    return null\n  }\n\n  remove(key: object) {\n    assertHasUuid(key)\n    delete this._map[key._uuid]\n  }\n}\n\nfunction assertHasUuid(key: ElementKey): asserts key is { _uuid: string } {\n  assert('tried to fetch a value for an element not seen before', !!key._uuid)\n}\n","import RenderNode from '../models/render-node'\nimport ElementMap from '../utils/element-map'\nimport { PostNode } from './post-node-builder'\nimport Post from './post'\n\nexport default class RenderTree {\n  _rootNode: RenderNode\n  _elements: ElementMap<RenderNode>\n\n  constructor(rootPostNode: Post) {\n    this._rootNode = this.buildRenderNode(rootPostNode)\n    this._elements = new ElementMap()\n  }\n  /*\n   * @return {RenderNode} The root render node in this tree\n   */\n  get rootNode() {\n    return this._rootNode\n  }\n  /**\n   * @return {Boolean}\n   */\n  get isDirty(): boolean {\n    return this.rootNode && this.rootNode.isDirty\n  }\n  /*\n   * @return {DOMNode} The root DOM element in this tree\n   */\n  get rootElement() {\n    return this.rootNode.element\n  }\n  /*\n   * @param {DOMNode} element\n   * @return {RenderNode} The renderNode for this element, if any\n   */\n  getElementRenderNode(element: Node) {\n    return this._elements.get(element)\n  }\n  setElementRenderNode(element: Node, renderNode: RenderNode) {\n    this._elements.set(element, renderNode)\n  }\n  removeElementRenderNode(element: Node) {\n    this._elements.remove(element)\n  }\n  /**\n   * @param {DOMNode} element\n   * Walk up from the dom element until we find a renderNode element\n   */\n  findRenderNodeFromElement(element: Node, conditionFn: (node: RenderNode) => boolean = () => true) {\n    let renderNode: RenderNode | null\n    let _element: Node | null = element\n\n    while (_element) {\n      renderNode = this.getElementRenderNode(_element)\n      if (renderNode && conditionFn(renderNode)) {\n        return renderNode\n      }\n\n      // continue loop\n      _element = _element.parentElement\n\n      // stop if we are at the root element\n      if (_element === this.rootElement) {\n        if (conditionFn(this.rootNode)) {\n          return this.rootNode\n        } else {\n          return\n        }\n      }\n    }\n  }\n\n  buildRenderNode(postNode: PostNode) {\n    const renderNode = new RenderNode(postNode, this)\n    postNode.renderNode = renderNode\n    return renderNode\n  }\n}\n","import MobiledocRenderer_0_2, { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_2, MobiledocV0_2 } from './0-2'\nimport MobiledocRenderer_0_3, { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_3, MobiledocV0_3 } from './0-3'\nimport MobiledocRenderer_0_3_1, { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_3_1, MobiledocV0_3_1 } from './0-3-1'\nimport MobiledocRenderer_0_3_2, { MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_3_2, MobiledocV0_3_2 } from './0-3-2'\nimport assert from '../../utils/assert'\nimport Post from '../../models/post'\n\nexport type Mobiledoc = MobiledocV0_2 | MobiledocV0_3 | MobiledocV0_3_1 | MobiledocV0_3_2\nexport const MOBILEDOC_VERSION = MOBILEDOC_VERSION_0_3_2\n\ninterface VersionTypes {\n  [MOBILEDOC_VERSION_0_2]: MobiledocV0_2\n  [MOBILEDOC_VERSION_0_3]: MobiledocV0_3\n  [MOBILEDOC_VERSION_0_3_1]: MobiledocV0_3_1\n  [MOBILEDOC_VERSION_0_3_2]: MobiledocV0_3_2\n}\n\nexport type MobiledocVersion = keyof VersionTypes\n\nexport default {\n  render(post: Post, version: keyof VersionTypes = MOBILEDOC_VERSION_0_3_2): VersionTypes[typeof version] {\n    switch (version) {\n      case MOBILEDOC_VERSION_0_2:\n        return MobiledocRenderer_0_2.render(post)\n      case MOBILEDOC_VERSION_0_3:\n        return MobiledocRenderer_0_3.render(post)\n      case MOBILEDOC_VERSION_0_3_1:\n        return MobiledocRenderer_0_3_1.render(post)\n      case undefined:\n      case null:\n      case MOBILEDOC_VERSION_0_3_2:\n        return MobiledocRenderer_0_3_2.render(post)\n      default:\n        assert(`Unknown version of mobiledoc renderer requested: ${version}`, false)\n    }\n  },\n}\n","function mergeWithOptions<A, B, O>(original: A, updates: B, options?: O) {\n  return Object.assign(original, updates, options)\n}\n\n/**\n * Merges properties of one object into another\n * @private\n */\nfunction merge<A, B>(original: A, updates: B) {\n  return mergeWithOptions(original, updates)\n}\n\nexport { mergeWithOptions, merge }\n","export default {\n  hasDOM() {\n    return typeof document !== 'undefined'\n  },\n}\n","import Section from './_section'\n\nexport type Cloneable<T> = T & {\n  clone(): Cloneable<T>\n}\n\nexport function expectCloneable<T extends Section>(section: T): Cloneable<T> {\n  if (!('clone' in section)) {\n    throw new Error('Expected section to be cloneable')\n  }\n\n  return section as Cloneable<T>\n}\n","import { Type } from './types'\nimport LinkedList from '../utils/linked-list'\nimport { forEach } from '../utils/array-utils'\nimport { Option } from '../utils/types'\nimport Set from '../utils/set'\nimport Position from '../utils/cursor/position'\nimport Range from '../utils/cursor/range'\nimport assert from '../utils/assert'\nimport Markerable, { isMarkerable } from './_markerable'\nimport Section, { isNested } from './_section'\nimport PostNodeBuilder from './post-node-builder'\nimport ListSection, { isListSection } from './list-section'\nimport ListItem, { isListItem } from './list-item'\nimport MarkupSection from './markup-section'\nimport RenderNode from './render-node'\nimport HasChildSections from './_has-child-sections'\nimport { expectCloneable, Cloneable } from './_cloneable'\nimport Markuperable from '../utils/markuperable'\nimport Markup from './markup'\n\ntype SectionCallback = (section: Section, index: number) => void\n\n/**\n * The Post is an in-memory representation of an editor's document.\n * An editor always has a single post. The post is organized into a list of\n * sections. Each section may be markerable (contains \"markers\", aka editable\n * text) or non-markerable (e.g., a card).\n * When persisting a post, it must first be serialized (loss-lessly) into\n * mobiledoc using {@link Editor#serialize}.\n */\nexport default class Post implements HasChildSections<Cloneable<Section>> {\n  type = Type.POST\n  builder!: PostNodeBuilder\n  sections: LinkedList<Cloneable<Section>>\n  renderNode!: RenderNode\n\n  constructor() {\n    this.sections = new LinkedList({\n      adoptItem: s => (s.post = s._parent = this),\n      freeItem: s => (s.post = s._parent = null),\n    })\n  }\n  /**\n   * @return {Position} The position at the start of the post (will be a {@link BlankPosition}\n   * if the post is blank)\n   * @public\n   */\n  headPosition(): Position {\n    if (this.isBlank) {\n      return Position.blankPosition()\n    } else {\n      return this.sections.head!.headPosition()\n    }\n  }\n\n  /**\n   * @return {Position} The position at the end of the post (will be a {@link BlankPosition}\n   * if the post is blank)\n   * @public\n   */\n  tailPosition(): Position {\n    if (this.isBlank) {\n      return Position.blankPosition()\n    } else {\n      return this.sections.tail!.tailPosition()\n    }\n  }\n\n  /**\n   * @return {Range} A range encompassing the entire post\n   * @public\n   */\n  toRange(): Range {\n    return this.headPosition().toRange(this.tailPosition())\n  }\n\n  get isBlank() {\n    return this.sections.isEmpty\n  }\n\n  /**\n   * If the post has no sections, or only has one, blank section, then it does\n   * not have content and this method returns false. Otherwise it is true.\n   * @return {Boolean}\n   * @public\n   */\n  get hasContent(): boolean {\n    if (this.sections.length > 1 || (this.sections.length === 1 && !this.sections.head!.isBlank)) {\n      return true\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * @param {Range} range\n   * @return {Array} markers that are completely contained by the range\n   */\n  markersContainedByRange(range: Range): Array<any> {\n    const markers: Markuperable[] = []\n\n    this.walkMarkerableSections(range, (section: Markerable) => {\n      section._markersInRange(range.trimTo(section), (m, { isContained }) => {\n        if (isContained) {\n          markers.push(m)\n        }\n      })\n    })\n\n    return markers\n  }\n\n  markupsInRange(range: Range) {\n    const markups = new Set<Markup>()\n\n    if (range.isCollapsed) {\n      let pos = range.head\n      if (pos.isMarkerable) {\n        let [back, forward] = [pos.markerIn(-1), pos.markerIn(1)]\n        if (back && forward && back === forward) {\n          back.markups.forEach(m => markups.add(m))\n        } else {\n          ;((back && back.markups) || []).forEach(m => {\n            if (m.isForwardInclusive()) {\n              markups.add(m)\n            }\n          })\n          ;((forward && forward.markups) || []).forEach(m => {\n            if (m.isBackwardInclusive()) {\n              markups.add(m)\n            }\n          })\n        }\n      }\n    } else {\n      this.walkMarkerableSections(range, section => {\n        forEach(section.markupsInRange(range.trimTo(section)), m => markups.add(m))\n      })\n    }\n\n    return markups.toArray()\n  }\n\n  walkAllLeafSections(callback: SectionCallback) {\n    let range = this.headPosition().toRange(this.tailPosition())\n    return this.walkLeafSections(range, callback)\n  }\n\n  walkLeafSections(range: Range, callback: SectionCallback) {\n    const { head, tail } = range\n\n    let index = 0\n    let nextSection: Option<Section>\n    let shouldStop: boolean\n    let currentSection = head.section\n\n    while (currentSection) {\n      nextSection = this._nextLeafSection(currentSection)\n      shouldStop = currentSection === tail.section\n\n      callback(currentSection, index)\n      index++\n\n      if (shouldStop) {\n        break\n      } else {\n        currentSection = nextSection\n      }\n    }\n  }\n\n  walkMarkerableSections(range: Range, callback: (section: Markerable) => void) {\n    this.walkLeafSections(range, section => {\n      if (isMarkerable(section)) {\n        callback(section)\n      }\n    })\n  }\n\n  // return the next section that has markers after this one,\n  // possibly skipping non-markerable sections\n  _nextLeafSection(section: Section): Option<Section> {\n    if (!section) {\n      return null\n    }\n\n    const next = section.next\n    if (next) {\n      if (next.isLeafSection) {\n        return next\n      } else if (isListSection(next)) {\n        return next.items.head\n      } else {\n        assert('Cannot determine next section from non-leaf-section', false)\n      }\n    } else if (isNested(section)) {\n      // if there is no section after this, but this section is a child\n      // (e.g. a ListItem inside a ListSection), check for a markerable\n      // section after its parent\n      return this._nextLeafSection(section.parent)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * @param {Range} range\n   * @return {Post} A new post, constrained to {range}\n   */\n  trimTo(range: Range): Post {\n    const { builder } = this\n    const post = builder.createPost()\n    const { head, tail } = range\n    const tailNotSelected = tail.offset === 0 && head.section !== tail.section\n\n    let sectionParent: Post | null = post,\n      listParent: ListSection | null = null\n\n    this.walkLeafSections(range, section => {\n      let newSection: ListItem | MarkupSection | Cloneable<Section>\n      if (isMarkerable(section)) {\n        if (isListItem(section)) {\n          if (listParent) {\n            sectionParent = null\n          } else {\n            listParent = builder.createListSection(section.parent.tagName)\n            post.sections.append(listParent)\n            sectionParent = null\n          }\n          newSection = builder.createListItem()\n          listParent.items.append(newSection as ListItem)\n        } else {\n          listParent = null\n          sectionParent = post\n          const tagName = tailNotSelected && tail.section === section ? 'p' : section.tagName\n          newSection = builder.createMarkupSection(tagName)\n        }\n\n        let currentRange = range.trimTo(section)\n        forEach(section.markersFor(currentRange.headSectionOffset, currentRange.tailSectionOffset), m =>\n          (newSection as MarkupSection | ListItem).markers.append(m)\n        )\n      } else {\n        newSection =\n          tailNotSelected && tail.section === section\n            ? builder.createMarkupSection('p')\n            : expectCloneable(section).clone()\n\n        sectionParent = post\n      }\n      if (sectionParent) {\n        sectionParent.sections.append(newSection)\n      }\n    })\n    return post\n  }\n}\n","import { Type } from './types'\nimport Section from './_section'\nimport { Option } from '../utils/types'\n\nexport default class Image extends Section {\n  src: Option<string> = null\n\n  constructor() {\n    super(Type.IMAGE_SECTION)\n  }\n\n  clone() {\n    return this.builder.createImageSection(this.src!)\n  }\n\n  canJoin() {\n    return false\n  }\n\n  get length() {\n    return 1\n  }\n}\n","import Atom, { AtomPayload } from './atom'\nimport Post from './post'\nimport MarkupSection from './markup-section'\nimport ListSection from './list-section'\nimport ListItem from './list-item'\nimport ImageSection from './image'\nimport Marker from './marker'\nimport Markup from './markup'\nimport Card, { CardPayload } from './card'\n\nimport { LIST_ITEM_TYPE, MARKUP_SECTION_TYPE, Type } from './types'\nimport { DEFAULT_TAG_NAME as DEFAULT_MARKUP_SECTION_TAG_NAME } from './markup-section'\nimport { DEFAULT_TAG_NAME as DEFAULT_LIST_SECTION_TAG_NAME } from './list-section'\n\nimport { normalizeTagName } from '../utils/dom-utils'\nimport { objectToSortedKVArray } from '../utils/array-utils'\nimport assert from '../utils/assert'\nimport Markuperable from '../utils/markuperable'\nimport Section from './_section'\nimport { Cloneable } from './_cloneable'\nimport { Dict } from '../utils/types'\n\nfunction cacheKey(tagName: string, attributes: Dict<string>) {\n  return `${normalizeTagName(tagName)}-${objectToSortedKVArray(attributes).join('-')}`\n}\n\nfunction addMarkupToCache(cache: Dict<Markup>, markup: Markup) {\n  cache[cacheKey(markup.tagName, markup.attributes)] = markup\n}\n\nfunction findMarkupInCache(cache: Dict<Markup>, tagName: string, attributes: Dict<string>) {\n  const key = cacheKey(tagName, attributes)\n  return cache[key]\n}\n\n/**\n * The PostNodeBuilder is used to create new {@link Post} primitives, such\n * as a MarkupSection, a CardSection, a Markup, etc. Every instance of an\n * {@link Editor} has its own builder instance. The builder can be used\n * inside an {@link Editor#run} callback to programmatically create new\n * Post primitives to insert into the document.\n * A PostNodeBuilder should be read from the Editor, *not* instantiated on its own.\n */\nexport default class PostNodeBuilder {\n  markupCache: Dict<Markup> = {}\n\n  /**\n   * @return {Post} A new, blank post\n   */\n  createPost(sections: Cloneable<Section>[] = []): Post {\n    const post = new Post()\n    post.builder = this\n\n    sections.forEach(s => post.sections.append(s))\n\n    return post\n  }\n\n  createMarkerableSection(type: Type.LIST_ITEM, tagName: string, markers: Markuperable[]): ListItem\n  createMarkerableSection(type: Type.MARKUP_SECTION, tagName: string, markers: Markuperable[]): MarkupSection\n  createMarkerableSection(\n    type: Exclude<Type, Type.LIST_ITEM & Type.MARKUP_SECTION>,\n    tagName: string,\n    markers: Markuperable[]\n  ): never\n  createMarkerableSection(type: Type, tagName: string, markers: Markuperable[] = []) {\n    switch (type) {\n      case LIST_ITEM_TYPE:\n        return this.createListItem(markers)\n      case MARKUP_SECTION_TYPE:\n        return this.createMarkupSection(tagName, markers)\n      default:\n        assert(`Cannot create markerable section of type ${type}`, false)\n    }\n  }\n\n  /**\n   * @param {tagName} [tagName='P']\n   * @param {Marker[]} [markers=[]]\n   * @return {MarkupSection}\n   */\n  createMarkupSection(\n    tagName: string = DEFAULT_MARKUP_SECTION_TAG_NAME,\n    markers: Markuperable[] = [],\n    isGenerated = false,\n    attributes = {}\n  ): MarkupSection {\n    tagName = normalizeTagName(tagName)\n    const section = new MarkupSection(tagName, markers, attributes)\n    if (isGenerated) {\n      section.isGenerated = true\n    }\n    section.builder = this\n    return section\n  }\n\n  createListSection(tagName = DEFAULT_LIST_SECTION_TAG_NAME, items: ListItem[] = [], attributes = {}) {\n    tagName = normalizeTagName(tagName)\n    const section = new ListSection(tagName, items, attributes)\n    section.builder = this\n    return section\n  }\n\n  createListItem(markers: Markuperable[] = []) {\n    const tagName = normalizeTagName('li')\n    const item = new ListItem(tagName, markers)\n    item.builder = this\n    return item\n  }\n\n  createImageSection(url: string) {\n    let section = new ImageSection()\n    if (url) {\n      section.src = url\n    }\n    section.builder = this\n    return section\n  }\n\n  /**\n   * @param {String} name\n   * @param {Object} [payload={}]\n   * @return {CardSection}\n   */\n  createCardSection(name: string, payload: CardPayload = {}): Card {\n    const card = new Card(name, payload)\n    card.builder = this\n    return card\n  }\n\n  /**\n   * @param {String} value\n   * @param {Markup[]} [markups=[]]\n   * @return {Marker}\n   */\n  createMarker(value?: string, markups: Markup[] = []): Marker {\n    const marker = new Marker(value, markups)\n    marker.builder = this\n    return marker\n  }\n\n  /**\n   * @param {String} name\n   * @param {String} [value='']\n   * @param {Object} [payload={}]\n   * @param {Markup[]} [markups=[]]\n   * @return {Atom}\n   */\n  createAtom(name: string, value: string = '', payload: AtomPayload = {}, markups: Markup[] = []): Atom {\n    const atom = new Atom(name, value, payload, markups)\n    atom.builder = this\n    return atom\n  }\n\n  /**\n   * @param {String} tagName\n   * @param {Object} attributes Key-value pairs of attributes for the markup\n   * @return {Markup}\n   */\n  createMarkup(tagName: string, attributes: Dict<string> = {}): Markup {\n    tagName = normalizeTagName(tagName)\n\n    let markup = findMarkupInCache(this.markupCache, tagName, attributes)\n    if (!markup) {\n      markup = new Markup(tagName, attributes)\n      markup.builder = this\n      addMarkupToCache(this.markupCache, markup)\n    }\n\n    return markup\n  }\n}\n\nexport type PostNode = Post | Section | Markuperable | Marker\n","import Editor from './editor'\nimport { TextInputHandlerListener } from './text-input-handler'\n\n/**\n * Convert section at the editor's cursor position into a list.\n * Does nothing if the cursor position is not at the start of the section,\n * or if the section is already a list item.\n *\n * @param {Editor} editor\n * @param {String} listTagName (\"ul\" or \"ol\")\n * @public\n */\nexport function replaceWithListSection(editor: Editor, listTagName: string) {\n  const { range } = editor\n  const { head } = range\n  const { section } = head\n\n  // Skip if cursor is not at end of section\n  if (!head.isTail()) {\n    return\n  }\n\n  if (section!.isListItem) {\n    return\n  }\n\n  editor.run(postEditor => {\n    let { builder } = postEditor\n    let item = builder.createListItem()\n    let listSection = builder.createListSection(listTagName, [item])\n\n    postEditor.replaceSection(section!, listSection)\n    postEditor.setRange(listSection.headPosition())\n  })\n}\n\n/**\n * Convert section at the editor's cursor position into a header section.\n * Does nothing if the cursor position is not at the start of the section.\n *\n * @param {Editor} editor\n * @param {String} headingTagName ('h1', 'h2', 'h3', 'h4', 'h5', 'h6')\n * @public\n */\nexport function replaceWithHeaderSection(editor: Editor, headingTagName: string) {\n  let {\n    range: {\n      head,\n      head: { section },\n    },\n  } = editor\n\n  // Skip if cursor is not at end of section\n  if (!head.isTail()) {\n    return\n  }\n\n  editor.run(postEditor => {\n    let { builder } = postEditor\n    let newSection = builder.createMarkupSection(headingTagName)\n    postEditor.replaceSection(section!, newSection)\n    postEditor.setRange(newSection.headPosition())\n  })\n}\n\nexport const DEFAULT_TEXT_INPUT_HANDLERS: TextInputHandlerListener[] = [\n  {\n    name: 'ul',\n    // \"* \" -> ul\n    match: /^\\* $/,\n    run(editor) {\n      replaceWithListSection(editor, 'ul')\n    },\n  },\n  {\n    name: 'ol',\n    // \"1\" -> ol, \"1.\" -> ol\n    match: /^1\\.? $/,\n    run(editor) {\n      replaceWithListSection(editor, 'ol')\n    },\n  },\n  {\n    name: 'heading',\n    /*\n     * \"# \" -> h1\n     * \"## \" -> h2\n     * \"### \" -> h3\n     * \"#### \" -> h4\n     * \"##### \" -> h5\n     * \"###### \" -> h6\n     */\n    match: /^(#{1,6}) $/,\n    run(editor, matches) {\n      let capture = matches[1]\n      let headingTag = 'h' + capture.length\n      replaceWithHeaderSection(editor, headingTag)\n    },\n  },\n]\n","export default {\n  isMac() {\n    return typeof window !== 'undefined' && window.navigator && /Mac/.test(window.navigator.platform)\n  },\n  isWin() {\n    return typeof window !== 'undefined' && window.navigator && /Win/.test(window.navigator.platform)\n  },\n  isChrome() {\n    return typeof window !== 'undefined' && 'chrome' in window\n  },\n}\n","import Key from '../utils/key'\nimport { MODIFIERS, specialCharacterToCode } from '../utils/key'\nimport { filter, reduce } from '../utils/array-utils'\nimport assert from '../utils/assert'\nimport Browser from '../utils/browser'\nimport { toggleLink } from './ui'\nimport Editor from './editor'\n\nfunction selectAll(editor: Editor) {\n  let { post } = editor\n  editor.selectRange(post.toRange())\n}\n\nfunction gotoStartOfLine(editor: Editor) {\n  let { range } = editor\n  let {\n    tail: { section },\n  } = range\n  editor.run(postEditor => {\n    postEditor.setRange(section!.headPosition())\n  })\n}\n\nfunction gotoEndOfLine(editor: Editor) {\n  let { range } = editor\n  let {\n    tail: { section },\n  } = range\n  editor.run(postEditor => {\n    postEditor.setRange(section!.tailPosition())\n  })\n}\n\nfunction deleteToEndOfSection(editor: Editor) {\n  let { range } = editor\n  if (range.isCollapsed) {\n    let {\n      head,\n      head: { section },\n    } = range\n    range = head.toRange(section!.tailPosition())\n  }\n  editor.run(postEditor => {\n    let nextPosition = postEditor.deleteRange(range)\n    postEditor.setRange(nextPosition)\n  })\n}\n\nexport const DEFAULT_KEY_COMMANDS: KeyCommand[] = [\n  {\n    str: 'META+B',\n    run(editor) {\n      editor.toggleMarkup('strong')\n    },\n  },\n  {\n    str: 'CTRL+B',\n    run(editor) {\n      editor.toggleMarkup('strong')\n    },\n  },\n  {\n    str: 'META+I',\n    run(editor) {\n      editor.toggleMarkup('em')\n    },\n  },\n  {\n    str: 'CTRL+I',\n    run(editor) {\n      editor.toggleMarkup('em')\n    },\n  },\n  {\n    str: 'META+U',\n    run(editor) {\n      editor.toggleMarkup('u')\n    },\n  },\n  {\n    str: 'CTRL+U',\n    run(editor) {\n      editor.toggleMarkup('u')\n    },\n  },\n  {\n    str: 'CTRL+K',\n    run(editor) {\n      if (Browser.isMac()) {\n        return deleteToEndOfSection(editor)\n      } else if (Browser.isWin()) {\n        return toggleLink(editor)\n      }\n    },\n  },\n  {\n    str: 'CTRL+A',\n    run(editor) {\n      if (Browser.isMac()) {\n        gotoStartOfLine(editor)\n      } else {\n        selectAll(editor)\n      }\n    },\n  },\n  {\n    str: 'META+A',\n    run(editor) {\n      if (Browser.isMac()) {\n        selectAll(editor)\n      }\n    },\n  },\n  {\n    str: 'CTRL+E',\n    run(editor) {\n      if (Browser.isMac()) {\n        gotoEndOfLine(editor)\n      }\n    },\n  },\n  {\n    str: 'META+K',\n    run(editor) {\n      return toggleLink(editor)\n    },\n  },\n  {\n    str: 'META+Z',\n    run(editor) {\n      editor.run(postEditor => {\n        postEditor.undoLastChange()\n      })\n    },\n  },\n  {\n    str: 'META+SHIFT+Z',\n    run(editor) {\n      editor.run(postEditor => {\n        postEditor.redoLastChange()\n      })\n    },\n  },\n  {\n    str: 'CTRL+Z',\n    run(editor) {\n      if (Browser.isMac()) {\n        return false\n      }\n      editor.run(postEditor => postEditor.undoLastChange())\n    },\n  },\n  {\n    str: 'CTRL+SHIFT+Z',\n    run(editor) {\n      if (Browser.isMac()) {\n        return false\n      }\n      editor.run(postEditor => postEditor.redoLastChange())\n    },\n  },\n]\n\nfunction modifierNamesToMask(modiferNames: string[]) {\n  let defaultVal = 0\n  return reduce(\n    modiferNames,\n    (sum, name) => {\n      let modifier = MODIFIERS[name.toUpperCase()]\n      assert(`No modifier named \"${name}\" found`, !!modifier)\n      return sum + modifier\n    },\n    defaultVal\n  )\n}\n\nfunction characterToCode(character: string) {\n  const upperCharacter = character.toUpperCase()\n  const special = specialCharacterToCode(upperCharacter)\n  if (special) {\n    return special\n  } else {\n    assert(`Only 1 character can be used in a key command str (got \"${character}\")`, character.length === 1)\n    return upperCharacter.charCodeAt(0)\n  }\n}\n\nexport interface KeyCommand {\n  name?: string\n  str: string\n  run(editor: Editor): boolean | void\n  /** @internal */\n  modifier?: string\n}\n\nexport interface CompiledKeyCommand {\n  name?: string\n  run(editor: Editor): boolean | void\n  /** @internal */\n  modifier?: string\n  modifierMask: number\n  code: number\n}\n\nexport function buildKeyCommand(keyCommand: CompiledKeyCommand | KeyCommand): CompiledKeyCommand {\n  if (isCompiledKeyCommand(keyCommand)) {\n    return keyCommand\n  }\n\n  assert('[deprecation] Key commands no longer use the `modifier` property', !keyCommand.modifier)\n\n  let { str, run, name } = keyCommand\n\n  let [character, ...modifierNames] = str.split('+').reverse()\n\n  return {\n    name,\n    run,\n    modifierMask: modifierNamesToMask(modifierNames),\n    code: characterToCode(character),\n  }\n}\n\nfunction isCompiledKeyCommand(keyCommand: CompiledKeyCommand | KeyCommand): keyCommand is CompiledKeyCommand {\n  return (keyCommand as KeyCommand).str === undefined\n}\n\nexport function validateKeyCommand(keyCommand: CompiledKeyCommand) {\n  return !!keyCommand.code && !!keyCommand.run\n}\n\nexport function findKeyCommands(keyCommands: CompiledKeyCommand[], keyEvent: KeyboardEvent) {\n  const key = Key.fromEvent(keyEvent)\n\n  return filter(keyCommands, ({ modifierMask, code }) => {\n    return key.keyCode === code && key.modifierMask === modifierMask\n  })\n}\n","import Set from '../utils/set'\nimport { forEach, filter } from '../utils/array-utils'\nimport assert from '../utils/assert'\nimport { containsNode } from '../utils/dom-utils'\nimport { Option } from '../utils/types'\nimport Editor from './editor'\nimport { Logger } from '../utils/log-manager'\nimport RenderTree from '../models/render-tree'\nimport Section from '../models/_section'\nimport RenderNode from '../models/render-node'\n\nconst enum MutationType {\n  NODES_CHANGED = 'childList',\n  CHARACTER_DATA = 'characterData',\n}\n\nexport default class MutationHandler {\n  editor: Editor\n  logger: Logger\n  renderTree: Option<RenderTree>\n\n  _isObserving: boolean\n  _observer: Option<MutationObserver>\n\n  constructor(editor: Editor) {\n    this.editor = editor\n    this.logger = editor.loggerFor('mutation-handler')\n    this.renderTree = null\n    this._isObserving = false\n\n    this._observer = new MutationObserver(mutations => {\n      this._handleMutations(mutations)\n    })\n  }\n\n  init() {\n    this.startObserving()\n  }\n\n  destroy() {\n    this.stopObserving()\n    this._observer = null\n  }\n\n  suspendObservation(callback: () => void) {\n    this.stopObserving()\n    callback()\n    this.startObserving()\n  }\n\n  stopObserving() {\n    if (this._isObserving) {\n      this._isObserving = false\n      this._observer!.disconnect()\n    }\n  }\n\n  startObserving() {\n    if (!this._isObserving) {\n      let { editor } = this\n      assert('Cannot observe un-rendered editor', editor.hasRendered)\n\n      this._isObserving = true\n      this.renderTree = editor._renderTree\n\n      this._observer!.observe(editor.element, {\n        characterData: true,\n        childList: true,\n        subtree: true,\n      })\n    }\n  }\n\n  reparsePost() {\n    this.editor._reparsePost()\n  }\n\n  reparseSections(sections: Section[]) {\n    this.editor._reparseSections(sections)\n  }\n\n  /**\n   * for each mutation:\n   *   * find the target nodes:\n   *     * if nodes changed, target nodes are:\n   *        * added nodes\n   *        * the target from which removed nodes were removed\n   *     * if character data changed\n   *       * target node is the mutation event's target (text node)\n   *     * filter out nodes that are no longer attached (parentNode is null)\n   *   * for each remaining node:\n   *   *  find its section, add to sections-to-reparse\n   *   *  if no section, reparse all (and break)\n   */\n  _handleMutations(mutations: MutationRecord[]) {\n    let reparsePost = false\n    let sections = new Set<Section>()\n\n    for (let i = 0; i < mutations.length; i++) {\n      if (reparsePost) {\n        break\n      }\n\n      let nodes = this._findTargetNodes(mutations[i])\n\n      for (let j = 0; j < nodes.length; j++) {\n        let node = nodes[j]\n        let renderNode = this._findRenderNodeFromNode(node)\n        if (renderNode) {\n          if (renderNode.reparsesMutationOfChildNode(node)) {\n            let section = this._findSectionFromRenderNode(renderNode)\n            if (section) {\n              sections.add(section)\n            } else {\n              reparsePost = true\n            }\n          }\n        } else {\n          reparsePost = true\n          break\n        }\n      }\n    }\n\n    if (reparsePost) {\n      this.logger.log(`reparsePost (${mutations.length} mutations)`)\n      this.reparsePost()\n    } else if (sections.length) {\n      this.logger.log(`reparse ${sections.length} sections (${mutations.length} mutations)`)\n      this.reparseSections(sections.toArray())\n    }\n  }\n\n  _findTargetNodes(mutation: MutationRecord) {\n    let nodes: Node[] = []\n\n    switch (mutation.type) {\n      case MutationType.CHARACTER_DATA:\n        nodes.push(mutation.target)\n        break\n      case MutationType.NODES_CHANGED:\n        forEach(mutation.addedNodes, n => nodes.push(n))\n        if (mutation.removedNodes.length) {\n          nodes.push(mutation.target)\n        }\n        break\n    }\n\n    let element = this.editor.element\n    let attachedNodes = filter(nodes, node => containsNode(element, node))\n    return attachedNodes\n  }\n\n  _findSectionRenderNodeFromNode(node: Node) {\n    return this.renderTree!.findRenderNodeFromElement(node, rn => {\n      return (rn.postNode! as Section).isSection\n    })\n  }\n\n  _findRenderNodeFromNode(node: Node) {\n    return this.renderTree!.findRenderNodeFromElement(node)\n  }\n\n  _findSectionFromRenderNode(renderNode: RenderNode) {\n    let sectionRenderNode = this._findSectionRenderNodeFromNode(renderNode.element!)\n    return sectionRenderNode && (sectionRenderNode.postNode as Section)\n  }\n}\n","export default class FixedQueue<T> {\n  _maxLength: number\n  _items: T[]\n\n  constructor(length = 0) {\n    this._maxLength = length\n    this._items = []\n  }\n\n  get length() {\n    return this._items.length\n  }\n\n  pop() {\n    return this._items.pop()\n  }\n\n  push(item: T) {\n    this._items.push(item)\n    if (this.length > this._maxLength) {\n      this._items.shift()\n    }\n  }\n\n  clear() {\n    this._items = []\n  }\n\n  toArray() {\n    return this._items\n  }\n}\n","import Post from '../models/post'\nimport Section from '../models/_section'\nimport mobiledocParsers from '../parsers/mobiledoc'\nimport FixedQueue from '../utils/fixed-queue'\nimport { Option } from '../utils/types'\nimport Editor from './editor'\nimport PostEditor, { EditAction } from './post'\nimport { Mobiledoc } from '../renderers/mobiledoc'\n\nfunction findLeafSectionAtIndex(post: Post, index: number) {\n  let section: Section\n\n  post.walkAllLeafSections((_section, _index) => {\n    if (index === _index) {\n      section = _section\n    }\n  })\n  return section!\n}\n\nexport class Snapshot {\n  takenAt: number\n  editor: Editor\n  editAction: Option<EditAction>\n  mobiledoc: Mobiledoc\n  range!: {\n    head: [number, number]\n    tail: [number, number]\n  }\n\n  constructor(takenAt: number, editor: Editor, editAction: Option<EditAction> = null) {\n    this.mobiledoc = editor.serialize()\n    this.editor = editor\n    this.editAction = editAction\n    this.takenAt = takenAt\n\n    this.snapshotRange()\n  }\n\n  snapshotRange() {\n    let { range, cursor } = this.editor\n    if (cursor.hasCursor() && !range.isBlank) {\n      let { head, tail } = range\n      this.range = {\n        head: [head.leafSectionIndex, head.offset],\n        tail: [tail.leafSectionIndex, tail.offset],\n      }\n    }\n  }\n\n  getRange(post: Post) {\n    if (this.range) {\n      let { head, tail } = this.range\n      let [headLeafSectionIndex, headOffset] = head\n      let [tailLeafSectionIndex, tailOffset] = tail\n      let headSection = findLeafSectionAtIndex(post, headLeafSectionIndex)\n      let tailSection = findLeafSectionAtIndex(post, tailLeafSectionIndex)\n\n      let headPosition = headSection.toPosition(headOffset)\n      let tailPosition = tailSection.toPosition(tailOffset)\n\n      return headPosition.toRange(tailPosition)\n    }\n  }\n\n  groupsWith(groupingTimeout: number, editAction: Option<EditAction>, takenAt: number) {\n    return editAction !== null && this.editAction === editAction && this.takenAt + groupingTimeout > takenAt\n  }\n}\n\nexport default class EditHistory {\n  editor: Editor\n  _undoStack: FixedQueue<Snapshot>\n  _redoStack: FixedQueue<Snapshot>\n  _pendingSnapshot: Option<Snapshot>\n  _groupingTimeout: number\n\n  constructor(editor: Editor, queueLength: number, groupingTimeout: number) {\n    this.editor = editor\n    this._undoStack = new FixedQueue(queueLength)\n    this._redoStack = new FixedQueue(queueLength)\n\n    this._pendingSnapshot = null\n    this._groupingTimeout = groupingTimeout\n  }\n\n  snapshot() {\n    // update the current snapshot with the range read from DOM\n    if (this._pendingSnapshot) {\n      this._pendingSnapshot.snapshotRange()\n    }\n  }\n\n  storeSnapshot(editAction: Option<EditAction> = null) {\n    let now = Date.now()\n    // store pending snapshot\n    let pendingSnapshot = this._pendingSnapshot\n    if (pendingSnapshot) {\n      if (!pendingSnapshot.groupsWith(this._groupingTimeout, editAction, now)) {\n        this._undoStack.push(pendingSnapshot)\n      }\n      this._redoStack.clear()\n    }\n\n    // take new pending snapshot to store next time `storeSnapshot` is called\n    this._pendingSnapshot = new Snapshot(now, this.editor, editAction)\n  }\n\n  stepBackward(postEditor: PostEditor) {\n    // Throw away the pending snapshot\n    this._pendingSnapshot = null\n\n    let snapshot = this._undoStack.pop()\n    if (snapshot) {\n      this._redoStack.push(new Snapshot(Date.now(), this.editor))\n      this._restoreFromSnapshot(snapshot, postEditor)\n    }\n  }\n\n  stepForward(postEditor: PostEditor) {\n    let snapshot = this._redoStack.pop()\n    if (snapshot) {\n      this._undoStack.push(new Snapshot(Date.now(), this.editor))\n      this._restoreFromSnapshot(snapshot, postEditor)\n    }\n    postEditor.cancelSnapshot()\n  }\n\n  _restoreFromSnapshot(snapshot: Snapshot, postEditor: PostEditor) {\n    let { mobiledoc } = snapshot\n    let { editor } = this\n    let { builder, post } = editor\n    let restoredPost = mobiledocParsers.parse(builder, mobiledoc)\n\n    postEditor.removeAllSections()\n    postEditor.migrateSectionsFromPost(restoredPost)\n\n    // resurrect snapshotted range if it exists\n    let newRange = snapshot.getRange(post)\n    if (newRange) {\n      postEditor.setRange(newRange)\n    }\n  }\n}\n","import assert from '../utils/assert'\nimport { MARKUP_SECTION_TYPE, LIST_SECTION_TYPE } from '../models/types'\nimport { DEFAULT_TAG_NAME as DEFAULT_MARKUP_SECTION_TAG_NAME } from '../models/markup-section'\nimport PostNodeBuilder from '../models/post-node-builder'\nimport Post from '../models/post'\nimport Section from '../models/_section'\nimport { Option } from '../utils/types'\nimport ListSection, { isListSection } from '../models/list-section'\nimport { Cloneable } from '../models/_cloneable'\n\nconst UL_LI_REGEX = /^\\* (.*)$/\nconst OL_LI_REGEX = /^\\d\\.? (.*)$/\nconst CR = '\\r'\nconst LF = '\\n'\nconst CR_REGEX = new RegExp(CR, 'g')\nconst CR_LF_REGEX = new RegExp(CR + LF, 'g')\n\nexport const SECTION_BREAK = LF\n\nfunction normalizeLineEndings(text: string) {\n  return text.replace(CR_LF_REGEX, LF).replace(CR_REGEX, LF)\n}\n\nexport interface TextParserOptions {}\n\nexport default class TextParser {\n  builder: PostNodeBuilder\n  options: TextParserOptions\n  post: Post\n\n  prevSection: Option<Cloneable<Section>>\n\n  constructor(builder: PostNodeBuilder, options: TextParserOptions) {\n    this.builder = builder\n    this.options = options\n\n    this.post = this.builder.createPost()\n    this.prevSection = null\n  }\n\n  /**\n   * @param {String} text to parse\n   * @return {Post} a post abstract\n   */\n  parse(text: string): Post {\n    text = normalizeLineEndings(text)\n    text.split(SECTION_BREAK).forEach(text => {\n      let section = this._parseSection(text)\n      this._appendSection(section)\n    })\n\n    return this.post\n  }\n\n  _parseSection(text: string) {\n    let tagName = DEFAULT_MARKUP_SECTION_TAG_NAME,\n      type = MARKUP_SECTION_TYPE,\n      section\n\n    if (UL_LI_REGEX.test(text)) {\n      tagName = 'ul'\n      type = LIST_SECTION_TYPE\n      text = text.match(UL_LI_REGEX)![1]\n    } else if (OL_LI_REGEX.test(text)) {\n      tagName = 'ol'\n      type = LIST_SECTION_TYPE\n      text = text.match(OL_LI_REGEX)![1]\n    }\n\n    let markers = [this.builder.createMarker(text)]\n\n    switch (type) {\n      case LIST_SECTION_TYPE: {\n        let item = this.builder.createListItem(markers)\n        let list = this.builder.createListSection(tagName, [item])\n        section = list\n        break\n      }\n      case MARKUP_SECTION_TYPE:\n        section = this.builder.createMarkupSection(tagName, markers)\n        break\n      default:\n        assert(`Unknown type encountered ${type}`, false)\n    }\n\n    return section\n  }\n\n  _appendSection(section: Cloneable<Section>) {\n    let isSameListSection =\n      isListSection(section) &&\n      this.prevSection &&\n      isListSection(this.prevSection) &&\n      this.prevSection.tagName === section.tagName\n\n    if (isSameListSection) {\n      ;(section as ListSection).items.forEach(item => {\n        ;(this.prevSection as ListSection).items.append(item.clone())\n      })\n    } else {\n      this.post.sections.insertAfter(section, this.prevSection!)\n      this.prevSection = section\n    }\n  }\n}\n","import mobiledocParsers from '../parsers/mobiledoc'\nimport HTMLParser from '../parsers/html'\nimport TextParser from '../parsers/text'\nimport PostNodeBuilder from '../models/post-node-builder'\nimport { SectionParserPlugin } from '../parsers/section'\nimport Post from '../models/post'\nimport { Logger } from './log-manager'\nimport Editor from '../editor/editor'\nimport { Maybe } from './types'\nimport { Mobiledoc } from '../renderers/mobiledoc'\n\nexport const MIME_TEXT_PLAIN = 'text/plain'\nexport const MIME_TEXT_HTML = 'text/html'\nexport const NONSTANDARD_IE_TEXT_TYPE = 'Text'\n\nconst MOBILEDOC_REGEX = new RegExp(/data-mobiledoc='(.*?)'>/)\n\n/**\n * @return {Post}\n * @private\n */\nfunction parsePostFromHTML(html: string, builder: PostNodeBuilder, plugins: SectionParserPlugin[]): Post {\n  let post: Post\n\n  if (MOBILEDOC_REGEX.test(html)) {\n    let mobiledocString = html.match(MOBILEDOC_REGEX)![1]\n    let mobiledoc = JSON.parse(mobiledocString)\n    post = mobiledocParsers.parse(builder, mobiledoc)\n  } else {\n    post = new HTMLParser(builder, { plugins }).parse(html)\n  }\n\n  return post\n}\n\n/**\n * @return {Post}\n * @private\n */\nfunction parsePostFromText(text: string, builder: PostNodeBuilder, plugins: SectionParserPlugin[]): Post {\n  let parser = new TextParser(builder, { plugins })\n  let post = parser.parse(text)\n  return post\n}\n\n// Extend TypeScript's Window interface to include clipboardData from events\ndeclare global {\n  interface Window {\n    readonly clipboardData: DataTransfer | null\n  }\n}\n\n/**\n * @return {{html: String, text: String}}\n * @private\n */\nexport function getContentFromPasteEvent(event: ClipboardEvent, window: Window) {\n  let html = '',\n    text = ''\n\n  let { clipboardData } = event\n\n  if (clipboardData && clipboardData.getData) {\n    html = clipboardData.getData(MIME_TEXT_HTML)\n    text = clipboardData.getData(MIME_TEXT_PLAIN)\n  } else if (window.clipboardData && window.clipboardData.getData) {\n    // IE\n    // The Internet Explorers (including Edge) have a non-standard way of interacting with the\n    // Clipboard API (see http://caniuse.com/#feat=clipboard). In short, they expose a global window.clipboardData\n    // object instead of the per-event event.clipboardData object on the other browsers.\n    html = window.clipboardData.getData(NONSTANDARD_IE_TEXT_TYPE)\n  }\n\n  return { html, text }\n}\n\n/**\n * @return {{html: String, text: String}}\n * @private\n */\nfunction getContentFromDropEvent(event: DragEvent, logger?: Logger): { html: string; text: string } {\n  let html = '',\n    text = ''\n\n  try {\n    html = event.dataTransfer!.getData(MIME_TEXT_HTML)\n    text = event.dataTransfer!.getData(MIME_TEXT_PLAIN)\n  } catch (e) {\n    // FIXME IE11 does not include any data in the 'text/html' or 'text/plain'\n    // mimetypes. It throws an error 'Invalid argument' when attempting to read\n    // these properties.\n    if (logger) {\n      logger.log('Error getting drop data: ', e)\n    }\n  }\n\n  return { html, text }\n}\n\ninterface ClipboardData {\n  mobiledoc: Mobiledoc\n  html: string\n  text: string\n}\n\n/**\n * @param {CopyEvent|CutEvent}\n * @param {Editor}\n * @param {Window}\n * @private\n */\nexport function setClipboardData(event: ClipboardEvent, { mobiledoc, html, text }: ClipboardData, window: Window) {\n  if (mobiledoc && html) {\n    html = `<div data-mobiledoc='${JSON.stringify(mobiledoc)}'>${html}</div>`\n  }\n\n  let { clipboardData } = event\n  let { clipboardData: nonstandardClipboardData } = window\n\n  if (clipboardData && clipboardData.setData) {\n    clipboardData.setData(MIME_TEXT_HTML, html!)\n    clipboardData.setData(MIME_TEXT_PLAIN, text!)\n  } else if (nonstandardClipboardData && nonstandardClipboardData.setData) {\n    // The Internet Explorers (including Edge) have a non-standard way of interacting with the\n    // Clipboard API (see http://caniuse.com/#feat=clipboard). In short, they expose a global window.clipboardData\n    // object instead of the per-event event.clipboardData object on the other browsers.\n    nonstandardClipboardData.setData(NONSTANDARD_IE_TEXT_TYPE, html!)\n  }\n}\n\n/**\n * @param {PasteEvent}\n * @param {{builder: Builder, _parserPlugins: Array}} options\n * @return {Post}\n * @private\n */\nexport function parsePostFromPaste(\n  pasteEvent: ClipboardEvent,\n  { builder, _parserPlugins: plugins }: Editor,\n  { targetFormat } = { targetFormat: 'html' }\n): Maybe<Post> {\n  let { html, text } = getContentFromPasteEvent(pasteEvent, window)\n\n  if (targetFormat === 'html' && html && html.length) {\n    return parsePostFromHTML(html, builder, plugins)\n  } else if (text && text.length) {\n    return parsePostFromText(text, builder, plugins)\n  }\n}\n\n/**\n * @param {DropEvent}\n * @param {Editor} editor\n * @param {Object} [options={}] Can pass a logger\n * @return {Post}\n * @private\n */\nexport function parsePostFromDrop(\n  dropEvent: DragEvent,\n  editor: Editor,\n  { logger }: { logger?: Logger } = {}\n): Maybe<Post> {\n  let { builder, _parserPlugins: plugins } = editor\n  let { html, text } = getContentFromDropEvent(dropEvent, logger)\n\n  if (html && html.length) {\n    return parsePostFromHTML(html, builder, plugins)\n  } else if (text && text.length) {\n    return parsePostFromText(text, builder, plugins)\n  }\n}\n","import { endsWith } from '../utils/string-utils'\nimport assert from '../utils/assert'\nimport deprecate from '../utils/deprecate'\nimport { ENTER } from '../utils/characters'\nimport Editor from './editor'\nimport Markerable from '../models/_markerable'\nimport { Maybe } from '../utils/types'\n\nclass TextInputHandler {\n  editor: Editor\n  _handlers: TextInputHandlerListener[]\n\n  constructor(editor: Editor) {\n    this.editor = editor\n    this._handlers = []\n  }\n\n  register(handler: TextInputHandlerListener) {\n    assert(`Input Handler is not valid`, this._validateHandler(handler))\n    this._handlers.push(handler)\n  }\n\n  unregister(name: string) {\n    let handlers = this._handlers\n    for (let i = 0; i < handlers.length; i++) {\n      if (handlers[i].name === name) {\n        handlers.splice(i, 1)\n      }\n    }\n  }\n\n  handle(string: string) {\n    let { editor } = this\n\n    editor.insertText(string)\n\n    let matchedHandler = this._findHandler()\n    if (matchedHandler) {\n      let [handler, matches] = matchedHandler\n      handler.run(editor, matches)\n    }\n  }\n\n  handleNewLine() {\n    let { editor } = this\n\n    let matchedHandler = this._findHandler(ENTER)\n    if (matchedHandler) {\n      let [handler, matches] = matchedHandler\n      handler.run(editor, matches)\n    }\n  }\n\n  _findHandler(string = ''): Maybe<[TextInputHandlerListener, string[]]> {\n    const { editor } = this\n    const { range } = editor\n    const { head } = range\n    const { section } = head\n\n    let preText = ((section! as unknown) as Markerable).textUntil(head) + string\n\n    for (let i = 0; i < this._handlers.length; i++) {\n      let handler = this._handlers[i]\n\n      if ('text' in handler && endsWith(preText, handler.text)) {\n        return [handler, [handler.text]]\n      } else if ('match' in handler && handler.match.test(preText)) {\n        return [handler, handler.match.exec(preText)!]\n      }\n    }\n  }\n\n  _validateHandler(handler: TextInputHandlerListener) {\n    deprecate('Registered input handlers require a \"name\" property so that they can be unregistered', !!handler.name)\n    return (\n      !!handler.run && // has `run`\n      (!!(handler as TextHandler).text || !!(handler as MatchHandler).match) && // and `text` or `match`\n      !(!!(handler as TextHandler).text && !!(handler as MatchHandler).match)\n    ) // not both `text` and `match`\n  }\n\n  destroy() {\n    this._handlers = []\n  }\n}\n\ninterface BaseHandler {\n  name: string\n  run: (editor: Editor, matches: string[]) => void\n}\n\ninterface TextHandler extends BaseHandler {\n  text: string\n}\n\ninterface MatchHandler extends BaseHandler {\n  match: RegExp\n}\n\nexport type TextInputHandlerListener = TextHandler | MatchHandler\n\nexport default TextInputHandler\n","import { PartialSelection } from '../utils/selection-utils'\n\nlet instance: SelectionChangeObserver\n\nexport interface SelectionChangeListener {\n  selectionDidChange(nextSelection: PartialSelection, prevSelection: PartialSelection): void\n}\n\nclass SelectionChangeObserver {\n  started: boolean\n  listeners: SelectionChangeListener[]\n  selection: PartialSelection\n\n  constructor() {\n    this.started = false\n    this.listeners = []\n    this.selection = {} as PartialSelection\n  }\n\n  static getInstance() {\n    if (!instance) {\n      instance = new SelectionChangeObserver()\n    }\n    return instance\n  }\n\n  static addListener(listener: SelectionChangeListener) {\n    SelectionChangeObserver.getInstance().addListener(listener)\n  }\n\n  addListener(listener: SelectionChangeListener) {\n    if (this.listeners.indexOf(listener) === -1) {\n      this.listeners.push(listener)\n      this.start()\n    }\n  }\n\n  static removeListener(listener: SelectionChangeListener) {\n    SelectionChangeObserver.getInstance().removeListener(listener)\n  }\n\n  removeListener(listener: SelectionChangeListener) {\n    let index = this.listeners.indexOf(listener)\n    if (index !== -1) {\n      this.listeners.splice(index, 1)\n      if (this.listeners.length === 0) {\n        this.stop()\n      }\n    }\n  }\n\n  start() {\n    if (this.started) {\n      return\n    }\n    this.started = true\n\n    this.poll()\n  }\n\n  stop() {\n    this.started = false\n    this.selection = {} as Selection\n  }\n\n  notifyListeners(newSelection: PartialSelection, prevSelection: PartialSelection) {\n    this.listeners.forEach(listener => {\n      listener.selectionDidChange(newSelection, prevSelection)\n    })\n  }\n\n  destroy() {\n    this.stop()\n    this.listeners = []\n  }\n\n  getSelection(): PartialSelection {\n    let selection = window.getSelection()!\n    let { anchorNode, focusNode, anchorOffset, focusOffset } = selection\n    return { anchorNode, focusNode, anchorOffset, focusOffset }\n  }\n\n  poll() {\n    if (this.started) {\n      this.update()\n      this.runNext(() => this.poll())\n    }\n  }\n\n  runNext(fn: FrameRequestCallback) {\n    window.requestAnimationFrame(fn)\n  }\n\n  update() {\n    let prevSelection = this.selection\n    let curSelection = this.getSelection()!\n    if (!this.selectionIsEqual(prevSelection, curSelection)) {\n      this.selection = curSelection\n      this.notifyListeners(curSelection, prevSelection)\n    }\n  }\n\n  selectionIsEqual(s1: PartialSelection, s2: PartialSelection) {\n    return (\n      s1.anchorNode === s2.anchorNode &&\n      s1.anchorOffset === s2.anchorOffset &&\n      s1.focusNode === s2.focusNode &&\n      s1.focusOffset === s2.focusOffset\n    )\n  }\n}\n\nexport default SelectionChangeObserver\n","import SelectionChangeObserver from '../editor/selection-change-observer'\nimport Editor from './editor'\nimport { PartialSelection } from '../utils/selection-utils'\n\ntype SelectionManagerCallback = (curSelection: PartialSelection, prevSelection: PartialSelection) => void\n\nexport default class SelectionManager {\n  editor: Editor\n  callback: SelectionManagerCallback\n  started: boolean\n\n  constructor(editor: Editor, callback: SelectionManagerCallback) {\n    this.editor = editor\n    this.callback = callback\n    this.started = false\n  }\n\n  start() {\n    if (this.started) {\n      return\n    }\n\n    SelectionChangeObserver.addListener(this)\n    this.started = true\n  }\n\n  stop() {\n    this.started = false\n    SelectionChangeObserver.removeListener(this)\n  }\n\n  destroy() {\n    this.stop()\n  }\n\n  selectionDidChange(curSelection: PartialSelection, prevSelection: PartialSelection) {\n    if (this.started) {\n      this.callback(curSelection, prevSelection)\n    }\n  }\n}\n","import assert from '../utils/assert'\nimport { parsePostFromPaste, setClipboardData, parsePostFromDrop } from '../utils/parse-utils'\nimport { filter, forEach } from '../utils/array-utils'\nimport Key from '../utils/key'\nimport TextInputHandler, { TextInputHandlerListener } from '../editor/text-input-handler'\nimport SelectionManager from '../editor/selection-manager'\nimport Browser from '../utils/browser'\nimport { Position, Range } from '../utils/cursor'\nimport Editor, { TextUnit, Format } from './editor'\nimport { Logger } from '../utils/log-manager'\nimport { PartialSelection } from '../utils/selection-utils'\n\nconst ELEMENT_EVENT_TYPES = <const>[\n  'keydown',\n  'keyup',\n  'cut',\n  'copy',\n  'paste',\n  'keypress',\n  'drop',\n  'compositionstart',\n  'compositionend',\n  'beforeinput',\n]\n\ndeclare global {\n  interface HTMLElementEventMap {\n    compositionstart: CompositionEvent\n    compositionend: CompositionEvent\n    beforeinput: InputEvent\n  }\n  interface InputEvent {\n    getTargetRanges(): StaticRange[]\n    dataTransfer: DataTransfer | null\n  }\n}\n\nexport type DOMEventType = typeof ELEMENT_EVENT_TYPES[number]\nexport type DOMEventForType<T extends DOMEventType> = HTMLElementEventMap[T]\nexport type DOMEvent = HTMLElementEventMap[DOMEventType]\n\ninterface ModifierKeys {\n  shift: boolean\n}\n\ntype EventManagerListener = [\n  HTMLElement,\n  DOMEventType,\n  (event: CompositionEvent | KeyboardEvent | ClipboardEvent | DragEvent | InputEvent) => void\n]\n\nexport default class EventManager {\n  editor: Editor\n  logger: Logger\n  modifierKeys: ModifierKeys\n  started: boolean\n\n  _isComposingOnBlankLine: boolean\n  _listeners: EventManagerListener[]\n  _textInputHandler: TextInputHandler\n  _selectionManager: SelectionManager\n\n  constructor(editor: Editor) {\n    this.editor = editor\n    this.logger = editor.loggerFor('event-manager')\n    this._textInputHandler = new TextInputHandler(editor)\n    this._listeners = []\n    this.modifierKeys = {\n      shift: false,\n    }\n\n    this._selectionManager = new SelectionManager(this.editor, this.selectionDidChange.bind(this))\n    this.started = true\n    this._isComposingOnBlankLine = false\n  }\n\n  init() {\n    let {\n      editor: { element },\n    } = this\n    assert(`Cannot init EventManager without element`, !!element)\n\n    ELEMENT_EVENT_TYPES.forEach(type => {\n      this._addListener(element, type)\n    })\n\n    this._selectionManager.start()\n  }\n\n  start() {\n    this.started = true\n  }\n\n  stop() {\n    this.started = false\n  }\n\n  registerInputHandler(inputHandler: TextInputHandlerListener) {\n    this._textInputHandler.register(inputHandler)\n  }\n\n  unregisterInputHandler(name: string) {\n    this._textInputHandler.unregister(name)\n  }\n\n  unregisterAllTextInputHandlers() {\n    this._textInputHandler.destroy()\n    this._textInputHandler = new TextInputHandler(this.editor)\n  }\n\n  _addListener(context: HTMLElement, type: DOMEventType) {\n    assert(`Missing listener for ${type}`, !!this[type])\n\n    let listener: (event: DOMEventForType<typeof type>) => void = event => this._handleEvent(type, event)\n    context.addEventListener(type, listener)\n    this._listeners.push([context, type, listener])\n  }\n\n  _removeListeners() {\n    this._listeners.forEach(([context, type, listener]) => {\n      context.removeEventListener(type, listener)\n    })\n    this._listeners = []\n  }\n\n  // This is primarily useful for programmatically simulating events on the\n  // editor from the tests.\n  _trigger(context: HTMLElement, type: DOMEventType, event: DOMEventForType<typeof type>) {\n    forEach(\n      filter(this._listeners, ([_context, _type]) => {\n        return _context === context && _type === type\n      }),\n      ([context, , listener]) => {\n        listener.call(context, event)\n      }\n    )\n  }\n\n  destroy() {\n    this._textInputHandler.destroy()\n    this._selectionManager.destroy()\n    this._removeListeners()\n  }\n\n  _handleEvent(type: DOMEventType, event: DOMEventForType<typeof type>) {\n    let { target: element } = event\n    if (!this.started) {\n      // abort handling this event\n      return true\n    }\n\n    if (!this.isElementAddressable(element! as HTMLElement)) {\n      // abort handling this event\n      return true\n    }\n\n    ;(this[type] as (evt: typeof event) => void)(event)\n  }\n\n  isElementAddressable(element: Node) {\n    return this.editor.cursor.isAddressable(element)\n  }\n\n  selectionDidChange(selection: PartialSelection /*, prevSelection */) {\n    let shouldNotify = true\n    let { anchorNode } = selection\n    if (!this.isElementAddressable(anchorNode!)) {\n      if (!this.editor.range.isBlank) {\n        // Selection changed from something addressable to something\n        // not-addressable -- e.g., blur event, user clicked outside editor,\n        // etc\n        shouldNotify = true\n      } else {\n        // selection changes wholly outside the editor should not trigger\n        // change notifications\n        shouldNotify = false\n      }\n    }\n\n    if (shouldNotify) {\n      this.editor._readRangeFromDOM()\n    }\n  }\n\n  keypress(event: KeyboardEvent) {\n    if (!InputEvent.prototype.getTargetRanges) {\n      let { editor, _textInputHandler } = this\n      if (!editor.hasCursor()) {\n        return\n      }\n\n      let key = Key.fromEvent(event)\n      if (!key.isPrintable()) {\n        return\n      } else {\n        event.preventDefault()\n      }\n\n      // Handle carriage returns\n      if (!key.isEnter() && key.keyCode === 13) {\n        _textInputHandler.handleNewLine()\n        editor.handleNewline(event)\n        return\n      }\n\n      _textInputHandler.handle(key.toString())\n    }\n  }\n\n  keydown(event: KeyboardEvent) {\n    let { editor } = this\n    if (!editor.hasCursor()) {\n      return\n    }\n    if (!editor.isEditable) {\n      return\n    }\n\n    let key = Key.fromEvent(event)\n    this._updateModifiersFromKey(key, { isDown: true })\n\n    if (editor.handleKeyCommand(event)) {\n      return\n    }\n\n    if (editor.post.isBlank) {\n      editor._insertEmptyMarkupSectionAtCursor()\n    }\n\n    let range = editor.range\n\n    switch (true) {\n      // Ignore keydown events when using an IME\n      case key.isIME(): {\n        break\n      }\n      // FIXME This should be restricted to only card/atom boundaries\n      case key.isHorizontalArrowWithoutModifiersOtherThanShift(): {\n        let newRange\n        if (key.isShift()) {\n          newRange = range.extend(key.direction * 1)\n        } else {\n          newRange = range.move(key.direction)\n        }\n\n        editor.selectRange(newRange)\n        event.preventDefault()\n        break\n      }\n      case key.isDelete(): {\n        if (!InputEvent.prototype.getTargetRanges) {\n          let { direction } = key\n          let unit = TextUnit.CHAR\n          if (key.altKey && Browser.isMac()) {\n            unit = TextUnit.WORD\n          } else if (key.ctrlKey && !Browser.isMac()) {\n            unit = TextUnit.WORD\n          }\n          editor.performDelete({ direction, unit })\n          event.preventDefault()\n        }\n        break\n      }\n      case key.isEnter():\n        if (!InputEvent.prototype.getTargetRanges) {\n          this._textInputHandler.handleNewLine()\n          editor.handleNewline(event)\n        }\n        break\n      case key.isTab():\n        // Handle tab here because it does not fire a `keypress` event\n        event.preventDefault()\n        this._textInputHandler.handle(key.toString())\n        break\n    }\n  }\n\n  keyup(event: KeyboardEvent) {\n    let { editor } = this\n    if (!editor.hasCursor()) {\n      return\n    }\n    let key = Key.fromEvent(event)\n    this._updateModifiersFromKey(key, { isDown: false })\n  }\n\n  beforeinput(event: InputEvent) {\n    let { editor } = this\n    if (!editor.hasCursor()) {\n      return\n    }\n\n    // See compatibility data on https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/inputType\n    // Chrome 60, Safari 10.1, Firefox 66; no IE or pre-Chromium Edge\n\n    if (!editor.isEditable) {\n      return\n    }\n\n    if (editor.post.isBlank) {\n      editor._insertEmptyMarkupSectionAtCursor()\n    }\n\n    let jsRange = event.getTargetRanges()[0]\n    if (jsRange) {\n      let range = new Range(\n        Position.fromNode(editor._renderTree, jsRange.startContainer, jsRange.startOffset),\n        Position.fromNode(editor._renderTree, jsRange.endContainer, jsRange.endOffset)\n      )\n      editor.selectRange(range)\n    }\n\n    if (event.inputType.includes('Composition')) {\n      // IME - handled differently\n      return\n    }\n\n    // Safari iOS puts insertReplacementText data in event.dataTransfer.\n    let insertData: string | null = event.data || event.dataTransfer?.getData('text/plain') || null\n\n    // Cut/paste/drop is handled by those events instead\n    switch (event.inputType) {\n      case 'deleteWordBackward':\n        editor.performDelete({ direction: -1, unit: TextUnit.WORD })\n        event.preventDefault()\n        return\n      case 'deleteWordForward':\n        editor.performDelete({ direction: 1, unit: TextUnit.WORD })\n        event.preventDefault()\n        return\n      case 'deleteContent':\n        editor.performDelete()\n        event.preventDefault()\n        return\n      case 'deleteContentBackward':\n        editor.performDelete({ direction: -1, unit: TextUnit.CHAR })\n        event.preventDefault()\n        return\n      case 'deleteContentForward':\n        editor.performDelete({ direction: 1, unit: TextUnit.CHAR })\n        event.preventDefault()\n        return\n      case 'insertLineBreak':\n      case 'insertParagraph':\n        this._textInputHandler.handleNewLine()\n        editor.handleNewline(event)\n        event.preventDefault()\n        break\n      case 'insertText':\n      case 'insertReplacementText':\n      case 'insertFromYank':\n        this._textInputHandler.handle(insertData || '')\n        event.preventDefault()\n        break\n    }\n  }\n\n  // The mutation handler interferes with IMEs when composing\n  // on a blank line. These two event handlers are for suppressing\n  // mutation handling in this scenario.\n  compositionstart(_event: KeyboardEvent) {\n    let { editor } = this\n    // Ignore compositionstart if not on a blank line\n    if (editor.range.headMarker) {\n      return\n    }\n    this._isComposingOnBlankLine = true\n\n    if (editor.post.isBlank) {\n      editor._insertEmptyMarkupSectionAtCursor()\n    }\n\n    // Stop listening for mutations on Chrome browsers and suppress\n    // mutations by prepending a character for other browsers.\n    // The reason why we treat these separately is because\n    // of the way each browser processes IME inputs.\n    if (Browser.isChrome()) {\n      editor.setPlaceholder('')\n      editor._mutationHandler.stopObserving()\n    } else {\n      this._textInputHandler.handle(' ')\n    }\n  }\n\n  compositionend(event: CompositionEvent) {\n    const { editor } = this\n\n    // Ignore compositionend if not composing on blank line\n    if (!this._isComposingOnBlankLine) {\n      return\n    }\n    this._isComposingOnBlankLine = false\n\n    // Start listening for mutations on Chrome browsers and\n    // delete the prepended character introduced by compositionstart\n    // for other browsers.\n    if (Browser.isChrome()) {\n      editor.insertText(event.data)\n      editor.setPlaceholder(editor.placeholder)\n      editor._mutationHandler.startObserving()\n    } else {\n      let startOfCompositionLine = editor.range.headSection!.toPosition(0)\n      let endOfCompositionLine = editor.range.headSection!.toPosition(event.data.length)\n      editor.run(postEditor => {\n        postEditor.deleteAtPosition(startOfCompositionLine, 1, { unit: TextUnit.CHAR })\n        postEditor.setRange(endOfCompositionLine)\n      })\n    }\n  }\n\n  cut(event: ClipboardEvent) {\n    event.preventDefault()\n\n    this.copy(event)\n    this.editor.performDelete()\n  }\n\n  copy(event: ClipboardEvent) {\n    event.preventDefault()\n\n    let {\n      editor,\n      editor: { range, post },\n    } = this\n    post = post.trimTo(range)\n\n    let data = {\n      html: editor.serializePost(post, Format.HTML),\n      text: editor.serializePost(post, Format.TEXT),\n      mobiledoc: editor.serializePost(post, Format.MOBILEDOC),\n    }\n\n    editor.runCallbacks('willCopy', [data])\n\n    setClipboardData(event, data, window)\n  }\n\n  paste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    let { editor } = this\n    let range = editor.range\n\n    if (!range.isCollapsed) {\n      editor.performDelete()\n    }\n\n    if (editor.post.isBlank) {\n      editor._insertEmptyMarkupSectionAtCursor()\n    }\n\n    let position = editor.range.head\n    let targetFormat = this.modifierKeys.shift ? 'text' : 'html'\n    let pastedPost = parsePostFromPaste(event, editor, { targetFormat })\n\n    editor.runCallbacks('willPaste', [pastedPost])\n\n    editor.run(postEditor => {\n      let nextPosition = postEditor.insertPost(position, pastedPost!)\n      postEditor.setRange(nextPosition)\n    })\n  }\n\n  drop(event: DragEvent) {\n    event.preventDefault()\n\n    let { clientX: x, clientY: y } = event\n    let { editor } = this\n\n    let position = editor.positionAtPoint(x, y)\n    if (!position) {\n      this.logger.log('Could not find drop position')\n      return\n    }\n\n    let post = parsePostFromDrop(event, editor, { logger: this.logger })\n    if (!post) {\n      this.logger.log('Could not determine post from drop event')\n      return\n    }\n\n    editor.run(postEditor => {\n      let nextPosition = postEditor.insertPost(position!, post!)\n      postEditor.setRange(nextPosition)\n    })\n  }\n\n  _updateModifiersFromKey(key: Key, { isDown }: { isDown: boolean }) {\n    if (key.isShiftKey()) {\n      this.modifierKeys.shift = isDown\n    }\n  }\n}\n","import { contains, isArrayEqual, objectToSortedKVArray } from '../utils/array-utils'\nimport Range from '../utils/cursor/range'\nimport { Option, Dict } from '../utils/types'\nimport Editor from './editor'\nimport { Cloneable } from '../models/_cloneable'\nimport Section from '../models/_section'\nimport Markup from '../models/markup'\nimport { TagNameable } from '../models/_tag-nameable'\nimport { getSectionAttributes } from '../models/_attributable'\n\ninterface EditStateState {\n  range: Range\n  activeMarkups: Markup[]\n  activeSections: Section[]\n  activeSectionTagNames: string[]\n  activeSectionAttributes: Dict<string[]>\n}\n\n/**\n * Used by {@link Editor} to manage its current state (cursor, active markups\n * and active sections).\n * @private\n */\nexport default class EditState {\n  editor: Option<Editor>\n  state: Option<EditStateState>\n  prevState: Option<EditStateState>\n\n  constructor(editor: Editor) {\n    this.editor = editor\n\n    let defaultState: EditStateState = {\n      range: Range.blankRange(),\n      activeMarkups: [],\n      activeSections: [],\n      activeSectionTagNames: [],\n      activeSectionAttributes: {},\n    }\n\n    this.prevState = this.state = defaultState\n  }\n\n  updateRange(newRange: Range) {\n    this.prevState = this.state\n    this.state = this._readState(newRange)\n  }\n\n  destroy() {\n    this.editor = null\n    this.prevState = this.state = null\n  }\n\n  /**\n   * @return {Boolean}\n   */\n  rangeDidChange(): boolean {\n    const { state, prevState } = this\n    const { range } = state!\n    const { range: prevRange } = prevState!\n\n    return !prevRange.isEqual(range)\n  }\n\n  /**\n   * @return {Boolean} Whether the input mode (active markups or active section tag names)\n   * has changed.\n   */\n  inputModeDidChange(): boolean {\n    const state = this.state!\n    const prevState = this.prevState!\n\n    return (\n      !isArrayEqual(state.activeMarkups, prevState.activeMarkups) ||\n      !isArrayEqual(state.activeSectionTagNames, prevState.activeSectionTagNames) ||\n      !isArrayEqual(\n        objectToSortedKVArray(state.activeSectionAttributes),\n        objectToSortedKVArray(prevState.activeSectionAttributes)\n      )\n    )\n  }\n\n  /**\n   * @return {Range}\n   */\n  get range(): Range {\n    return this.state!.range\n  }\n\n  /**\n   * @return {Section[]}\n   */\n  get activeSections(): Section[] {\n    return this.state!.activeSections\n  }\n\n  /**\n   * @return {Object}\n   */\n  get activeSectionAttributes(): Dict<string[]> {\n    return this.state!.activeSectionAttributes\n  }\n\n  /**\n   * @return {Markup[]}\n   */\n  get activeMarkups(): Markup[] {\n    return this.state!.activeMarkups\n  }\n\n  /**\n   * Update the editor's markup state. This is used when, e.g.,\n   * a user types meta+B when the editor has a cursor but no selected text;\n   * in this case the editor needs to track that it has an active \"b\" markup\n   * and apply it to the next text the user types.\n   */\n  toggleMarkupState(markup: Markup) {\n    if (contains(this.activeMarkups, markup)) {\n      this._removeActiveMarkup(markup)\n    } else {\n      this._addActiveMarkup(markup)\n    }\n  }\n\n  _readState(range: Range): EditStateState {\n    let state: Partial<EditStateState> = {\n      range,\n      activeMarkups: this._readActiveMarkups(range),\n      activeSections: this._readActiveSections(range),\n    }\n    // Section objects are 'live', so to check that they changed, we\n    // need to map their tagNames now (and compare to mapped tagNames later).\n    // In addition, to catch changes from ul -> ol, we keep track of the\n    // un-nested tag names (otherwise we'd only see li -> li change)\n    state.activeSectionTagNames = state.activeSections!.map(s => {\n      return s.isNested ? ((s.parent as unknown) as TagNameable).tagName : ((s as unknown) as TagNameable).tagName\n    })\n    state.activeSectionAttributes = this._readSectionAttributes(state.activeSections!)\n\n    return state as EditStateState\n  }\n\n  _readActiveSections(range: Range) {\n    const { head, tail } = range\n    const { editor } = this\n    const { post } = editor!\n\n    if (range.isBlank) {\n      return []\n    } else {\n      return post.sections.readRange(head.section as Cloneable<Section>, tail.section as Cloneable<Section>)\n    }\n  }\n\n  _readActiveMarkups(range: Range) {\n    const { editor } = this\n    const { post } = editor!\n\n    return post.markupsInRange(range)\n  }\n\n  _readSectionAttributes(sections: Section[]) {\n    return sections.reduce<Dict<string[]>>((sectionAttributes, s) => {\n      let attributes: Dict<string> = getSectionAttributes(s)\n\n      Object.keys(attributes).forEach(attrName => {\n        let camelizedAttrName = attrName.replace(/^data-md-/, '')\n        let attrValue = attributes[attrName]\n\n        sectionAttributes[camelizedAttrName] = sectionAttributes[camelizedAttrName] || []\n\n        if (!contains(sectionAttributes[camelizedAttrName], attrValue)) {\n          sectionAttributes[camelizedAttrName].push(attrValue)\n        }\n      })\n\n      return sectionAttributes\n    }, {})\n  }\n\n  _removeActiveMarkup(markup: Markup) {\n    let index = this.state!.activeMarkups.indexOf(markup)\n    this.state!.activeMarkups.splice(index, 1)\n  }\n\n  _addActiveMarkup(markup: Markup) {\n    this.state!.activeMarkups.push(markup)\n  }\n}\n","function addHTMLSpaces(text) {\n  let nbsp = '\\u00A0';\n  return text.replace(/  /g, ' ' + nbsp);\n}\n\nexport function createTextNode(dom, text) {\n  return dom.createTextNode(addHTMLSpaces(text));\n}\n\nexport function normalizeTagName(tagName) {\n  return tagName.toLowerCase();\n}\n","export default 'dom';\n","import RENDER_TYPE from '../utils/render-type';\n\nexport default {\n  name: 'image',\n  type: RENDER_TYPE,\n  render({payload, env: {dom}}) {\n    let img = dom.createElement('img');\n    img.src = payload.src;\n    return img;\n  }\n};\n","export const MARKUP_SECTION_TYPE = 1;\nexport const IMAGE_SECTION_TYPE = 2;\nexport const LIST_SECTION_TYPE = 3;\nexport const CARD_SECTION_TYPE = 10;\n","import {\n  MARKUP_SECTION_TYPE,\n  LIST_SECTION_TYPE\n} from './section-types';\nimport { normalizeTagName } from './dom';\n\nconst MARKUP_SECTION_TAG_NAMES = [\n  'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pull-quote', 'aside'\n].map(normalizeTagName);\n\nconst MARKUP_SECTION_ELEMENT_NAMES = [\n  'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'aside'\n].map(normalizeTagName);\n\nconst LIST_SECTION_TAG_NAMES = [\n  'ul', 'ol'\n].map(normalizeTagName);\n\nconst MARKUP_TYPES = [\n  'b', 'i', 'strong', 'em', 'a', 'u', 'sub', 'sup', 's', 'code'\n].map(normalizeTagName);\n\nfunction contains(array, item) {\n  return array.indexOf(item) !== -1;\n}\n\nexport function isValidSectionTagName(tagName, sectionType) {\n  tagName = normalizeTagName(tagName);\n\n  switch (sectionType) {\n    case MARKUP_SECTION_TYPE:\n      return contains(MARKUP_SECTION_TAG_NAMES, tagName);\n    case LIST_SECTION_TYPE:\n      return contains(LIST_SECTION_TAG_NAMES, tagName);\n    default:\n      throw new Error(`Cannot validate tagName for unknown section type \"${sectionType}\"`);\n  }\n}\n\nexport function isMarkupSectionElementName(tagName) {\n  tagName = normalizeTagName(tagName);\n  return contains(MARKUP_SECTION_ELEMENT_NAMES, tagName);\n}\n\nexport function isValidMarkerType(type) {\n  type = normalizeTagName(type);\n  return contains(MARKUP_TYPES, type);\n}\n","export function includes(array, detectValue) {\n  for (let i=0;i < array.length;i++) {\n    let value = array[i];\n    if (value === detectValue) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\n/**\n * @param {Array} array of key1,value1,key2,value2,...\n * @return {Object} {key1:value1, key2:value2, ...}\n * @private\n */\nexport function kvArrayToObject(array) {\n  if (!Array.isArray(array)) { return {}; }\n\n  const obj = {};\n  for (let i = 0; i < array.length; i+=2) {\n    let [key, value] = [array[i], array[i+1]];\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * @param {Object} {key1:value1, key2:value2, ...}\n * @return {Array} array of key1,value1,key2,value2,...\n * @private\n */\nexport function objectToSortedKVArray(obj) {\n  const keys = Object.keys(obj).sort();\n  const result = [];\n  keys.forEach(k => {\n    result.push(k);\n    result.push(obj[k]);\n  });\n  return result;\n}\n","import { includes } from './array-utils';\n\nconst PROTOCOL_REGEXP = /^([a-z0-9.+-]+:)/i;\n\nconst badProtocols = [\n  'javascript:', // jshint ignore:line\n  'vbscript:' // jshint ignore:line\n];\n\nfunction getProtocol(url) {\n  let matches = url && url.match(PROTOCOL_REGEXP);\n  let protocol = (matches && matches[0]) || ':';\n  return protocol;\n}\n\nexport function sanitizeHref(url) {\n  let protocol = getProtocol(url).toLowerCase();\n  if (includes(badProtocols, protocol)) {\n    return `unsafe:${url}`;\n  }\n  return url;\n}\n\n/**\n * @param attributes array\n * @return obj with normalized attribute names (lowercased)\n */\nexport function reduceAttributes(attributes) {\n  let obj = {};\n  for (let i = 0; i < attributes.length; i += 2) {\n    let key = attributes[i];\n    let val = attributes[i+1];\n    obj[key.toLowerCase()] = val;\n  }\n  return obj;\n}\n","import {\n  isMarkupSectionElementName\n} from '../utils/tag-names';\nimport {\n  sanitizeHref\n} from './sanitization-utils';\n\nexport const VALID_ATTRIBUTES = [\n  'data-md-text-align'\n];\n\nfunction _isValidAttribute(attr) {\n  return VALID_ATTRIBUTES.indexOf(attr) !== -1;\n}\n\nfunction handleMarkupSectionAttribute(element, attributeKey, attributeValue) {\n  if (!_isValidAttribute(attributeKey)) {\n    throw new Error(`Cannot use attribute: ${attributeKey}`);\n  }\n\n  element.setAttribute(attributeKey, attributeValue);\n}\n\nexport function defaultSectionElementRenderer(tagName, dom, attrsObj = {}) {\n  let element;\n  if (isMarkupSectionElementName(tagName)) {\n    element = dom.createElement(tagName);\n\n    Object.keys(attrsObj).forEach(k => {\n      handleMarkupSectionAttribute(element, k, attrsObj[k]);\n    });\n  } else {\n    element = dom.createElement('div');\n    element.setAttribute('class', tagName);\n  }\n\n  return element;\n}\n\nfunction sanitizeAttribute(tagName, attrName, attrValue) {\n  if (tagName === 'a' && attrName === 'href') {\n    return sanitizeHref(attrValue);\n  } else {\n    return attrValue;\n  }\n}\n\nexport function defaultMarkupElementRenderer(tagName, dom, attrsObj) {\n  let element = dom.createElement(tagName);\n  Object.keys(attrsObj).forEach(attrName => {\n    let attrValue = attrsObj[attrName];\n    attrValue = sanitizeAttribute(tagName, attrName, attrValue);\n    element.setAttribute(attrName, attrValue);\n  });\n  return element;\n}\n\n","import { createTextNode } from '../utils/dom';\nimport ImageCard from '../cards/image';\nimport RENDER_TYPE from '../utils/render-type';\nimport {\n  MARKUP_SECTION_TYPE,\n  IMAGE_SECTION_TYPE,\n  LIST_SECTION_TYPE,\n  CARD_SECTION_TYPE\n} from '../utils/section-types';\nimport {\n  isValidSectionTagName,\n  isValidMarkerType\n} from '../utils/tag-names';\nimport {\n  reduceAttributes\n} from '../utils/sanitization-utils';\nimport {\n  defaultSectionElementRenderer,\n  defaultMarkupElementRenderer\n} from '../utils/render-utils';\n\nexport const MOBILEDOC_VERSION = '0.2.0';\n\nconst IMAGE_SECTION_TAG_NAME = 'img';\n\nfunction validateVersion(version) {\n  if (version !== MOBILEDOC_VERSION) {\n    throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nexport default class Renderer {\n  constructor(mobiledoc, options) {\n    let {\n      cards,\n      cardOptions,\n      unknownCardHandler,\n      markupElementRenderer,\n      sectionElementRenderer,\n      dom\n    } = options;\n    let {\n      version,\n      sections: sectionData\n    } = mobiledoc;\n    validateVersion(version);\n\n    const [markerTypes, sections] = sectionData;\n\n    this.dom                = dom;\n    this.root               = dom.createDocumentFragment();\n    this.markerTypes        = markerTypes;\n    this.sections           = sections;\n    this.cards              = cards;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n\n    this.sectionElementRenderer = {\n      '__default__': defaultSectionElementRenderer\n    };\n    Object.keys(sectionElementRenderer).forEach(key => {\n      this.sectionElementRenderer[key.toLowerCase()] = sectionElementRenderer[key];\n    });\n\n    this.markupElementRenderer = {\n      '__default__': defaultMarkupElementRenderer\n    };\n    Object.keys(markupElementRenderer).forEach(key => {\n      this.markupElementRenderer[key.toLowerCase()] = markupElementRenderer[key];\n    });\n\n    this._renderCallbacks    = [];\n    this._teardownCallbacks  = [];\n    this._renderedChildNodes = [];\n  }\n\n  get _defaultUnknownCardHandler() {\n    return ({env: {name}}) => {\n      throw new Error(`Card \"${name}\" not found but no unknownCardHandler was registered`);\n    };\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      let rendered = this.renderSection(section);\n      if (rendered) {\n        this.root.appendChild(rendered);\n      }\n    });\n    for (let i = 0; i < this._renderCallbacks.length; i++) {\n      this._renderCallbacks[i]();\n    }\n    // maintain a reference to child nodes so they can be cleaned up later by teardown\n    this._renderedChildNodes = [];\n    let node = this.root.firstChild;\n    while (node) {\n      this._renderedChildNodes.push(node);\n      node = node.nextSibling;\n    }\n    return { result: this.root, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n    for (let i=0; i < this._renderedChildNodes.length; i++) {\n      let node = this._renderedChildNodes[i];\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE:\n        return this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE:\n        return this.renderCardSection(section);\n      default:\n        throw new Error(`Cannot render mobiledoc section of type \"${type}\"`);\n    }\n  }\n\n  renderMarkersOnElement(element, markers) {\n    let elements = [element];\n    let currentElement = element;\n\n    let pushElement = (openedElement) => {\n      currentElement.appendChild(openedElement);\n      elements.push(openedElement);\n      currentElement = openedElement;\n    };\n\n    for (let i=0, l=markers.length; i<l; i++) {\n      let marker = markers[i];\n      let [openTypes, closeCount, text] = marker;\n\n      for (let j=0, m=openTypes.length; j<m; j++) {\n        let markerType = this.markerTypes[openTypes[j]];\n        let [tagName, attrs=[]] = markerType;\n        if (isValidMarkerType(tagName)) {\n          pushElement(this.renderMarkupElement(tagName, attrs));\n        } else {\n          closeCount--;\n        }\n      }\n\n      currentElement.appendChild(createTextNode(this.dom, text));\n\n      for (let j=0, m=closeCount; j<m; j++) {\n        elements.pop();\n        currentElement = elements[elements.length - 1];\n      }\n    }\n  }\n\n  /**\n   * @param attrs Array\n   */\n  renderMarkupElement(tagName, attrs) {\n    tagName = tagName.toLowerCase();\n    attrs   = reduceAttributes(attrs);\n\n    let renderer = this.markupElementRendererFor(tagName);\n    return renderer(tagName, this.dom, attrs);\n  }\n\n  markupElementRendererFor(tagName) {\n    return this.markupElementRenderer[tagName] ||\n      this.markupElementRenderer.__default__;\n  }\n\n  renderListItem(markers) {\n    const element = this.dom.createElement('li');\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  renderListSection([type, tagName, listItems]) {\n    if (!isValidSectionTagName(tagName, LIST_SECTION_TYPE)) {\n      return;\n    }\n    const element = this.dom.createElement(tagName);\n    listItems.forEach(li => {\n      element.appendChild(this.renderListItem(li));\n    });\n    return element;\n  }\n\n  renderImageSection([type, src]) {\n    let element = this.dom.createElement(IMAGE_SECTION_TAG_NAME);\n    element.src = src;\n    return element;\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard.name) {\n      return ImageCard;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownCardHandler\n    };\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      dom: this.dom,\n      didRender: (callback) => this._registerRenderCallback(callback),\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  _registerRenderCallback(callback) {\n    this._renderCallbacks.push(callback);\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  renderCardSection([type, name, payload]) {\n    let card = this.findCard(name);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered;\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'object') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE}, but result was \"${rendered}\"`);\n    }\n  }\n\n  renderMarkupSection([type, tagName, markers]) {\n    tagName = tagName.toLowerCase();\n    if (!isValidSectionTagName(tagName, MARKUP_SECTION_TYPE)) {\n      return;\n    }\n\n    let renderer = this.sectionElementRendererFor(tagName);\n    let element = renderer(tagName, this.dom);\n\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  sectionElementRendererFor(tagName) {\n    return this.sectionElementRenderer[tagName] ||\n      this.sectionElementRenderer.__default__;\n  }\n}\n\n","export const MARKUP_MARKER_TYPE = 0;\nexport const ATOM_MARKER_TYPE = 1;","import { createTextNode } from '../utils/dom';\nimport ImageCard from '../cards/image';\nimport RENDER_TYPE from '../utils/render-type';\nimport {\n  MARKUP_SECTION_TYPE,\n  IMAGE_SECTION_TYPE,\n  LIST_SECTION_TYPE,\n  CARD_SECTION_TYPE\n} from '../utils/section-types';\nimport {\n  isValidSectionTagName,\n  isValidMarkerType\n} from '../utils/tag-names';\nimport {\n  reduceAttributes\n} from '../utils/sanitization-utils';\nimport {\n  defaultSectionElementRenderer,\n  defaultMarkupElementRenderer\n} from '../utils/render-utils';\n\nimport {\n  MARKUP_MARKER_TYPE,\n  ATOM_MARKER_TYPE\n} from '../utils/marker-types';\n\nexport const MOBILEDOC_VERSION_0_3_0 = '0.3.0';\nexport const MOBILEDOC_VERSION_0_3_1 = '0.3.1';\nexport const MOBILEDOC_VERSION_0_3_2 = '0.3.2';\n\nconst IMAGE_SECTION_TAG_NAME = 'img';\n\nfunction validateVersion(version) {\n  switch (version) {\n    case MOBILEDOC_VERSION_0_3_0:\n    case MOBILEDOC_VERSION_0_3_1:\n    case MOBILEDOC_VERSION_0_3_2:\n      return;\n    default:\n      throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nexport default class Renderer {\n  constructor(mobiledoc, state) {\n\n    let {\n      cards,\n      cardOptions,\n      atoms,\n      unknownCardHandler,\n      unknownAtomHandler,\n      markupElementRenderer,\n      sectionElementRenderer,\n      dom\n    } = state;\n    let {\n      version,\n      sections,\n      atoms: atomTypes,\n      cards: cardTypes,\n      markups: markerTypes\n    } = mobiledoc;\n    validateVersion(version);\n\n    this.dom                = dom;\n    this.root               = this.dom.createDocumentFragment();\n    this.sections           = sections;\n    this.atomTypes          = atomTypes;\n    this.cardTypes          = cardTypes;\n    this.markerTypes        = markerTypes;\n    this.cards              = cards;\n    this.atoms              = atoms;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n    this.unknownAtomHandler = unknownAtomHandler || this._defaultUnknownAtomHandler;\n\n    this.sectionElementRenderer = {\n      '__default__': defaultSectionElementRenderer\n    };\n    Object.keys(sectionElementRenderer).forEach(key => {\n      this.sectionElementRenderer[key.toLowerCase()] = sectionElementRenderer[key];\n    });\n\n    this.markupElementRenderer = {\n      '__default__': defaultMarkupElementRenderer\n    };\n    Object.keys(markupElementRenderer).forEach(key => {\n      this.markupElementRenderer[key.toLowerCase()] = markupElementRenderer[key];\n    });\n\n    this._renderCallbacks = [];\n    this._teardownCallbacks  = [];\n  }\n\n  get _defaultUnknownCardHandler() {\n    return ({env: {name}}) => {\n      throw new Error(`Card \"${name}\" not found but no unknownCardHandler was registered`);\n    };\n  }\n\n  get _defaultUnknownAtomHandler() {\n    return ({env: {name}}) => {\n      throw new Error(`Atom \"${name}\" not found but no unknownAtomHandler was registered`);\n    };\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      let rendered = this.renderSection(section);\n      if (rendered) {\n        this.root.appendChild(rendered);\n      }\n    });\n    for (let i=0; i < this._renderCallbacks.length; i++) {\n      this._renderCallbacks[i]();\n    }\n    // maintain a reference to child nodes so they can be cleaned up later by teardown\n    this._renderedChildNodes = Array.prototype.slice.call(this.root.childNodes);\n    return { result: this.root, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n    for (let i=0; i < this._renderedChildNodes.length; i++) {\n      let node = this._renderedChildNodes[i];\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n    }\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE:\n        return this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE:\n        return this.renderCardSection(section);\n      default:\n        throw new Error(`Cannot render mobiledoc section of type \"${type}\"`);\n    }\n  }\n\n  renderMarkersOnElement(element, markers) {\n    let elements = [element];\n    let currentElement = element;\n\n    let pushElement = (openedElement) => {\n      currentElement.appendChild(openedElement);\n      elements.push(openedElement);\n      currentElement = openedElement;\n    };\n\n    for (let i=0, l=markers.length; i<l; i++) {\n      let marker = markers[i];\n      let [type, openTypes, closeCount, value] = marker;\n\n      for (let j=0, m=openTypes.length; j<m; j++) {\n        let markerType = this.markerTypes[openTypes[j]];\n        let [tagName, attrs=[]] = markerType;\n\n        if (isValidMarkerType(tagName)) {\n          pushElement(this.renderMarkupElement(tagName, attrs));\n        } else {\n          closeCount--;\n        }\n      }\n\n      switch (type) {\n        case MARKUP_MARKER_TYPE:\n          currentElement.appendChild(createTextNode(this.dom, value));\n          break;\n        case ATOM_MARKER_TYPE:\n          currentElement.appendChild(this._renderAtom(value));\n          break;\n        default:\n          throw new Error(`Unknown markup type (${type})`);\n      }\n\n      for (let j=0, m=closeCount; j<m; j++) {\n        elements.pop();\n        currentElement = elements[elements.length - 1];\n      }\n    }\n  }\n\n  /**\n   * @param attrs Array\n   */\n  renderMarkupElement(tagName, attrs) {\n    tagName = tagName.toLowerCase();\n    attrs   = reduceAttributes(attrs);\n\n    let renderer = this.markupElementRendererFor(tagName);\n    return renderer(tagName, this.dom, attrs);\n  }\n\n  markupElementRendererFor(tagName) {\n    return this.markupElementRenderer[tagName] ||\n      this.markupElementRenderer.__default__;\n  }\n\n  renderListItem(markers) {\n    const element = this.dom.createElement('li');\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  renderListSection([type, tagName, listItems]) {\n    if (!isValidSectionTagName(tagName, LIST_SECTION_TYPE)) {\n      return;\n    }\n    const element = this.dom.createElement(tagName);\n    listItems.forEach(li => {\n      element.appendChild(this.renderListItem(li));\n    });\n    return element;\n  }\n\n  renderImageSection([type, src]) {\n    let element = this.dom.createElement(IMAGE_SECTION_TAG_NAME);\n    element.src = src;\n    return element;\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard.name) {\n      return ImageCard;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _findCardByIndex(index) {\n    let cardType = this.cardTypes[index];\n    if (!cardType) {\n      throw new Error(`No card definition found at index ${index}`);\n    }\n\n    let [ name, payload ] = cardType;\n    let card = this.findCard(name);\n\n    return {\n      card,\n      payload\n    };\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownCardHandler\n    };\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      dom: this.dom,\n      didRender: (callback) => this._registerRenderCallback(callback),\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  _registerRenderCallback(callback) {\n    this._renderCallbacks.push(callback);\n  }\n\n  renderCardSection([type, index]) {\n    let { card, payload } = this._findCardByIndex(index);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered;\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'object') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE}, but result was \"${rendered}\"`);\n    }\n  }\n\n  findAtom(name) {\n    for (let i=0; i < this.atoms.length; i++) {\n      if (this.atoms[i].name === name) {\n        return this.atoms[i];\n      }\n    }\n    return this._createUnknownAtom(name);\n  }\n\n  _createUnknownAtom(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownAtomHandler\n    };\n  }\n\n  _createAtomArgument(atom, value, payload) {\n    let env = {\n      name: atom.name,\n      isInEditor: false,\n      dom: this.dom,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, value, payload };\n  }\n\n  _validateAtomRender(rendered, atomName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'object') {\n      throw new Error(`Atom \"${atomName}\" must render ${RENDER_TYPE}, but result was \"${rendered}\"`);\n    }\n  }\n\n  _findAtomByIndex(index) {\n    let atomType = this.atomTypes[index];\n    if (!atomType) {\n      throw new Error(`No atom definition found at index ${index}`);\n    }\n\n    let [ name, value, payload ] = atomType;\n    let atom = this.findAtom(name);\n\n    return {\n      atom,\n      value,\n      payload\n    };\n  }\n\n  _renderAtom(index) {\n    let { atom, value, payload } = this._findAtomByIndex(index);\n\n    let atomArg = this._createAtomArgument(atom, value, payload);\n    let rendered = atom.render(atomArg);\n\n    this._validateAtomRender(rendered, atom.name);\n\n    return rendered || createTextNode(this.dom, '');\n  }\n\n  renderMarkupSection([type, tagName, markers, attributes = []]) {\n    tagName = tagName.toLowerCase();\n    if (!isValidSectionTagName(tagName, MARKUP_SECTION_TYPE)) {\n      return;\n    }\n\n    let attrsObj = reduceAttributes(attributes);\n    let renderer = this.sectionElementRendererFor(tagName);\n    let element = renderer(tagName, this.dom, attrsObj);\n\n    this.renderMarkersOnElement(element, markers);\n    return element;\n  }\n\n  sectionElementRendererFor(tagName) {\n    return this.sectionElementRenderer[tagName] ||\n      this.sectionElementRenderer.__default__;\n  }\n}\n\n"," import Renderer_0_2, {\n   MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_2\n } from './renderers/0-2';\n import Renderer_0_3, {\n   MOBILEDOC_VERSION_0_3_0,\n   MOBILEDOC_VERSION_0_3_1,\n   MOBILEDOC_VERSION_0_3_2\n } from './renderers/0-3';\n import RENDER_TYPE from './utils/render-type';\n\n/**\n * runtime DOM renderer\n * renders a mobiledoc to DOM\n *\n * input: mobiledoc\n * output: DOM\n */\n\n function validateCards(cards) {\n   if (!Array.isArray(cards)) {\n     throw new Error('`cards` must be passed as an array');\n   }\n   for (let i=0; i < cards.length; i++) {\n     let card = cards[i];\n     if (card.type !== RENDER_TYPE) {\n       throw new Error(`Card \"${card.name}\" must be of type \"${RENDER_TYPE}\", was \"${card.type}\"`);\n     }\n     if (!card.render) {\n       throw new Error(`Card \"${card.name}\" must define \\`render\\``);\n     }\n   }\n }\n\n function validateAtoms(atoms) {\n   if (!Array.isArray(atoms)) {\n     throw new Error('`atoms` must be passed as an array');\n   }\n   for (let i=0; i < atoms.length; i++) {\n     let atom = atoms[i];\n     if (atom.type !== RENDER_TYPE) {\n       throw new Error(`Atom \"${atom.name}\" must be type \"${RENDER_TYPE}\", was \"${atom.type}\"`);\n     }\n     if (!atom.render) {\n       throw new Error(`Atom \"${atom.name}\" must define \\`render\\``);\n     }\n   }\n }\n\n export default class RendererFactory {\n   constructor({\n     cards=[],\n     atoms=[],\n     cardOptions={},\n     unknownCardHandler,\n     unknownAtomHandler,\n     markupElementRenderer={},\n     sectionElementRenderer={},\n     dom,\n     markupSanitizer=null\n   }={}) {\n     validateCards(cards);\n     validateAtoms(atoms);\n\n     if (!dom) {\n       if (typeof window === 'undefined') {\n         throw new Error('A `dom` option must be provided to the renderer when running without window.document');\n       }\n       dom = window.document;\n     }\n\n     this.options = {\n       cards,\n       atoms,\n       cardOptions,\n       unknownCardHandler,\n       unknownAtomHandler,\n       markupElementRenderer,\n       sectionElementRenderer,\n       dom,\n       markupSanitizer\n     };\n   }\n\n   render(mobiledoc) {\n     let { version } = mobiledoc;\n     switch (version) {\n       case MOBILEDOC_VERSION_0_2:\n       case undefined:\n       case null:\n         return new Renderer_0_2(mobiledoc, this.options).render();\n       case MOBILEDOC_VERSION_0_3_0:\n       case MOBILEDOC_VERSION_0_3_1:\n       case MOBILEDOC_VERSION_0_3_2:\n         return new Renderer_0_3(mobiledoc, this.options).render();\n       default:\n         throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n     }\n   }\n }\n","export default {\n  name: 'image-card',\n  type: 'text',\n  render() {}\n};\n","export default 'text';\n","export const MARKUP_SECTION_TYPE = 1;\nexport const IMAGE_SECTION_TYPE = 2;\nexport const LIST_SECTION_TYPE = 3;\nexport const CARD_SECTION_TYPE = 10;\n\n","/**\n * runtime Text renderer\n * renders a mobiledoc to Text\n *\n * input: mobiledoc\n * output: Text (string)\n */\nimport ImageCard from '../cards/image';\nimport RENDER_TYPE from '../utils/render-type';\n\nconst LINE_BREAK = '\\n';\n\nimport {\n  MARKUP_SECTION_TYPE,\n  LIST_SECTION_TYPE,\n  CARD_SECTION_TYPE,\n  IMAGE_SECTION_TYPE\n} from '../utils/section-types';\n\nexport const MOBILEDOC_VERSION = '0.2.0';\n\nfunction validateVersion(version) {\n  if (version !== MOBILEDOC_VERSION) {\n    throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nexport default class Renderer {\n  constructor(mobiledoc, state) {\n    let { cards, cardOptions, atoms, unknownCardHandler } = state;\n    let { version, sections: sectionData } = mobiledoc;\n    validateVersion(version);\n\n    let [, sections] = sectionData;\n\n    this.root               = [];\n    this.sections           = sections;\n    this.cards              = cards;\n    this.atoms              = atoms;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n\n    this._teardownCallbacks  = [];\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      this.root.push(this.renderSection(section));\n    });\n\n    let result = this.root.join(LINE_BREAK);\n    return { result, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n  }\n\n  get _defaultUnknownCardHandler() {\n    return () => {\n      // for the text renderer, a missing card is a no-op\n    };\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE:\n        return  this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE:\n        return this.renderCardSection(section);\n      default:\n        throw new Error('Unimplemented renderer for type ' + type);\n    }\n  }\n\n  renderImageSection() {\n    return '';\n  }\n\n  renderListSection([type, tagName, items]) {\n    return items.map(\n      li => this.renderListItem(li)\n    ).join(LINE_BREAK);\n  }\n\n  renderListItem(markers) {\n    return this.renderMarkers(markers);\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard.name) {\n      return ImageCard;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownCardHandler\n    };\n  }\n\n  renderCardSection([type, name, payload]) {\n    let card = this.findCard(name);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered || '';\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'string') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE}, but result was ${typeof rendered}\"`);\n    }\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  renderMarkupSection([type, tagName, markers]) {\n    return this.renderMarkers(markers);\n  }\n\n  renderMarkers(markers) {\n    let str = '';\n    markers.forEach(m => {\n      let [, , text] = m;\n      str += text;\n    });\n    return str;\n  }\n}\n","export const MARKUP_MARKER_TYPE = 0;\nexport const ATOM_MARKER_TYPE = 1;","/**\n * runtime Text renderer\n * renders a mobiledoc to Text\n *\n * input: mobiledoc\n * output: Text (string)\n */\nimport ImageCard from '../cards/image';\nimport RENDER_TYPE from '../utils/render-type';\n\nconst LINE_BREAK = '\\n';\n\nimport {\n  MARKUP_SECTION_TYPE,\n  LIST_SECTION_TYPE,\n  CARD_SECTION_TYPE,\n  IMAGE_SECTION_TYPE\n} from '../utils/section-types';\n\nimport {\n  MARKUP_MARKER_TYPE,\n  ATOM_MARKER_TYPE\n} from '../utils/marker-types';\n\nexport const MOBILEDOC_VERSION_0_3 = '0.3.0';\nexport const MOBILEDOC_VERSION_0_3_1 = '0.3.1';\nexport const MOBILEDOC_VERSION_0_3_2 = '0.3.2';\n\nfunction validateVersion(version) {\n  if (\n    version !== MOBILEDOC_VERSION_0_3 &&\n    version !== MOBILEDOC_VERSION_0_3_1 &&\n    version !== MOBILEDOC_VERSION_0_3_2\n  ) {\n    throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n  }\n}\n\nexport default class Renderer {\n  constructor(mobiledoc, state) {\n\n    let { cards, cardOptions, atoms, unknownCardHandler, unknownAtomHandler } = state;\n    let { version, sections, atoms: atomTypes, cards: cardTypes } = mobiledoc;\n    validateVersion(version);\n\n    this.root               = [];\n    this.sections           = sections;\n    this.atomTypes          = atomTypes;\n    this.cardTypes          = cardTypes;\n    this.cards              = cards;\n    this.atoms              = atoms;\n    this.cardOptions        = cardOptions;\n    this.unknownCardHandler = unknownCardHandler || this._defaultUnknownCardHandler;\n    this.unknownAtomHandler = unknownAtomHandler || this._defaultUnknownAtomHandler;\n\n    this._teardownCallbacks  = [];\n  }\n\n  render() {\n    this.sections.forEach(section => {\n      this.root.push(this.renderSection(section));\n    });\n\n    let result = this.root.join(LINE_BREAK);\n    return { result, teardown: () => this.teardown() };\n  }\n\n  teardown() {\n    for (let i=0; i < this._teardownCallbacks.length; i++) {\n      this._teardownCallbacks[i]();\n    }\n  }\n\n  get _defaultUnknownCardHandler() {\n    return () => {\n      // for the text renderer, a missing card is a no-op\n    };\n  }\n\n  get _defaultUnknownAtomHandler() {\n    return ({ value }) => {\n      return value || '';\n    };\n  }\n\n  renderSection(section) {\n    const [type] = section;\n    switch (type) {\n      case MARKUP_SECTION_TYPE:\n        return  this.renderMarkupSection(section);\n      case IMAGE_SECTION_TYPE:\n        return this.renderImageSection(section);\n      case LIST_SECTION_TYPE:\n        return this.renderListSection(section);\n      case CARD_SECTION_TYPE:\n        return this.renderCardSection(section);\n      default:\n        throw new Error('Unimplemented renderer for type ' + type);\n    }\n  }\n\n  renderImageSection() {\n    return '';\n  }\n\n  renderListSection([type, tagName, items]) {\n    return items.map(\n      li => this.renderListItem(li)\n    ).join(LINE_BREAK);\n  }\n\n  renderListItem(markers) {\n    return this.renderMarkers(markers);\n  }\n\n  findCard(name) {\n    for (let i=0; i < this.cards.length; i++) {\n      if (this.cards[i].name === name) {\n        return this.cards[i];\n      }\n    }\n    if (name === ImageCard.name) {\n      return ImageCard;\n    }\n    return this._createUnknownCard(name);\n  }\n\n  _findCardByIndex(index) {\n    let cardType = this.cardTypes[index];\n    if (!cardType) {\n      throw new Error(`No card definition found at index ${index}`);\n    }\n\n    let [ name, payload ] = cardType;\n    let card = this.findCard(name);\n\n    return {\n      card,\n      payload\n    };\n  }\n\n  _createUnknownCard(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownCardHandler\n    };\n  }\n\n  renderCardSection([type, index]) {\n    let { card, payload } = this._findCardByIndex(index);\n\n    let cardArg = this._createCardArgument(card, payload);\n    let rendered = card.render(cardArg);\n\n    this._validateCardRender(rendered, card.name);\n\n    return rendered || '';\n  }\n\n  _validateCardRender(rendered, cardName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'string') {\n      throw new Error(`Card \"${cardName}\" must render ${RENDER_TYPE}, but result was ${typeof rendered}\"`);\n    }\n  }\n\n  _registerTeardownCallback(callback) {\n    this._teardownCallbacks.push(callback);\n  }\n\n  _createCardArgument(card, payload={}) {\n    let env = {\n      name: card.name,\n      isInEditor: false,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, payload };\n  }\n\n  renderMarkupSection([type, tagName, markers]) {\n    return this.renderMarkers(markers);\n  }\n\n  findAtom(name) {\n    for (let i=0; i < this.atoms.length; i++) {\n      if (this.atoms[i].name === name) {\n        return this.atoms[i];\n      }\n    }\n    return this._createUnknownAtom(name);\n  }\n\n  _createUnknownAtom(name) {\n    return {\n      name,\n      type: RENDER_TYPE,\n      render: this.unknownAtomHandler\n    };\n  }\n\n  _createAtomArgument(atom, value, payload) {\n    let env = {\n      name: atom.name,\n      onTeardown: (callback) => this._registerTeardownCallback(callback)\n    };\n\n    let options = this.cardOptions;\n\n    return { env, options, value, payload };\n  }\n\n  _validateAtomRender(rendered, atomName) {\n    if (!rendered) {\n      return;\n    }\n\n    if (typeof rendered !== 'string') {\n      throw new Error(`Atom \"${atomName}\" must render ${RENDER_TYPE}, but result was ${typeof rendered}\"`);\n    }\n  }\n\n  _findAtomByIndex(index) {\n    let atomType = this.atomTypes[index];\n    if (!atomType) {\n      throw new Error(`No atom definition found at index ${index}`);\n    }\n\n    let [ name, value, payload ] = atomType;\n    let atom = this.findAtom(name);\n\n    return {\n      atom,\n      value,\n      payload\n    };\n  }\n\n  _renderAtom(index) {\n    let { atom, value, payload } = this._findAtomByIndex(index);\n\n    let atomArg = this._createAtomArgument(atom, value, payload);\n    let rendered = atom.render(atomArg);\n\n    this._validateAtomRender(rendered, atom.name);\n\n    return rendered || '';\n  }\n\n  renderMarkers(markers) {\n    let str = '';\n    markers.forEach(m => {\n      let [type, , , value] = m;\n      switch (type) {\n        case MARKUP_MARKER_TYPE:\n          str += value;\n          break;\n        case ATOM_MARKER_TYPE:\n          str += this._renderAtom(value);\n          break;\n        default:\n          throw new Error(`Unknown markup type (${type})`);\n      }\n    });\n    return str;\n  }\n}\n","import Renderer_0_2, {\n  MOBILEDOC_VERSION as MOBILEDOC_VERSION_0_2\n} from './renderers/0-2';\nimport Renderer_0_3, {\n  MOBILEDOC_VERSION_0_3,\n  MOBILEDOC_VERSION_0_3_1,\n  MOBILEDOC_VERSION_0_3_2\n} from './renderers/0-3';\nimport RENDER_TYPE from './utils/render-type';\n/**\n * runtime Text renderer\n * renders a mobiledoc to Text\n *\n * input: mobiledoc\n * output: Text (string)\n */\n\nfunction validateCards(cards) {\n  if (!Array.isArray(cards)) {\n    throw new Error('`cards` must be passed as an array');\n  }\n  for (let i=0; i < cards.length; i++) {\n    let card = cards[i];\n    if (card.type !== RENDER_TYPE) {\n      throw new Error(`Card \"${card.name}\" must be type \"${RENDER_TYPE}\", was \"${card.type}\"`);\n    }\n    if (!card.render) {\n      throw new Error(`Card \"${card.name}\" must define \\`render\\``);\n    }\n  }\n}\n\nfunction validateAtoms(atoms) {\n  if (!Array.isArray(atoms)) {\n    throw new Error('`atoms` must be passed as an array');\n  }\n  for (let i=0; i < atoms.length; i++) {\n    let atom = atoms[i];\n    if (atom.type !== RENDER_TYPE) {\n      throw new Error(`Atom \"${atom.name}\" must be type \"${RENDER_TYPE}\", was \"${atom.type}\"`);\n    }\n    if (!atom.render) {\n      throw new Error(`Atom \"${atom.name}\" must define \\`render\\``);\n    }\n  }\n}\n\nexport default class RendererFactory {\n  constructor({cards, atoms, cardOptions, unknownCardHandler, unknownAtomHandler}={}) {\n    cards = cards || [];\n    validateCards(cards);\n    atoms = atoms || [];\n    validateAtoms(atoms);\n    cardOptions = cardOptions || {};\n\n    this.state = {cards, atoms, cardOptions, unknownCardHandler, unknownAtomHandler};\n  }\n\n  render(mobiledoc) {\n    let { version } = mobiledoc;\n    switch (version) {\n      case MOBILEDOC_VERSION_0_2:\n        return new Renderer_0_2(mobiledoc, this.state).render();\n      case undefined:\n      case null:\n      case MOBILEDOC_VERSION_0_3:\n      case MOBILEDOC_VERSION_0_3_1:\n      case MOBILEDOC_VERSION_0_3_2:\n        return new Renderer_0_3(mobiledoc, this.state).render();\n      default:\n        throw new Error(`Unexpected Mobiledoc version \"${version}\"`);\n    }\n  }\n}\n","export class Logger {\n  type: string\n  manager: LogManager\n\n  constructor(type: string, manager: LogManager) {\n    this.type = type\n    this.manager = manager\n  }\n\n  isEnabled() {\n    return this.manager.isEnabled(this.type)\n  }\n\n  log(...args: unknown[]) {\n    args.unshift(`[${this.type}]`)\n    if (this.isEnabled()) {\n      window.console.log(...args)\n    }\n  }\n}\n\nexport default class LogManager {\n  enabledTypes: string[]\n  allEnabled: boolean\n\n  constructor() {\n    this.enabledTypes = []\n    this.allEnabled = false\n  }\n\n  for(type: string) {\n    return new Logger(type, this)\n  }\n\n  enableAll() {\n    this.allEnabled = true\n  }\n\n  enableTypes(types: string[]) {\n    this.enabledTypes = this.enabledTypes.concat(types)\n  }\n\n  disable() {\n    this.enabledTypes = []\n    this.allEnabled = false\n  }\n\n  isEnabled(type: string) {\n    return this.allEnabled || this.enabledTypes.indexOf(type) !== -1\n  }\n}\n","import Tooltip, { DEFAULT_TOOLTIP_PLUGIN, TooltipPlugin } from '../views/tooltip'\nimport PostEditor from './post'\nimport ImageCard from '../cards/image'\nimport { Direction } from '../utils/key'\nimport mobiledocParsers from '../parsers/mobiledoc'\nimport HTMLParser from '../parsers/html'\nimport DOMParser from '../parsers/dom'\nimport Renderer from '../renderers/editor-dom'\nimport RenderTree from '../models/render-tree'\nimport mobiledocRenderers, { MobiledocVersion } from '../renderers/mobiledoc'\nimport { MOBILEDOC_VERSION } from '../renderers/mobiledoc'\nimport { mergeWithOptions } from '../utils/merge'\nimport { normalizeTagName, clearChildNodes, serializeHTML } from '../utils/dom-utils'\nimport { forEach, filter, contains, values, detect } from '../utils/array-utils'\nimport { setData } from '../utils/element-utils'\nimport Cursor from '../utils/cursor'\nimport Range from '../utils/cursor/range'\nimport Position from '../utils/cursor/position'\nimport Environment from '../utils/environment'\nimport PostNodeBuilder from '../models/post-node-builder'\nimport { DEFAULT_TEXT_INPUT_HANDLERS } from './text-input-handlers'\nimport {\n  DEFAULT_KEY_COMMANDS,\n  buildKeyCommand,\n  findKeyCommands,\n  validateKeyCommand,\n  KeyCommand,\n  CompiledKeyCommand,\n} from './key-commands'\nimport Card, { CardMode, CardPayload } from '../models/card'\nimport assert from '../utils/assert'\nimport MutationHandler from '../editor/mutation-handler'\nimport EditHistory from '../editor/edit-history'\nimport EventManager, { DOMEventType, DOMEventForType } from '../editor/event-manager'\nimport EditState from '../editor/edit-state'\nimport DOMRenderer from 'mobiledoc-dom-renderer'\nimport TextRenderer from 'mobiledoc-text-renderer'\nimport LifecycleCallbacks, { LifecycleCallback } from '../models/lifecycle-callbacks'\nimport LogManager from '../utils/log-manager'\nimport toRange from '../utils/to-range'\nimport MobiledocError from '../utils/mobiledoc-error'\nimport Post from '../models/post'\nimport { Mobiledoc } from '../renderers/mobiledoc'\nimport { SectionParserPlugin } from '../parsers/section'\nimport { CardData, CardRenderHook } from '../models/card-node'\nimport { AtomData } from '../models/atom-node'\nimport { Option, Maybe, Dict } from '../utils/types'\nimport Markup from '../models/markup'\nimport View from '../views/view'\nimport Atom, { AtomPayload } from '../models/atom'\nimport Section, { isNested } from '../models/_section'\nimport { TextInputHandlerListener } from './text-input-handler'\n\n// This export may later be deprecated, but re-export it from the renderer here\n// for consumers that may depend on it.\nexport { EDITOR_ELEMENT_CLASS_NAME } from '../renderers/editor-dom'\n\nexport interface EditorOptions {\n  parserPlugins?: SectionParserPlugin[]\n  placeholder?: string\n  spellcheck?: boolean\n  autofocus?: boolean\n  showLinkTooltips?: boolean\n  undoDepth?: number\n  undoBlockTimeout?: number\n  cards?: CardData[]\n  atoms?: AtomData[]\n  cardOptions?: {}\n  unknownCardHandler?: CardRenderHook\n  unknownAtomHandler?: CardRenderHook\n  mobiledoc?: Option<Mobiledoc>\n  html?: Option<string>\n  tooltipPlugin?: TooltipPlugin\n\n  /** @internal */\n  nodeType?: number\n}\n\nconst defaults: EditorOptions = {\n  placeholder: 'Write here...',\n  spellcheck: true,\n  autofocus: true,\n  showLinkTooltips: true,\n  undoDepth: 5,\n  undoBlockTimeout: 5000, // ms for an undo event\n  cards: [],\n  atoms: [],\n  cardOptions: {},\n  unknownCardHandler: ({ env }) => {\n    throw new MobiledocError(`Unknown card encountered: ${env.name}`)\n  },\n  unknownAtomHandler: ({ env }) => {\n    throw new MobiledocError(`Unknown atom encountered: ${env.name}`)\n  },\n  mobiledoc: null,\n  html: null,\n  tooltipPlugin: DEFAULT_TOOLTIP_PLUGIN,\n}\n\nconst CALLBACK_QUEUES = {\n  DID_UPDATE: 'didUpdate',\n  WILL_RENDER: 'willRender',\n  DID_RENDER: 'didRender',\n  WILL_DELETE: 'willDelete',\n  DID_DELETE: 'didDelete',\n  WILL_HANDLE_NEWLINE: 'willHandleNewline',\n  CURSOR_DID_CHANGE: 'cursorDidChange',\n  DID_REPARSE: 'didReparse',\n  POST_DID_CHANGE: 'postDidChange',\n  INPUT_MODE_DID_CHANGE: 'inputModeDidChange',\n  WILL_COPY: 'willCopy',\n  WILL_PASTE: 'willPaste',\n}\n\nexport enum Format {\n  MOBILEDOC = 'mobiledoc',\n  HTML = 'html',\n  TEXT = 'text',\n}\n\nexport interface SerializeOptions {\n  version?: MobiledocVersion\n}\n\nexport interface InputHandler {\n  /** Used by identifying handlers. */\n  name: string\n  /** Required if `match` is not provided. */\n  text?: string\n  /** Required if `text` is not provided. */\n  match?: RegExp\n  /**\n   * This callback is invoked with the {@link Editor} instance and an array of\n   * matches. If `text` was provided, the matches array will equal [`text`],\n   * and if a `match` regex was provided the matches array will be the result\n   * of `match.exec` on the matching text. The callback is called after the\n   * matching text has been inserted.\n   */\n  run: (editor: Editor, matches: string[]) => void\n}\n\nexport enum TextUnit {\n  CHAR = 'char',\n  WORD = 'word',\n}\n\ninterface DeleteOperation {\n  direction: Direction\n  unit: TextUnit\n}\n\ninterface BeforeHooks {\n  toggleMarkup: LifecycleCallback[]\n}\n\n/**\n * The Editor is a core component of mobiledoc-kit. After instantiating\n * an editor, use {@link Editor#render} to display the editor on the web page.\n *\n * An editor uses a {@link Post} internally to represent the displayed document.\n * The post can be serialized as mobiledoc using {@link Editor#serialize}. Mobiledoc\n * is the transportable \"over-the-wire\" format (JSON) that is suited for persisting\n * and sharing between editors and renderers (for display, e.g.), whereas the Post\n * model is better suited for programmatic editing.\n *\n * The editor will call registered callbacks for certain state changes. These are:\n *   * {@link Editor#cursorDidChange} -- The cursor position or selection changed.\n *   * {@link Editor#postDidChange} -- The contents of the post changed due to user input or\n *     programmatic editing. This hook can be used with {@link Editor#serialize}\n *     to auto-save a post as it is being edited.\n *   * {@link Editor#inputModeDidChange} -- The active section(s) or markup(s) at the current cursor\n *     position or selection have changed. This hook can be used with\n *     {@link Editor#activeMarkups} and {@link Editor#activeSections} to implement\n *     a custom toolbar.\n *   * {@link Editor#onTextInput} -- Register callbacks when the user enters text\n *     that matches a given string or regex.\n *   * {@link Editor#beforeToggleMarkup} -- Register callbacks that will be run before\n *     applying changes from {@link Editor#toggleMarkup}\n */\nexport default class Editor implements EditorOptions {\n  post: Post\n  cards!: CardData[]\n  atoms!: AtomData[]\n  element!: HTMLElement\n\n  isEditable: boolean\n  hasRendered: boolean\n  isDestroyed: boolean\n\n  undoDepth!: number\n  parserPlugins!: SectionParserPlugin[]\n  placeholder!: string\n  spellcheck!: boolean\n  autofocus!: boolean\n  showLinkTooltips!: boolean\n  undoBlockTimeout!: number\n  cardOptions!: {}\n  unknownCardHandler!: CardRenderHook\n  unknownAtomHandler!: CardRenderHook\n  mobiledoc!: Option<Mobiledoc>\n  html!: Option<string>\n  text!: Option<string>\n  tooltipPlugin!: TooltipPlugin\n\n  _views: View[]\n  _keyCommands?: CompiledKeyCommand[]\n  _parserPlugins: SectionParserPlugin[]\n  _logManager: LogManager\n  _parser: DOMParser\n  _builder!: PostNodeBuilder\n  _renderer: Renderer\n  _renderTree: RenderTree\n  _editHistory: EditHistory\n  _eventManager: EventManager\n  _mutationHandler: MutationHandler\n  _editState: EditState\n  _callbacks: LifecycleCallbacks\n  _beforeHooks: BeforeHooks\n  _isComposingOnBlankLine: boolean\n\n  /**\n   * @param {Object} [options]\n   * @param {Object} [options.mobiledoc] The mobiledoc to load into the editor.\n   *        Supersedes `options.html`.\n   * @param {String|DOM} [options.html] The html (as a string or DOM fragment)\n   *        to parse and load into the editor.\n   *        Will be ignored if `options.mobiledoc` is also passed.\n   * @param {Array} [options.parserPlugins=[]]\n   * @param {Array} [options.cards=[]] The cards that the editor may render.\n   * @param {Array} [options.atoms=[]] The atoms that the editor may render.\n   * @param {Function} [options.unknownCardHandler] Invoked by the editor's renderer\n   *        whenever it encounters an unknown card.\n   * @param {Function} [options.unknownAtomHandler] Invoked by the editor's renderer\n   *        whenever it encounters an unknown atom.\n   * @param {String} [options.placeholder] Default text to show before user starts typing.\n   * @param {Boolean} [options.spellcheck=true] Whether to enable spellcheck\n   * @param {Boolean} [options.autofocus=true] Whether to focus the editor when it is first rendered.\n   * @param {Boolean} [options.showLinkTooltips=true] Whether to show the url tooltip for links\n   * @param {number} [options.undoDepth=5] How many undo levels will be available.\n   *        Set to 0 to disable undo/redo functionality.\n   * @public\n   */\n  constructor(options: EditorOptions = {}) {\n    assert(\n      'editor create accepts an options object. For legacy usage passing an element for the first argument, consider the `html` option for loading DOM or HTML posts. For other cases call `editor.render(domNode)` after editor creation',\n      options && !options.nodeType\n    )\n    this._views = []\n    this.isEditable = true\n    this._parserPlugins = options.parserPlugins || []\n\n    // FIXME: This should merge onto this.options\n    mergeWithOptions(this, defaults, options)\n    this.cards.push(ImageCard)\n\n    DEFAULT_KEY_COMMANDS.forEach(kc => this.registerKeyCommand(kc))\n\n    this._logManager = new LogManager()\n    this._parser = new DOMParser(this.builder)\n    let { cards, atoms, unknownCardHandler, unknownAtomHandler, cardOptions } = this\n    this._renderer = new Renderer(this, cards, atoms, unknownCardHandler, unknownAtomHandler, cardOptions)\n\n    this.post = this.loadPost()\n    this._renderTree = new RenderTree(this.post)\n\n    this._editHistory = new EditHistory(this, this.undoDepth, this.undoBlockTimeout)\n    this._eventManager = new EventManager(this)\n    this._mutationHandler = new MutationHandler(this)\n    this._editState = new EditState(this)\n    this._callbacks = new LifecycleCallbacks(values(CALLBACK_QUEUES))\n    this._beforeHooks = { toggleMarkup: [] }\n\n    this._isComposingOnBlankLine = false\n\n    DEFAULT_TEXT_INPUT_HANDLERS.forEach(handler => this.onTextInput(handler))\n\n    this.hasRendered = false\n    this.isDestroyed = false\n  }\n\n  /**\n   * Turns on verbose logging for the editor.\n   * @param {Array} [logTypes=[]] If present, only the given log types will be logged.\n   * @public\n   */\n  enableLogging(logTypes: string[] = []): void {\n    if (logTypes.length === 0) {\n      this._logManager.enableAll()\n    } else {\n      this._logManager.enableTypes(logTypes)\n    }\n  }\n\n  /**\n   * Disable all logging\n   * @public\n   */\n  disableLogging() {\n    this._logManager.disable()\n  }\n\n  /**\n   * @private\n   */\n  loggerFor(type: string) {\n    return this._logManager.for(type)\n  }\n\n  /**\n   * The editor's instance of a post node builder.\n   * @type {PostNodeBuilder}\n   */\n  get builder() {\n    if (!this._builder) {\n      this._builder = new PostNodeBuilder()\n    }\n    return this._builder\n  }\n\n  loadPost() {\n    let { mobiledoc, html } = this\n    if (mobiledoc) {\n      return mobiledocParsers.parse(this.builder, mobiledoc)\n    } else if (html) {\n      if (typeof html === 'string') {\n        let options = { plugins: this._parserPlugins }\n        return new HTMLParser(this.builder, options).parse(html)\n      } else {\n        let dom = html\n        return this._parser.parse(dom)\n      }\n    } else {\n      return this.builder.createPost([this.builder.createMarkupSection()])\n    }\n  }\n\n  rerender() {\n    let postRenderNode = this.post.renderNode\n\n    // if we haven't rendered this post's renderNode before, mark it dirty\n    if (!postRenderNode.element) {\n      assert('Must call `render` before `rerender` can be called', this.hasRendered)\n      postRenderNode.element = this.element\n      postRenderNode.markDirty()\n    }\n\n    this.runCallbacks(CALLBACK_QUEUES.WILL_RENDER)\n    this._mutationHandler.suspendObservation(() => {\n      this._renderer.render(this._renderTree)\n    })\n    this.runCallbacks(CALLBACK_QUEUES.DID_RENDER)\n  }\n\n  /**\n   * @param {Element} element The DOM element to render into.\n   *        Its contents will be replaced by the editor's rendered post.\n   * @public\n   */\n  render(element: HTMLElement) {\n    assert(\n      'Cannot render an editor twice. Use `rerender` to update the ' + 'rendering of an existing editor instance.',\n      !this.hasRendered\n    )\n\n    element.spellcheck = this.spellcheck\n\n    clearChildNodes(element)\n\n    this.element = element\n\n    if (this.showLinkTooltips) {\n      this._addTooltip()\n    }\n\n    // A call to `run` will trigger the didUpdatePostCallbacks hooks with a\n    // postEditor.\n    this.run(() => {})\n\n    // Only set `hasRendered` to true after calling `run` to ensure that\n    // no cursorDidChange or other callbacks get fired before the editor is\n    // done rendering\n    this.hasRendered = true\n    this.rerender()\n\n    this._mutationHandler.init()\n    this._eventManager.init()\n\n    if (this.isEditable === false) {\n      this.disableEditing()\n    } else {\n      this.enableEditing()\n    }\n\n    if (this.autofocus) {\n      this.selectRange(this.post.headPosition())\n    }\n  }\n\n  _addTooltip() {\n    this.addView(\n      new Tooltip({\n        rootElement: this.element,\n        showForTag: 'a',\n        editor: this,\n      })\n    )\n  }\n\n  get keyCommands() {\n    if (!this._keyCommands) {\n      this._keyCommands = []\n    }\n    return this._keyCommands\n  }\n\n  /**\n   * @param {Object} keyCommand The key command to register. It must specify a\n   * modifier key (meta, ctrl, etc), a string representing the ascii key, and\n   * a `run` method that will be passed the editor instance when the key command\n   * is invoked\n   * @public\n   */\n  registerKeyCommand(rawKeyCommand: KeyCommand) {\n    const keyCommand = buildKeyCommand(rawKeyCommand)\n    assert('Key Command is not valid', validateKeyCommand(keyCommand))\n    this.keyCommands.unshift(keyCommand)\n  }\n\n  /**\n   * @param {String} name If the keyCommand event has a name attribute it can be removed.\n   * @public\n   */\n  unregisterKeyCommands(name: string) {\n    for (let i = this.keyCommands.length - 1; i > -1; i--) {\n      let keyCommand = this.keyCommands[i]\n\n      if (keyCommand.name === name) {\n        this.keyCommands.splice(i, 1)\n      }\n    }\n  }\n\n  /**\n   * Convenience for {@link PostEditor#deleteAtPosition}. Deletes and puts the\n   * cursor in the new position.\n   * @public\n   */\n  deleteAtPosition(position: Position, direction: number, { unit }: { unit: TextUnit }) {\n    this.run(postEditor => {\n      let nextPosition = postEditor.deleteAtPosition(position, direction, { unit })\n      postEditor.setRange(nextPosition)\n    })\n  }\n\n  /**\n   * Convenience for {@link PostEditor#deleteRange}. Deletes and puts the\n   * cursor in the new position.\n   * @param {Range} range\n   * @public\n   */\n  deleteRange(range: Range) {\n    this.run(postEditor => {\n      let nextPosition = postEditor.deleteRange(range)\n      postEditor.setRange(nextPosition)\n    })\n  }\n\n  /**\n   * @private\n   */\n  performDelete({ direction, unit }: DeleteOperation = { direction: Direction.BACKWARD, unit: TextUnit.CHAR }) {\n    const { range } = this\n\n    this.runCallbacks(CALLBACK_QUEUES.WILL_DELETE, [range, direction, unit])\n    if (range.isCollapsed) {\n      this.deleteAtPosition(range.head, direction, { unit })\n    } else {\n      this.deleteRange(range)\n    }\n    this.runCallbacks(CALLBACK_QUEUES.DID_DELETE, [range, direction, unit])\n  }\n\n  handleNewline(event: Event) {\n    if (!this.hasCursor()) {\n      return\n    }\n\n    event.preventDefault()\n\n    let { range } = this\n    this.run(postEditor => {\n      let cursorSection: Option<Section>\n      if (!range.isCollapsed) {\n        let nextPosition = postEditor.deleteRange(range)\n        cursorSection = nextPosition.section\n        if (cursorSection && cursorSection.isBlank) {\n          postEditor.setRange(cursorSection.headPosition())\n          return\n        }\n      }\n\n      // Above logic might delete redundant range, so callback must run after it.\n      let defaultPrevented = false\n      const event = {\n        preventDefault() {\n          defaultPrevented = true\n        },\n      }\n      this.runCallbacks(CALLBACK_QUEUES.WILL_HANDLE_NEWLINE, [event])\n      if (defaultPrevented) {\n        return\n      }\n\n      cursorSection = postEditor.splitSection(range.head)[1]\n      postEditor.setRange(cursorSection!.headPosition())\n    })\n  }\n\n  /**\n   * Notify the editor that the post did change, and run associated\n   * callbacks.\n   * @private\n   */\n  _postDidChange() {\n    this.runCallbacks(CALLBACK_QUEUES.POST_DID_CHANGE)\n  }\n\n  /**\n   * Selects the given range or position. If given a collapsed range or a position, this positions the cursor\n   * at the range's position. Otherwise a selection is created in the editor\n   * surface encompassing the range.\n   * @param {Range|Position} range\n   */\n  selectRange(range: Range | Position) {\n    range = toRange(range)\n\n    this.cursor.selectRange(range)\n    this.range = range\n  }\n\n  get cursor() {\n    return new Cursor(this)\n  }\n\n  /**\n   * Return the current range for the editor (may be cached).\n   * @return {Range}\n   */\n  get range(): Range {\n    return this._editState.range\n  }\n\n  set range(newRange) {\n    this._editState.updateRange(newRange)\n\n    if (this._editState.rangeDidChange()) {\n      this._rangeDidChange()\n    }\n\n    if (this._editState.inputModeDidChange()) {\n      this._inputModeDidChange()\n    }\n  }\n\n  _readRangeFromDOM() {\n    this.range = this.cursor.offsets\n  }\n\n  setPlaceholder(placeholder: string) {\n    setData(this.element, 'placeholder', placeholder)\n  }\n\n  _reparsePost() {\n    let post = this._parser.parse(this.element)\n    this.run(postEditor => {\n      postEditor.removeAllSections()\n      postEditor.migrateSectionsFromPost(post)\n      postEditor.setRange(Range.blankRange())\n    })\n\n    this.runCallbacks(CALLBACK_QUEUES.DID_REPARSE)\n    this._postDidChange()\n  }\n\n  _reparseSections(sections: Section[] = []) {\n    let currentRange: Maybe<Range>\n\n    sections.forEach(section => {\n      this._parser.reparseSection(section, this._renderTree)\n    })\n    this._removeDetachedSections()\n\n    if (this._renderTree.isDirty) {\n      currentRange = this.range\n    }\n\n    // force the current snapshot's range to remain the same rather than\n    // rereading it from DOM after the new character is applied and the browser\n    // updates the cursor position\n    const editHistory = this._editHistory!\n    const pendingSnapshot = editHistory._pendingSnapshot!\n\n    const range = pendingSnapshot.range\n    this.run(() => {\n      pendingSnapshot.range = range\n    })\n\n    this.rerender()\n\n    if (currentRange) {\n      this.selectRange(currentRange)\n    }\n\n    this.runCallbacks(CALLBACK_QUEUES.DID_REPARSE)\n    this._postDidChange()\n  }\n\n  // FIXME this should be able to be removed now -- if any sections are detached,\n  // it's due to a bug in the code.\n  _removeDetachedSections() {\n    forEach(\n      filter(this.post.sections, s => !s.renderNode.isAttached()),\n      s => s.renderNode.scheduleForRemoval()\n    )\n  }\n\n  /**\n   * The sections from the cursor's selection start to the selection end\n   * @type {Section[]}\n   */\n  get activeSections() {\n    return this._editState.activeSections\n  }\n\n  get activeSection() {\n    const { activeSections } = this\n    return activeSections[activeSections.length - 1]\n  }\n\n  get activeSectionAttributes() {\n    return this._editState.activeSectionAttributes\n  }\n\n  detectMarkupInRange(range: Range, markupTagName: string) {\n    let markups = this.post.markupsInRange(range)\n    return detect(markups, markup => {\n      return markup.hasTag(markupTagName)\n    })\n  }\n\n  /**\n   * @type {Markup[]}\n   * @public\n   */\n  get activeMarkups() {\n    return this._editState.activeMarkups\n  }\n\n  /**\n   * @param {Markup|String} markup A markup instance, or a string (e.g. \"b\")\n   * @return {boolean}\n   */\n  hasActiveMarkup(markup: Markup | string): boolean {\n    let matchesFn: (markup: Markup) => boolean\n\n    if (typeof markup === 'string') {\n      let tagName = normalizeTagName(markup)\n      matchesFn = m => m.tagName === tagName\n    } else {\n      matchesFn = m => m === markup\n    }\n\n    return !!detect(this.activeMarkups, matchesFn)\n  }\n\n  /**\n   * @param {String} version The mobiledoc version to serialize to.\n   * @return {Mobiledoc} Serialized mobiledoc\n   * @public\n   */\n  serialize(version: MobiledocVersion = MOBILEDOC_VERSION): Mobiledoc {\n    return this.serializePost(this.post, Format.MOBILEDOC, { version })\n  }\n\n  /**\n   * Serialize the editor's post to the requested format.\n   * Note that only mobiledoc format is lossless. If cards or atoms are present\n   * in the post, the html and text formats will omit them in output because\n   * the editor does not have access to the html and text versions of the\n   * cards/atoms.\n   * @param {string} format The format to serialize ('mobiledoc', 'text', 'html')\n   * @return {Object|String} The editor's post, serialized to {format}\n   * @public\n   */\n  serializeTo(format: Format.MOBILEDOC): Mobiledoc\n  serializeTo(format: Format.TEXT | Format.HTML): string\n  serializeTo(format: Format): Mobiledoc | string {\n    let post = this.post\n    return this.serializePost(post, format)\n  }\n\n  /**\n   * @param {Post}\n   * @param {String} format Same as {serializeTo}\n   * @param {Object} [options]\n   * @param {String} [options.version=MOBILEDOC_VERSION] version to serialize to\n   * @return {Object|String}\n   * @private\n   */\n  serializePost(post: Post, format: Format.MOBILEDOC, options?: SerializeOptions): Mobiledoc\n  serializePost(post: Post, format: Format.TEXT | Format.HTML, options?: SerializeOptions): string\n  serializePost(post: Post, format: Format, options?: SerializeOptions): string | Mobiledoc\n  serializePost(post: Post, format: Format, options: SerializeOptions = {}): string | Mobiledoc {\n    assert(`Unrecognized serialization format ${format}`, contains(Object.values(Format), format))\n\n    if (format === Format.MOBILEDOC) {\n      let version: MobiledocVersion = options.version || MOBILEDOC_VERSION\n      return mobiledocRenderers.render(post, version)\n    } else {\n      let mobiledoc = this.serializePost(post, Format.MOBILEDOC)\n      let unknownCardHandler = () => {}\n      let unknownAtomHandler = () => {}\n      let rendererOptions = { unknownCardHandler, unknownAtomHandler }\n\n      switch (format) {\n        case Format.HTML: {\n          if (Environment.hasDOM()) {\n            const rendered = new DOMRenderer(rendererOptions).render(mobiledoc)\n            return `<div>${serializeHTML(rendered.result)}</div>`\n          } else {\n            // Fallback to text serialization\n            return this.serializePost(post, Format.TEXT, options)\n          }\n        }\n        case Format.TEXT: {\n          let rendered = new TextRenderer(rendererOptions).render(mobiledoc)\n          return rendered.result\n        }\n      }\n    }\n  }\n\n  addView(view: View) {\n    this._views.push(view)\n  }\n\n  removeAllViews() {\n    this._views.forEach(v => v.destroy())\n    this._views = []\n  }\n\n  /**\n   * Whether the editor has a cursor (or a selected range).\n   * It is possible for the editor to be focused but not have a selection.\n   * In this case, key events will fire but the editor will not be able to\n   * determine a cursor position, so they will be ignored.\n   * @return {boolean}\n   * @public\n   */\n  hasCursor(): boolean {\n    return this.cursor.hasCursor()\n  }\n\n  /**\n   * Tears down the editor's attached event listeners and views.\n   * @public\n   */\n  destroy() {\n    this.isDestroyed = true\n    if (this._hasSelection()) {\n      this.cursor.clearSelection()\n    }\n    if (this._hasFocus()) {\n      this.element.blur() // FIXME This doesn't blur the element on IE11\n    }\n    this._mutationHandler.destroy()\n    this._eventManager.destroy()\n    this.removeAllViews()\n    this._renderer.destroy()\n    this._editState.destroy()\n  }\n\n  /**\n   * Keep the user from directly editing the post using the keyboard and mouse.\n   * Modification via the programmatic API is still permitted.\n   * @see Editor#enableEditing\n   * @public\n   */\n  disableEditing() {\n    this.isEditable = false\n    if (this.hasRendered) {\n      this._eventManager.stop()\n      this.element.setAttribute('contentEditable', 'false')\n      this.setPlaceholder('')\n      this.selectRange(Range.blankRange())\n    }\n  }\n\n  /**\n   * Allow the user to directly interact with editing a post via keyboard and mouse input.\n   * Editor instances are editable by default. Use this method to re-enable\n   * editing after disabling it.\n   * @see Editor#disableEditing\n   * @public\n   */\n  enableEditing() {\n    this.isEditable = true\n    if (this.hasRendered) {\n      this._eventManager.start()\n      this.element.setAttribute('contentEditable', 'true')\n      this.setPlaceholder(this.placeholder)\n    }\n  }\n\n  /**\n   * Change a cardSection into edit mode\n   * If called before the card has been rendered, it will be marked so that\n   * it is rendered in edit mode when it gets rendered.\n   * @param {CardSection} cardSection\n   * @public\n   */\n  editCard(cardSection: Card) {\n    this._setCardMode(cardSection, CardMode.EDIT)\n  }\n\n  /**\n   * Change a cardSection into display mode\n   * If called before the card has been rendered, it will be marked so that\n   * it is rendered in display mode when it gets rendered.\n   * @param {CardSection} cardSection\n   * @return undefined\n   * @public\n   */\n  displayCard(cardSection: Card) {\n    this._setCardMode(cardSection, CardMode.DISPLAY)\n  }\n\n  /**\n   * Run a new post editing session. Yields a block with a new {@link PostEditor}\n   * instance. This instance can be used to interact with the post abstract.\n   * Rendering will be deferred until after the callback is completed.\n   *\n   * Usage:\n   * ```\n   *   let markerRange = this.range;\n   *   editor.run((postEditor) => {\n   *     postEditor.deleteRange(markerRange);\n   *     // editing surface not updated yet\n   *     postEditor.schedule(() => {\n   *       console.log('logs during rerender flush');\n   *     });\n   *     // logging not yet flushed\n   *   });\n   *   // editing surface now updated.\n   *   // logging now flushed\n   * ```\n   *\n   * @param {Function} callback Called with an instance of\n   *        {@link PostEditor} as its argument.\n   * @return {Mixed} The return value of `callback`.\n   * @public\n   */\n  run<T>(callback: (postEditor: PostEditor) => T): T {\n    const postEditor = new PostEditor(this)\n    postEditor.begin()\n    this._editHistory.snapshot()\n    const result = callback(postEditor)\n    this.runCallbacks(CALLBACK_QUEUES.DID_UPDATE, [postEditor])\n    postEditor.complete()\n    this._readRangeFromDOM()\n\n    if (postEditor._shouldCancelSnapshot) {\n      this._editHistory._pendingSnapshot = null\n    }\n    this._editHistory.storeSnapshot(postEditor.editActionTaken)\n\n    return result\n  }\n\n  /**\n   * @param {Function} callback Called with `postEditor` as its argument.\n   * @public\n   */\n  didUpdatePost(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.DID_UPDATE, callback)\n  }\n\n  /**\n   * @param {Function} callback Called when the post has changed, either via\n   *        user input or programmatically. Use with {@link Editor#serialize} to\n   *        retrieve the post in portable mobiledoc format.\n   */\n  postDidChange(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.POST_DID_CHANGE, callback)\n  }\n\n  /**\n   * Register a handler that will be invoked by the editor after the user enters\n   * matching text.\n   * @param {Object} inputHandler\n   * @param {String} inputHandler.name Required. Used by identifying handlers.\n   * @param {String} [inputHandler.text] Required if `match` is not provided\n   * @param {RegExp} [inputHandler.match] Required if `text` is not provided\n   * @param {Function} inputHandler.run This callback is invoked with the {@link Editor}\n   *                   instance and an array of matches. If `text` was provided,\n   *                   the matches array will equal [`text`], and if a `match`\n   *                   regex was provided the matches array will be the result of\n   *                   `match.exec` on the matching text. The callback is called\n   *                   after the matching text has been inserted.\n   * @public\n   */\n  onTextInput(inputHandler: TextInputHandlerListener) {\n    this._eventManager.registerInputHandler(inputHandler)\n  }\n\n  /**\n   * Unregister all text input handlers\n   *\n   * @public\n   */\n  unregisterAllTextInputHandlers() {\n    this._eventManager.unregisterAllTextInputHandlers()\n  }\n\n  /**\n   * Unregister text input handler by name\n   * @param {String} name The name of handler to be removed\n   *\n   * @public\n   */\n  unregisterTextInputHandler(name: string) {\n    this._eventManager.unregisterInputHandler(name)\n  }\n\n  /**\n   * @param {Function} callback Called when the editor's state (active markups or\n   * active sections) has changed, either via user input or programmatically\n   */\n  inputModeDidChange(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.INPUT_MODE_DID_CHANGE, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before the editor\n   *        is rendered.\n   * @public\n   */\n  willRender(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.WILL_RENDER, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called after the editor\n   *        is rendered.\n   * @public\n   */\n  didRender(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.DID_RENDER, callback)\n  }\n\n  willCopy(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.WILL_COPY, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before pasting.\n   * @public\n   */\n  willPaste(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.WILL_PASTE, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before deleting.\n   * @public\n   */\n  willDelete(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.WILL_DELETE, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called after deleting.\n   * @public\n   */\n  didDelete(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.DID_DELETE, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called before handling new line.\n   * @public\n   */\n  willHandleNewline(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.WILL_HANDLE_NEWLINE, callback)\n  }\n\n  /**\n   * @param {Function} callback This callback will be called every time the cursor\n   *        position (or selection) changes.\n   * @public\n   */\n  cursorDidChange(callback: LifecycleCallback) {\n    this.addCallback(CALLBACK_QUEUES.CURSOR_DID_CHANGE, callback)\n  }\n\n  _rangeDidChange() {\n    if (this.hasRendered) {\n      this.runCallbacks(CALLBACK_QUEUES.CURSOR_DID_CHANGE)\n    }\n  }\n\n  _inputModeDidChange() {\n    this.runCallbacks(CALLBACK_QUEUES.INPUT_MODE_DID_CHANGE)\n  }\n\n  _insertEmptyMarkupSectionAtCursor() {\n    this.run(postEditor => {\n      const section = postEditor.builder.createMarkupSection('p')\n      postEditor.insertSectionBefore(this.post.sections, section)\n      postEditor.setRange(section.toRange())\n    })\n  }\n\n  /**\n   * @callback editorBeforeCallback\n   * @param { Object } details\n   * @param { Markup } details.markup\n   * @param { Range } details.range\n   * @param { boolean } details.willAdd Whether the markup will be applied\n   */\n\n  /**\n   * Register a callback that will be run before {@link Editor#toggleMarkup} is applied.\n   * If any callback returns literal `false`, the toggling of markup will be canceled.\n   * Note this only applies to calling `editor#toggleMarkup`. Using `editor.run` and\n   * modifying markup with the `postEditor` will skip any `beforeToggleMarkup` callbacks.\n   * @param {editorBeforeCallback}\n   */\n  beforeToggleMarkup(callback: LifecycleCallback) {\n    this._beforeHooks.toggleMarkup.push(callback)\n  }\n\n  /**\n   * Toggles the given markup at the editor's current {@link Range}.\n   * If the range is collapsed this changes the editor's state so that the\n   * next characters typed will be affected. If there is text selected\n   * (aka a non-collapsed range), the selections' markup will be toggled.\n   * If the editor is not focused and has no active range, nothing happens.\n   * Hooks added using #beforeToggleMarkup will be run before toggling,\n   * and if any of them returns literal false, toggling the markup will be canceled\n   * and no change will be applied.\n   * @param {String} markup E.g. \"b\", \"em\", \"a\"\n   * @param {Object} [attributes={}] E.g. {href: \"http://bustle.com\"}\n   * @public\n   * @see PostEditor#toggleMarkup\n   */\n  toggleMarkup(markupTag: string, attributes: Dict<string> = {}) {\n    const markup = this.builder.createMarkup(markupTag, attributes)\n    const { range } = this\n    const willAdd = !this.detectMarkupInRange(range, markup.tagName)\n    const shouldCancel = this._runBeforeHooks('toggleMarkup', { markup, range, willAdd })\n\n    if (shouldCancel) {\n      return\n    }\n\n    if (range.isCollapsed) {\n      this._editState.toggleMarkupState(markup)\n      this._inputModeDidChange()\n\n      // when clicking a button to toggle markup, the button can end up being focused,\n      // so ensure the editor is focused\n      this._ensureFocus()\n    } else {\n      this.run(postEditor => postEditor.toggleMarkup(markup, range))\n    }\n  }\n\n  // If the editor has a selection but is not focused, focus it\n  _ensureFocus() {\n    if (this._hasSelection() && !this._hasFocus()) {\n      this.focus()\n    }\n  }\n\n  focus() {\n    this.element.focus()\n  }\n\n  /**\n   * Whether there is a selection inside the editor's element.\n   * It's possible to have a selection but not have focus.\n   * @see #_hasFocus\n   * @return {Boolean}\n   */\n  _hasSelection(): boolean {\n    const { cursor } = this\n    return this.hasRendered && (cursor._hasCollapsedSelection() || cursor._hasSelection())\n  }\n\n  /**\n   * Whether the editor's element is focused\n   * It's possible to be focused but have no selection\n   * @see #_hasSelection\n   * @return {Boolean}\n   */\n  _hasFocus(): boolean {\n    return document.activeElement === this.element\n  }\n\n  /**\n   * Toggles the tagName for the current active section(s). This will skip\n   * non-markerable sections. E.g. if the editor's range includes a \"P\" MarkupSection\n   * and a CardSection, only the MarkupSection will be toggled.\n   * @param {String} tagName The new tagname to change to.\n   * @public\n   * @see PostEditor#toggleSection\n   */\n  toggleSection(tagName: string) {\n    this.run(postEditor => postEditor.toggleSection(tagName, this.range))\n  }\n\n  /**\n   * Sets an attribute for the current active section(s).\n   *\n   * @param {String} key The attribute. The only valid attribute is 'text-align'.\n   * @param {String} value The value of the attribute.\n   * @public\n   * @see PostEditor#setAttribute\n   */\n  setAttribute(key: string, value: string) {\n    this.run(postEditor => postEditor.setAttribute(key, value, this.range))\n  }\n\n  /**\n   * Removes an attribute from the current active section(s).\n   *\n   * @param {String} key The attribute. The only valid attribute is 'text-align'.\n   * @public\n   * @see PostEditor#removeAttribute\n   */\n  removeAttribute(key: string) {\n    this.run(postEditor => postEditor.removeAttribute(key, this.range))\n  }\n\n  /**\n   * Finds and runs the first matching key command for the event\n   *\n   * If multiple commands are bound to a key combination, the\n   * first matching one is run.\n   *\n   * If a command returns `false` then the next matching command\n   * is run instead.\n   *\n   * @param {Event} event The keyboard event triggered by the user\n   * @return {Boolean} true when a command was successfully run\n   * @private\n   */\n  handleKeyCommand(event: KeyboardEvent): boolean {\n    const keyCommands = findKeyCommands(this.keyCommands, event)\n    for (let i = 0; i < keyCommands.length; i++) {\n      let keyCommand = keyCommands[i]\n      if (keyCommand.run(this) !== false) {\n        event.preventDefault()\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Inserts the text at the current cursor position. If the editor has\n   * no current cursor position, nothing will be inserted. If the editor's\n   * range is not collapsed, it will be deleted before insertion.\n   *\n   * @param {String} text\n   * @public\n   */\n  insertText(text: string) {\n    if (!this.hasCursor()) {\n      return\n    }\n    if (this.post.isBlank) {\n      this._insertEmptyMarkupSectionAtCursor()\n    }\n    let {\n      activeMarkups,\n      range,\n      range: { head: position },\n    } = this\n\n    this.run(postEditor => {\n      if (!range.isCollapsed) {\n        position = postEditor.deleteRange(range)\n      }\n\n      postEditor.insertTextWithMarkup(position, text, activeMarkups)\n    })\n  }\n\n  /**\n   * Inserts an atom at the current cursor position. If the editor has\n   * no current cursor position, nothing will be inserted. If the editor's\n   * range is not collapsed, it will be deleted before insertion.\n   * @param {String} atomName\n   * @param {String} [atomText='']\n   * @param {Object} [atomPayload={}]\n   * @return {Atom} The inserted atom.\n   * @public\n   */\n  insertAtom(atomName: string, atomText: string = '', atomPayload: AtomPayload = {}): Maybe<Atom> {\n    if (!this.hasCursor()) {\n      return\n    }\n\n    if (this.post.isBlank) {\n      this._insertEmptyMarkupSectionAtCursor()\n    }\n\n    let atom: Atom\n    let { range } = this\n    this.run(postEditor => {\n      let position = range.head\n\n      atom = postEditor.builder.createAtom(atomName, atomText, atomPayload)\n      if (!range.isCollapsed) {\n        position = postEditor.deleteRange(range)\n      }\n\n      postEditor.insertMarkers(position, [atom])\n    })\n    return atom!\n  }\n\n  /**\n   * Inserts a card at the section after the current cursor position. If the editor has\n   * no current cursor position, nothing will be inserted. If the editor's\n   * range is not collapsed, it will be deleted before insertion. If the cursor is in\n   * a blank section, it will be replaced with a card section.\n   * The editor's cursor will be placed at the end of the inserted card.\n   * @param {String} cardName\n   * @param {Object} [cardPayload={}]\n   * @param {Boolean} [inEditMode=false] Whether the card should be inserted in edit mode.\n   * @return {Card} The inserted Card section.\n   * @public\n   */\n  insertCard(cardName: string, cardPayload: CardPayload = {}, inEditMode: boolean = false): Maybe<Card> {\n    if (!this.hasCursor()) {\n      return\n    }\n\n    if (this.post.isBlank) {\n      this._insertEmptyMarkupSectionAtCursor()\n    }\n\n    let card: Card\n    let { range } = this\n    this.run(postEditor => {\n      let position = range.tail\n      card = postEditor.builder.createCardSection(cardName, cardPayload)\n      if (inEditMode) {\n        this.editCard(card)\n      }\n\n      if (!range.isCollapsed) {\n        position = postEditor.deleteRange(range)\n      }\n\n      let section = position.section!\n      if (isNested(section)) {\n        section = section.parent\n      }\n\n      if (section.isBlank) {\n        postEditor.replaceSection(section, card)\n      } else {\n        let collection = this.post.sections\n        postEditor.insertSectionBefore(collection, card, section.next)\n      }\n\n      // It is important to explicitly set the range to the end of the card.\n      // Otherwise it is possible to create an inconsistent state in the\n      // browser. For instance, if the user clicked a button that\n      // called `editor.insertCard`, the editor surface may retain\n      // the selection but lose focus, and the next keystroke by the user\n      // will cause an unexpected DOM mutation (which can wipe out the\n      // card).\n      // See: https://github.com/bustle/mobiledoc-kit/issues/286\n      postEditor.setRange(card.tailPosition())\n    })\n    return card!\n  }\n\n  /**\n   * @param {integer} x x-position in viewport\n   * @param {integer} y y-position in viewport\n   * @return {Position|null}\n   */\n  positionAtPoint(x: number, y: number): Position | null {\n    return Position.atPoint(x, y, this)\n  }\n\n  /**\n   * @private\n   */\n  _setCardMode(cardSection: Card, mode: CardMode) {\n    const renderNode = cardSection.renderNode\n    if (renderNode && renderNode.isRendered) {\n      const cardNode = renderNode.cardNode!\n      cardNode[mode]()\n    } else {\n      cardSection.setInitialMode(mode)\n    }\n  }\n\n  triggerEvent(context: HTMLElement, eventName: DOMEventType, event: DOMEventForType<typeof eventName>) {\n    this._eventManager._trigger(context, eventName, event)\n  }\n\n  addCallback(queueName: string, callback: LifecycleCallback) {\n    this._callbacks.addCallback(queueName, callback)\n  }\n\n  addCallbackOnce(queueName: string, callback: LifecycleCallback) {\n    this._callbacks.addCallbackOnce(queueName, callback)\n  }\n\n  runCallbacks(queueName: string, args?: unknown[]) {\n    if (this.isDestroyed) {\n      // TODO warn that callback attempted after editor was destroyed\n      return\n    }\n    this._callbacks.runCallbacks(queueName, args)\n  }\n\n  /**\n   * Runs each callback for the given hookName.\n   * Only the hookName 'toggleMarkup' is currently supported\n   * @return {Boolean} shouldCancel Whether the action in `hookName` should be canceled\n   * @private\n   */\n  _runBeforeHooks(hookName: keyof BeforeHooks, ...args: unknown[]): true | undefined {\n    let hooks = this._beforeHooks[hookName] || []\n    for (let i = 0; i < hooks.length; i++) {\n      if (hooks[i](...args) === false) {\n        return true\n      }\n    }\n  }\n}\n","export default '##VERSION##'\n"],"names":["isMarkerable","isListSection","DEFAULT_TAG_NAME","FORWARD","BACKWARD","PostInserter","MobiledocParser","MOBILEDOC_VERSION","visitor","PostOpcodeCompiler","MOBILEDOC_VERSION_0_2","MobiledocParser_0_2","MOBILEDOC_VERSION_0_3","MobiledocParser_0_3","MOBILEDOC_VERSION_0_3_1","MobiledocParser_0_3_1","MOBILEDOC_VERSION_0_3_2","MobiledocParser_0_3_2","Visitor","VALID_ATTRIBUTES","isMarkupSection","sectionIsMarkupSection","sectionIsListSection","sectionIsListItem","DEFAULT_MARKUP_SECTION_TAG_NAME","DEFAULT_LIST_SECTION_TAG_NAME","ImageSection","normalizeTagName","MARKUP_SECTION_TYPE","LIST_SECTION_TYPE","MARKUP_SECTION_ELEMENT_NAMES","contains","Renderer","ImageCard","IMAGE_SECTION_TAG_NAME","validateVersion","validateCards","validateAtoms","Renderer_0_2","Renderer_0_3","IMAGE_SECTION_TYPE","CARD_SECTION_TYPE","RENDER_TYPE","MARKUP_MARKER_TYPE","ATOM_MARKER_TYPE","LINE_BREAK","RendererFactory","CALLBACK_QUEUES","DOMRenderer","TextRenderer"],"mappings":"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"}